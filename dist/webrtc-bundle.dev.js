// webrtc-bundle.dev.js 2.0.0
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {view: require('./lib/views/widget'), model: require('./lib/models/widget')};

require('./lib/loader');
},{"./lib/loader":4,"./lib/models/widget":5,"./lib/views/widget":6}],2:[function(require,module,exports){
module.exports = {"widget":".bdsft-reset{font-size:14px;font:normal normal 14px Open Sans,Arial,sans-serif}.bdsft-reset div,.bdsft-reset span,.bdsft-reset applet,.bdsft-reset object,.bdsft-reset iframe,.bdsft-reset h1,.bdsft-reset h2,.bdsft-reset h3,.bdsft-reset h4,.bdsft-reset h5,.bdsft-reset h6,.bdsft-reset p,.bdsft-reset blockquote,.bdsft-reset pre,.bdsft-reset a,.bdsft-reset abbr,.bdsft-reset acronym,.bdsft-reset address,.bdsft-reset big,.bdsft-reset cite,.bdsft-reset code,.bdsft-reset del,.bdsft-reset dfn,.bdsft-reset em,.bdsft-reset img,.bdsft-reset ins,.bdsft-reset kbd,.bdsft-reset q,.bdsft-reset s,.bdsft-reset samp,.bdsft-reset small,.bdsft-reset strike,.bdsft-reset strong,.bdsft-reset sub,.bdsft-reset sup,.bdsft-reset tt,.bdsft-reset var,.bdsft-reset b,.bdsft-reset u,.bdsft-reset i,.bdsft-reset center,.bdsft-reset dl,.bdsft-reset dt,.bdsft-reset dd,.bdsft-reset ol,.bdsft-reset ul,.bdsft-reset li,.bdsft-reset fieldset,.bdsft-reset form,.bdsft-reset div.form,.bdsft-reset label,.bdsft-reset legend,.bdsft-reset table,.bdsft-reset caption,.bdsft-reset tbody,.bdsft-reset tfoot,.bdsft-reset thead,.bdsft-reset tr,.bdsft-reset th,.bdsft-reset td,.bdsft-reset article,.bdsft-reset aside,.bdsft-reset canvas,.bdsft-reset details,.bdsft-reset figcaption,.bdsft-reset figure,.bdsft-reset footer,.bdsft-reset header,.bdsft-reset hgroup,.bdsft-reset menu,.bdsft-reset nav,.bdsft-reset section,.bdsft-reset summary,.bdsft-reset time,.bdsft-reset mark,.bdsft-reset audio,.bdsft-reset video,.bdsft-reset button,.bdsft-reset textarea,.bdsft-reset input{font-size:100%;font:normal normal 100% Open Sans,Arial,sans-serif}.bdsft-reset,.bdsft-reset div,.bdsft-reset span,.bdsft-reset applet,.bdsft-reset object,.bdsft-reset iframe,.bdsft-reset h1,.bdsft-reset h2,.bdsft-reset h3,.bdsft-reset h4,.bdsft-reset h5,.bdsft-reset h6,.bdsft-reset p,.bdsft-reset blockquote,.bdsft-reset pre,.bdsft-reset a,.bdsft-reset abbr,.bdsft-reset acronym,.bdsft-reset address,.bdsft-reset big,.bdsft-reset cite,.bdsft-reset code,.bdsft-reset del,.bdsft-reset dfn,.bdsft-reset em,.bdsft-reset img,.bdsft-reset ins,.bdsft-reset kbd,.bdsft-reset q,.bdsft-reset s,.bdsft-reset samp,.bdsft-reset small,.bdsft-reset strike,.bdsft-reset strong,.bdsft-reset sub,.bdsft-reset sup,.bdsft-reset tt,.bdsft-reset var,.bdsft-reset b,.bdsft-reset u,.bdsft-reset i,.bdsft-reset center,.bdsft-reset dl,.bdsft-reset dt,.bdsft-reset dd,.bdsft-reset ol,.bdsft-reset ul,.bdsft-reset li,.bdsft-reset fieldset,.bdsft-reset form,.bdsft-reset div.form,.bdsft-reset label,.bdsft-reset legend,.bdsft-reset table,.bdsft-reset caption,.bdsft-reset tbody,.bdsft-reset tfoot,.bdsft-reset thead,.bdsft-reset tr,.bdsft-reset th,.bdsft-reset td,.bdsft-reset article,.bdsft-reset aside,.bdsft-reset canvas,.bdsft-reset details,.bdsft-reset figcaption,.bdsft-reset figure,.bdsft-reset footer,.bdsft-reset header,.bdsft-reset hgroup,.bdsft-reset menu,.bdsft-reset nav,.bdsft-reset section,.bdsft-reset summary,.bdsft-reset time,.bdsft-reset mark,.bdsft-reset audio,.bdsft-reset video,.bdsft-reset button,.bdsft-reset textarea,.bdsft-reset input{font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal;alignment-adjust:auto;alignment-baseline:baseline;-webkit-animation:none 0 ease 0 1 normal;-moz-animation:none 0 ease 0 1 normal;-ms-animation:none 0 ease 0 1 normal;animation:none 0 ease 0 1 normal;-webkit-animation-play-state:running;-moz-play-state:running;-ms-animation-play-state:running;animation-play-state:running;appearance:normal;azimuth:center;backface-visibility:visible;background:none 0 0 auto repeat scroll padding-box transparent;background-color:transparent;background-image:none;baseline-shift:baseline;binding:none;bleed:6pt;bookmark-label:content();bookmark-level:none;bookmark-state:open;bookmark-target:none;border:0 none transparent;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;bottom:auto;box-align:stretch;box-decoration-break:slice;box-direction:normal;box-flex:0;box-flex-group:1;box-lines:single;box-ordinal-group:1;box-orient:inline-axis;box-pack:start;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;break-after:auto;break-before:auto;break-inside:auto;caption-side:top;clear:none;clip:auto;color:inherit;color-profile:auto;-webkit-column-count:auto;-webkit-column-fill:balance;-webkit-column-gap:normal;-webkit-column-rule:medium medium #1f1f1f;-webkit-column-span:1;-webkit-column-width:auto;-webkit-columns:auto auto;-moz-column-count:auto;-moz-column-fill:balance;-moz-column-gap:normal;-moz-column-rule:medium medium #1f1f1f;-moz-column-span:1;-moz-column-width:auto;-moz-columns:auto auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium medium #1f1f1f;column-span:1;column-width:auto;columns:auto auto;content:normal;counter-increment:none;counter-reset:none;crop:auto;cursor:auto;direction:ltr;display:inline;dominant-baseline:auto;drop-initial-after-adjust:text-after-edge;drop-initial-after-align:baseline;drop-initial-before-adjust:text-before-edge;drop-initial-before-align:caps-height;drop-initial-size:auto;drop-initial-value:initial;elevation:level;empty-cells:show;fit:fill;fit-position:0;float:none;float-offset:0;grid-columns:none;grid-rows:none;hanging-punctuation:none;height:auto;hyphenate-after:auto;hyphenate-before:auto;hyphenate-character:auto;hyphenate-lines:no-limit;hyphenate-resource:none;hyphens:manual;icon:auto;image-orientation:auto;image-rendering:auto;image-resolution:normal;inline-box-align:last;left:auto;line-height:inherit;line-stacking:inline-line-height exclude-ruby consider-shifts;list-style:disc outside none;margin:0;marks:none;marquee-direction:forward;marquee-loop:1;marquee-play-count:1;marquee-speed:normal;marquee-style:scroll;max-height:none;max-width:none;min-height:0;min-width:0;move-to:normal;nav-down:auto;nav-index:auto;nav-left:auto;nav-right:auto;nav-up:auto;opacity:1;orphans:2;outline:invert none medium;outline-offset:0;overflow:visible;overflow-style:auto;padding:0;page:auto;page-break-after:auto;page-break-before:auto;page-break-inside:auto;page-policy:start;perspective:none;perspective-origin:50% 50%;position:static;presentation-level:0;punctuation-trim:none;quotes:none;rendering-intent:auto;resize:none;right:auto;rotation:0;rotation-point:50% 50%;ruby-align:auto;ruby-overhang:none;ruby-position:before;ruby-span:none;size:auto;string-set:none;table-layout:auto;top:auto;-webkit-transform:none;-moz-transform:none;transform:none;-webkit-transform-origin:50% 50%;-moz-transform-origin:50% 50%;-o-transform-origin:50% 50%;transform-origin:50% 50% 0;transform-style:flat;-webkit-transition:all 0 ease 0;-moz-transition:all 0 ease 0;-o-transition:all 0 ease 0;transition:all 0 ease 0;unicode-bidi:normal;vertical-align:baseline;white-space:normal;white-space-collapse:collapse;widows:2;width:auto;word-break:normal;word-spacing:normal;word-wrap:normal;z-index:auto;text-align:start}.bdsft-reset address,.bdsft-reset blockquote,.bdsft-reset dd,.bdsft-reset div,.bdsft-reset dl,.bdsft-reset dt,.bdsft-reset fieldset,.bdsft-reset form,.bdsft-reset div.form,.bdsft-reset frame,.bdsft-reset frameset,.bdsft-reset h1,.bdsft-reset h2,.bdsft-reset h3,.bdsft-reset h4,.bdsft-reset h5,.bdsft-reset h6,.bdsft-reset noframes,.bdsft-reset ol,.bdsft-reset p,.bdsft-reset ul,.bdsft-reset center,.bdsft-reset dir,.bdsft-reset hr,.bdsft-reset menu,.bdsft-reset pre,.bdsft-reset article,.bdsft-reset aside,.bdsft-reset canvas,.bdsft-reset details,.bdsft-reset figcaption,.bdsft-reset figure,.bdsft-reset footer,.bdsft-reset header,.bdsft-reset hgroup,.bdsft-reset nav,.bdsft-reset section,.bdsft-reset summary{display:block}.bdsft-reset li{display:list-item}.bdsft-reset table{display:table}.bdsft-reset tr{display:table-row}.bdsft-reset thead{display:table-header-group}.bdsft-reset tbody{display:table-row-group}.bdsft-reset tfoot{display:table-footer-group}.bdsft-reset col{display:table-column}.bdsft-reset colgroup{display:table-column-group}.bdsft-reset td,.bdsft-reset th{display:table-cell}.bdsft-reset caption{display:table-caption}.bdsft-reset input,.bdsft-reset select{display:inline-block}.bdsft-reset b,.bdsft-reset strong,.bdsft-reset strong>*{font-weight:bold}.bdsft-reset textarea,.bdsft-reset input{cursor:text}.bdsft-reset textarea .bdsft-reset textarea::-webkit-input-placeholder,.bdsft-reset input .bdsft-reset textarea::-webkit-input-placeholder,.bdsft-reset textarea .bdsft-reset input::-webkit-input-placeholder,.bdsft-reset input .bdsft-reset input::-webkit-input-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset textarea .bdsft-reset textarea:-moz-placeholder,.bdsft-reset input .bdsft-reset textarea:-moz-placeholder,.bdsft-reset textarea .bdsft-reset input:-moz-placeholder,.bdsft-reset input .bdsft-reset input:-moz-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset textarea .bdsft-reset textarea::-moz-placeholder,.bdsft-reset input .bdsft-reset textarea::-moz-placeholder,.bdsft-reset textarea .bdsft-reset input::-moz-placeholder,.bdsft-reset input .bdsft-reset input::-moz-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset textarea .bdsft-reset textarea:-ms-input-placeholder,.bdsft-reset input .bdsft-reset textarea:-ms-input-placeholder,.bdsft-reset textarea .bdsft-reset input:-ms-input-placeholder,.bdsft-reset input .bdsft-reset input:-ms-input-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset input[type=checkbox],.bdsft-reset input[type=radio]{cursor:default}.bdsft-reset a,.bdsft-reset a *,.bdsft-reset a span,.bdsft-reset button,.bdsft-reset button *,.bdsft-reset button span,.bdsft-reset input[type=submit],.bdsft-reset input[type=reset]{cursor:pointer}.bdsft-reset a:link,.bdsft-reset a:visited,.bdsft-reset a:hover,.bdsft-reset a:active{color:inherit;background:transparent;text-shadow:none}.bdsft-reset button::-moz-focus-inner{border:0;padding:0}.bdsft-reset *[class^='bdsft-icon']{font-family:FontAwesome!important}.bdsft-webrtc button{border:0;border-radius:20px;padding:5px 10px;font-size:14px;color:#fff;background-color:#999;text-align:center}.bdsft-webrtc input,.bdsft-webrtc textarea{background:#333;border:1px solid #3c3c3c;color:#d3d3d3;font-family:arial;font-size:18px;padding:0;border-radius:0}.bdsft-webrtc input:focus,.bdsft-webrtc textarea:focus{outline:0}.bdsft-webrtc .button:hover{box-shadow:0 0 10px #999}.bdsft-webrtc .ui-widget-content.ui-dialog{display:none;color:#999;font-size:22px;background:#333;padding:10px;border:2px solid #ddd;box-shadow:0 0 10px #999;border-radius:3px;z-index:99}.bdsft-webrtc .no-close .ui-dialog-titlebar-close{display:none}.bdsft-webrtc .unsupported{position:absolute;top:240px;left:30px;width:600px;background-color:#191414;text-align:center;display:none;color:#fff;z-index:10}.bdsft-webrtc .historyRowSample{display:none}.bdsft-webrtc [id$=\"sample\"]{display:none!important}.bdsft-webrtc #javascript_disabled{display:block;background-color:#fff;color:#000}.bdsft-webrtc a.disabled{pointer-events:none;cursor:default;background-color:#999;opacity:.5}.bdsft-webrtc .main{position:relative;top:0;left:0;width:100%}.bdsft-webrtc .client{position:relative;top:0;left:0}.bdsft-webrtc .client::-webkit-scrollbar{width:8px}.bdsft-webrtc .client::-webkit-scrollbar-track,.bdsft-webrtc .client::-webkit-scrollbar-thumb{background:#272727}.bdsft-webrtc .client::-webkit-scrollbar-track:window-inactive,.bdsft-webrtc .client::-webkit-scrollbar-thumb:window-inactive{background:#272727}.bdsft-webrtc .client._960x720{width:960px}.bdsft-webrtc .client._640x360,.bdsft-webrtc .client._640x480{width:640px}.bdsft-webrtc .client._320x180,.bdsft-webrtc .client._320x240{width:320px}.bdsft-webrtc .client._1280x720,.bdsft-webrtc .client.hd{width:1280px}.bdsft-webrtc .client .row:before,.bdsft-webrtc .client .row:after{display:none}.bdsft-webrtc .client.audioOnly{display:inline-block;width:auto}.bdsft-webrtc .client.fullscreen-shown{width:100%!important;height:100%!important;top:0;left:0;position:absolute}.bdsft-webrtc .client.fullscreen-shown .main{height:100%}.bdsft-webrtc .main:-webkit-full-screen-ancestor:not(iframe){position:absolute!important;top:0;left:0;right:0;bottom:0;width:100%;height:100%}.bdsft-webrtc #screen_sharing_unsupported{position:relative;top:0;left:0;margin:10px;background:#f00;display:none}.bdsft-webrtc #screen_sharing_unsupported span{text-decoration:underline}"}
},{}],3:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else {
        if (typeof root === 'undefined' || root !== Object(root)) {
            throw new Error('templatizer: window does not exist or is not an object');
        }
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)r.push(e&&e[i]?a.escape(t([n[i]])):t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}(); 

    var templatizer = {};


    // widget.jade compiled template
    templatizer["widget"] = function tmpl_widget() {
        return '<div class="wrapper bdsft-reset bdsft-webrtc"><div id="unsupported" class="unsupported"></div><div id="whiteboard_unsupported" class="unsupported"></div><div id="screen_sharing_unsupported" class="unsupported">Could not retrieve screen capture. Do you have it enabled?<br/>Open link to check : <span>chrome://flags/#enable-usermedia-screen-capture</span></div><noscript><div id="javascript_disabled" class="unsupported">JavaScript must be enabled to load the WebRTC client</div></noscript><div id="conversejs"></div><div class="client classes"><div class="main"><div class="errorPopup"></div></div></div></div>';
    };

    return templatizer;
}));

},{"fs":7}],4:[function(require,module,exports){
var loader = require('webrtc-core').loader;
var Widget = require('../');

var widgetLoader = loader(Widget, {
      // Overwrite styles and templates
      // style: {
      //       authentication: require('../js/styles').authentication
      // },
      // template: {
      //       authentication: require('../js/templates').authentication
      // },
      dependencies: {
            audio: require("webrtc-audio"),
            authentication: require("webrtc-authentication"),
            chat: require("webrtc-chat"),
            dialpad: require("webrtc-dialpad"),
            callcontrol: require("webrtc-callcontrol"),
            connectionstatus: require("webrtc-connectionstatus"),
            fullscreen: require("webrtc-fullscreen"),
            history: require("webrtc-history"),
            incomingcall: require("webrtc-incomingcall"),
            messages: require("webrtc-messages"),
            settings: require("webrtc-settings"),
            sipstack: require("webrtc-sipstack"),
            stats: require("webrtc-stats"),
            sound: require("webrtc-sound"),
            timer: require("webrtc-timer"),
            transfer: require("webrtc-transfer"),
            video: require("webrtc-video"),
            videobar: require("webrtc-videobar"),
            widget: Widget
      }
});

window.BroadSoftWebRTC = window.BroadSoftWebRTC || {};
window.BroadSoftWebRTC.loader = widgetLoader;

module.exports = widgetLoader;
},{"../":1,"webrtc-audio":14,"webrtc-authentication":71,"webrtc-callcontrol":77,"webrtc-chat":134,"webrtc-connectionstatus":193,"webrtc-core":253,"webrtc-dialpad":301,"webrtc-fullscreen":305,"webrtc-history":311,"webrtc-incomingcall":370,"webrtc-messages":375,"webrtc-settings":433,"webrtc-sipstack":491,"webrtc-sound":579,"webrtc-stats":634,"webrtc-timer":693,"webrtc-transfer":751,"webrtc-video":757,"webrtc-videobar":815}],5:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Widget);

var Constants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function Widget(eventbus, video, urlconfig, cookieconfig, fullscreen) {
  var self = {};

  self.props = ['classes'];

  self.bindings = {
    classes: {
        video: 'displayResolution',
        fullscreen: 'visible',
        urlconfig: ['view', 'hd'],
        cookieconfig: ['hd'],
    }
  }

  return self;
}
},{"webrtc-core":253}],6:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(WidgetView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

var WebRTC_C = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;
var PopupView = require('webrtc-core').popup;
var defaults = require('webrtc-core').defaults;

function WidgetView(eventbus, debug, videoView, videobarView, callcontrolView, sipstack, transferView, authenticationView, 
  incomingcallView, messagesView, settingsView, connectionstatusView, statsView, historyView, chatView, widget) {
  var self = {};

  self.model = widget;

  self.elements = ['client', 'main'];

  self.visibilities = {};

  self.appendTo = function(parent) {
    parent.append(self.view);
  };
  self.remove = function() {
    self.view.remove();
  };

  self.init = function() {
    var unsupported = Utils.compatibilityCheck();
    if (unsupported) {
      Utils.getElement('#unsupported').html(unsupported).show();
    }

    // var whiteboardUnsupported = Utils.whiteboardCompabilityCheck();
    // if (whiteboardUnsupported) {
    //   Utils.getElement('#whiteboard_unsupported').html(whiteboardUnsupported).show();
    // }

    videoView.view.appendTo(self.main);
    videobarView.view.appendTo(self.main);
    messagesView.view.appendTo(self.main);
    connectionstatusView.view.appendTo(self.main);

    PopupView(authenticationView, eventbus, {parent: self.main});
    PopupView(callcontrolView, eventbus, {parent: self.main});
    PopupView(incomingcallView, eventbus, {parent: self.main});
    PopupView(settingsView, eventbus, {parent: self.main});
    PopupView(transferView, eventbus, {parent: self.main});
    PopupView(chatView, eventbus, {parent: self.main, modifier: 67});
    PopupView(historyView, eventbus, {parent: self.main, modifier: 72});
    PopupView(statsView, eventbus, {parent: self.main, modifier: 83});
  };

  self.listeners = function() {
    // $(document).unbind('keypress').bind('keypress', function(e) {});
    // $(document).unbind('keydown').bind('keydown', function(event) {
    document.addEventListener('keydown', function(event) {
      var isModifier = event.altKey;
      if (isModifier) {
        if (transferView.target.is(event.target)) {
          return;
        }
        eventbus.modifier(event.which);
        event.stopPropagation();
      }
    });
  };

  return self;
}
},{"../../js/styles":2,"../../js/templates":3,"webrtc-core":253}],7:[function(require,module,exports){

},{}],8:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":9,"ieee754":10,"is-array":11}],9:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],10:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],11:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],12:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":13}],13:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],14:[function(require,module,exports){
module.exports = {view: require('./lib/views/audio'), model: require('./lib/models/audio')};
},{"./lib/models/audio":18,"./lib/views/audio":19}],15:[function(require,module,exports){
module.exports = {
    enableMute: true
};
},{}],16:[function(require,module,exports){
module.exports = {"audio":".bdsft-webrtc .enableMute:not(.muted).started .mute,.bdsft-webrtc .enableMute.muted.started .unmute{transition:all 1s linear;opacity:1;z-index:20}.bdsft-webrtc .enableMute:not(.started) .mute,.bdsft-webrtc .enableMute:not(.started) .unmute,.bdsft-webrtc .enableMute.muted.started .mute,.bdsft-webrtc .enableMute:not(.muted).started .unmute{transition:all 1s linear;opacity:0;z-index:-1}.bdsft-webrtc :not(.enableMute).cell-muteAudio{display:none!important}"}
},{}],17:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // audio.jade compiled template
    templatizer["audio"] = function tmpl_audio() {
        return '<div class="bdsft-webrtc"><div class="cell cell-muteAudio classes"><div class="icon fadeable mute"><a href="" title="Mute Audio" class="icon-muteAudio"></a></div><div class="icon fadeable unmute"><a href="" title="Unmute Audio" class="icon-unmuteAudio"></a></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],18:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Audio, {
  config: require('../../js/config')
});

var utils = require('webrtc-core').utils;

function Audio(eventbus, sipstack, urlconfig) {
  var self = {};

  self.updateLocalAudio = function() {
    enableLocalAudio(!self.muted);
  };

  var enableLocalAudio = function(enabled) {
    var localStreams = sipstack.getLocalStreams();
    if (!localStreams || localStreams.length === 0) {
      return;
    }
    var localMedia = localStreams[0];
    var localAudio = localMedia.getAudioTracks()[0];
    localAudio.enabled = enabled;
  };

  self.props = ['muted', 'classes'];

  self.bindings = {
    classes: {
        audio: ['muted', 'enableMute'],
        sipstack: 'callState'
      },
    localAudio: {
      audio: 'muted'
    },
    enableMute: {
      urlconfig: 'enableMute'
    }
  };

  self.mute = function() {
    self.muted = true;
  };

  self.unmute = function() {
    self.muted = false;
  };
  
  self.listeners = function() {
    eventbus.on(["resumed", "started", "userMediaUpdated"], function() {
      self.updateLocalAudio();
    });
  };

  return self;
}

},{"../../js/config":15,"webrtc-core":23}],19:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(AudioView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

function AudioView(audio, sound) {
  var self = {};

  self.elements = ['mute', 'unmute'];

  var clickHander = function(callback){
    return function(e) {
      e.preventDefault();
      sound.playClick();
      callback();
    }
  }

  self.listeners = function() {
    self.mute.bind('click', clickHander(function() {
      audio.mute();
    }));
    self.unmute.bind('click', clickHander(function() {
      audio.unmute();
    }));
  };

  return self;
}
},{"../../js/styles":16,"../../js/templates":17,"webrtc-core":23}],20:[function(require,module,exports){
module.exports = {
	debug: {
		names: '*',
		level: 'debug'
	},
	urlconfig: {
		view: 'audioVideo'
	}
}

},{}],21:[function(require,module,exports){
module.exports = {"core":"@font-face{font-family:'Exario-Icon-Fonts';src:url(\"../fonts/Exario-Icon-Fonts.eot?\") format(\"embedded-opentype\")}@font-face{font-family:'Exario-Icon-Fonts';src:url(\"data:application/font-woff;base64,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\") format(\"woff\"),url(\"data:application/x-font-ttf;base64,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\") format(\"truetype\"),url(\"../fonts/Exario-Icon-Fonts.svg#Exario-Icon-Fonts\") format(\"svg\");font-weight:normal;font-style:normal}@font-face{font-family:'bsl_icons';src:url(\"../fonts/bsl_icons.eot?\") format(\"embedded-opentype\")}@font-face{font-family:'bsl_icons';src:url(\"data:application/font-woff;base64,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N3JgWV1XfTGc+xSMgoiFgoeIiomKiYuFi4aOh5CHkIeRh5KHkYOYgZ+AnoGeg54Ig52EoYSkhaSHoougi56MnIybjZuNnY+dj52RnJGakpqUm5ablpuYmZqXmpedl6CWCKCWo5Slk6aSqZGuj62PsI60iwjmi4v3AQWLm5OXmpGQjY+MkIuVi5OHk4QI92/7bwWSg4+Di4GLgYeChIQIDvtv+bn3hhWLgYl+h3qHeod+h4KDeHR3ZHVneGiBaIuBi4GMgYyBjICOf45/j4KNhY6FjYCPfJAIfJGCjoeNZphpm26dWqlZtFe/V79ivm27eal7rH2wio+IlIWahZuIlYiRiZGJlIeXCIiXiJaKlYqVipWLlYuula6er6CyoKKek5SPmI+cj5uPmY2Vi5CLj4qOipKJlXyYcQiQg5CBk36SfZF/koCRgZGAkIKMiY+HkIORg4+EjoWNho2Fi4aLg4WCgH+AgICBfoEIfoF/gYCBgYCFgouEi4iMh42GjYWNiIyIjIiOh4+Ej4WNh4uKqFetXrBmsGa4ar9uCIyKj4mRh5GHkIiOio2Kj4mQiZGJj4qOi5KLlJGWlpWVlZeVmJSYlpeWlZeWlJGTiwiQi5GJkImRiJGHk4WThpCIjYmUhpWFloWWhZeEmYSYg5WGkoemfZqBjYSMiYyHi4UIDv0m9+j4JhWLhomHh4cI+577ngWHh4eJhouGi4eNh48IbqcFh4+JkIuQi5CNj4+PCPd193T7dfd1BYePiY+LkIuQjY+PjwioqAWPj4+MkIuQi4+Kj4cI9577nwWPiI2Gi4YIDviU+fQV+3qL+077Tov7eov7evdO+073eov3eov3TvdOi/d6i/d6+073Tvt6iwj3fPu+FfvD+8MFg4N/i4OTCIWRi4v7O/c8BYOTi5eTkwi0tAWTk5eLk4MI9wr7C/eM94wFk5OXi5ODCLRiBZODi3+DgwgO+JSrFft6i/tO906L93qL93r3TvdO93qL93qL9077Tov7eov7evtO+077eosI91P4rRWTk4uYg5MIYLUFg5N/i4ODCPsM+wz7DfcMBYOTf4uDgwhgYQWEg4t+koMI9w37DPsN+wwFhIOLfpKDCLZhBZODl4uTkwj3DfcM9wz7DAWTg5eLk5MItrUFk5OLmIOTCPsN9wz3DfcMBQ74hPnkFft6i/tO+06L+3qL+3r3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\") format(\"woff\"),url(\"data:application/x-font-ttf;base64,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\") format(\"truetype\"),url(\"../fonts/bsl_icons.svg#bsl_icons\") format(\"svg\");font-weight:normal;font-style:normal}.bdsft-webrtc [class^=\"icon-\"],.bdsft-webrtc [class*=\" icon-\"]{font-family:'bsl_icons';speak:none;font-style:normal;font-weight:normal;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.bdsft-webrtc [class^=\"icon-\"].exario{font-family:'Exario-Icon-Fonts';speak:none;text-decoration:none;margin:0 .35em 0 0;font-size:25px}.bdsft-webrtc .icon-link:before{content:\"\\e00b\"}.bdsft-webrtc .icon{cursor:pointer}.bdsft-webrtc .icon a{speak:none;text-decoration:none;margin:0 .35em 0 0}.bdsft-webrtc .icon a:before{color:#fff}.bdsft-webrtc .icon-quality:before{color:#0f0;opacity:.4}.bdsft-webrtc .icon-quality1:before{content:\"\\e007\"}.bdsft-webrtc .icon-quality2:before{content:\"\\e006\"}.bdsft-webrtc .icon-quality3:before{content:\"\\e005\"}.bdsft-webrtc .icon-quality4:before{content:\"\\e004\"}.bdsft-webrtc .icon-trash:before{content:\"\\e013\";color:#f00}.bdsft-webrtc .icon-screen-sharing:before{content:\"\\e604\"}.bdsft-webrtc .icon-screen-sharing-off:before{content:\"\\e605\"}.bdsft-webrtc .icon-dialpadShow:before,.bdsft-webrtc .icon-dialpadShow:hover:before,.bdsft-webrtc .icon-dialpadHide:before,.bdsft-webrtc .icon-dialpadHide:hover:before{content:\"\\ed3b\"}.bdsft-webrtc a.icon-hangup:before,.bdsft-webrtc a.icon-hangup:hover:before{content:\"\\e600\";color:#f00}.bdsft-webrtc .icon-clock:before{content:\"\\e634\"}.bdsft-webrtc .icon-cog:before,.bdsft-webrtc .icon-settings:before,.bdsft-webrtc .icon-settings:hover:before{content:\"\\e601\"}.bdsft-webrtc .icon-resume:before,.bdsft-webrtc .icon-resume:hover:before,.bdsft-webrtc .icon-hold:before,.bdsft-webrtc .icon-hold:hover:before{content:\"\\e6bb\"}.bdsft-webrtc .icon-unmuteAudio:before,.bdsft-webrtc .icon-unmuteAudio:hover:before{content:\"\\e6c1\"}.bdsft-webrtc .icon-muteAudio:before,.bdsft-webrtc .icon-muteAudio:hover:before{content:\"\\e6c3\"}.bdsft-webrtc .icon-arrow-up-thick:before{content:\"\\f5a4\"}.bdsft-webrtc .icon-arrow-down-thick:before{content:\"\\f5a5\"}.bdsft-webrtc .icon-cancel3:before{content:\"\\f2c9\"}.bdsft-webrtc .icon-fullscreenContract:before,.bdsft-webrtc .icon-fullscreenContract:hover:before,.bdsft-webrtc .icon-fullscreenExpand:before,.bdsft-webrtc .icon-fullscreenExpand:hover:before{content:\"\\f371\"}.bdsft-webrtc .icon-th:before{content:\"\\e602\"}.bdsft-webrtc .icon-selfViewShow:before,.bdsft-webrtc .icon-selfViewShow:hover:before,.bdsft-webrtc .icon-selfViewHide:before,.bdsft-webrtc .icon-selfViewHide:hover:before{content:\"\\f17f\"}.bdsft-webrtc .icon-transfer:before,.bdsft-webrtc .icon-transfer:hover:before{content:\"\\f186\"}.bdsft-webrtc .icon-angle-right:before{content:\"\\f1fe\"}.bdsft-webrtc a.icon-call:before{content:\"\\e00e\";color:#3b9e3b}.bdsft-webrtc .icon-highlightable:hover{color:<%= iconHighlightColor %>}.bdsft-webrtc .icon a:hover:before,.bdsft-webrtc .icon a:hover,.bdsft-webrtc .icon span:hover,.bdsft-webrtc .videoBar a:hover:before,.bdsft-webrtc .videoBar a:hover{color:<%= iconHighlightColor %>}.bdsft-webrtc .table{display:table;width:100%}.bdsft-webrtc .fixed{table-layout:fixed}.bdsft-webrtc .collapse{border-collapse:collapse}.bdsft-webrtc .cell{display:table-cell}.bdsft-webrtc .heading{display:table-row;font-weight:bold}.bdsft-webrtc .row{display:table-row;margin:0}.bdsft-webrtc .group{display:table-row-group}.bdsft-webrtc .hidden{display:none!important}.bdsft-webrtc .opaque{opacity:0!important}.bdsft-webrtc .popup{background:#292929;padding:10px;border:2px solid #ddd;float:left;position:absolute;top:0;bottom:0;left:0;right:0;margin:auto;box-shadow:0 0 10px #999;border-radius:3px;font-size:14px;line-height:18px;z-index:100}.bdsft-webrtc .popup .actions{text-align:right}.bdsft-webrtc .popup .title{font-weight:bold;font-size:18px;color:#fff}.bdsft-webrtc .centered{top:50%;left:50%;bottom:auto;right:auto;transform:translate(-50%,-50%);backface-visibility:hidden}.bdsft-webrtc .topright{right:auto;left:100%;top:0;bottom:auto}.bdsft-webrtc .bottomleft{right:auto;left:0;bottom:auto;top:100%}.bdsft-webrtc .audioOnly .centered,.bdsft-webrtc .audioOnly.centered{top:0;transform:translate(-50%,40px)}.bdsft-webrtc .fadeable{opacity:0;display:block;z-index:-1;backface-visibility:hidden}.bdsft-webrtc .fadeIn{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:20}.bdsft-webrtc .fadeOut{transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}@keyframes flickerAnimation{0%{opacity:0;height:0}5%{opacity:.5;height:auto}20%{opacity:1;height:auto}80%{opacity:1;height:auto}85%{opacity:.5;height:auto}100%{opacity:0;height:0}}@-o-keyframes flickerAnimation{0%{opacity:0;height:0}5%{opacity:.5;height:auto}20%{opacity:1;height:auto}80%{opacity:1;height:auto}85%{opacity:.5;height:auto}100%{opacity:0;height:0}}@-moz-keyframes flickerAnimation{0%{opacity:0;height:0}5%{opacity:.5;height:auto}20%{opacity:1;height:auto}80%{opacity:1;height:auto}85%{opacity:.5;height:auto}100%{opacity:0;height:0}}@-webkit-keyframes flickerAnimation{0%{opacity:0;height:0}5%{opacity:.5;height:auto}20%{opacity:1;height:auto}80%{opacity:1;height:auto}85%{opacity:.5;height:auto}100%{opacity:0;height:0}}@keyframes fadeInAnimation{0%{opacity:0;height:0}5%{opacity:.1;height:auto}20%{opacity:.2;height:auto}80%{opacity:.8;height:auto}100%{opacity:1;height:auto}}@-o-keyframes fadeInAnimation{0%{opacity:0;height:0}5%{opacity:.1;height:auto}20%{opacity:.2;height:auto}80%{opacity:.8;height:auto}100%{opacity:1;height:auto}}@-moz-keyframes fadeInAnimation{0%{opacity:0;height:0}5%{opacity:.1;height:auto}20%{opacity:.2;height:auto}80%{opacity:.8;height:auto}100%{opacity:1;height:auto}}@-webkit-keyframes fadeInAnimation{0%{opacity:0;height:0}5%{opacity:.1;height:auto}20%{opacity:.2;height:auto}80%{opacity:.8;height:auto}100%{opacity:1;height:auto}}"}
},{}],22:[function(require,module,exports){
/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */

/* More information about these options at jshint.com/docs/options */
/* global mozRTCIceCandidate, mozRTCPeerConnection,
mozRTCSessionDescription, webkitRTCPeerConnection */
/* exported trace,requestUserMedia */

'use strict';

var RTCPeerConnection = null;
var getUserMedia = null;
var attachMediaStream = null;
var reattachMediaStream = null;
var webrtcDetectedBrowser = null;
var webrtcDetectedVersion = null;

function trace(text) {
  // This function is used for logging.
  if (text[text.length - 1] === '\n') {
    text = text.substring(0, text.length - 1);
  }
  if (window.performance) {
    var now = (window.performance.now() / 1000).toFixed(3);
    console.log(now + ': ' + text);
  } else {
    console.log(text);
  }
}

if (typeof navigator !== 'undefined' && navigator.mozGetUserMedia) {
  console.log('This appears to be Firefox');

  webrtcDetectedBrowser = 'firefox';

  webrtcDetectedVersion =
    parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);

  // The RTCPeerConnection object.
  RTCPeerConnection = function(pcConfig, pcConstraints) {
    // .urls is not supported in FF yet.
    if (pcConfig && pcConfig.iceServers) {
      for (var i = 0; i < pcConfig.iceServers.length; i++) {
        if (pcConfig.iceServers[i].hasOwnProperty('urls')) {
          pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;
          delete pcConfig.iceServers[i].urls;
        }
      }
    }
    return new mozRTCPeerConnection(pcConfig, pcConstraints);
  };

  // The RTCSessionDescription object.
  window.RTCSessionDescription = mozRTCSessionDescription;

  // The RTCIceCandidate object.
  window.RTCIceCandidate = mozRTCIceCandidate;

  // getUserMedia shim (only difference is the prefix).
  // Code from Adam Barth.
  getUserMedia = navigator.mozGetUserMedia.bind(navigator);
  navigator.getUserMedia = getUserMedia;

  // Shim for MediaStreamTrack.getSources.
  MediaStreamTrack.getSources = function(successCb) {
    setTimeout(function() {
      var infos = [
        {kind: 'audio', id: 'default', label:'', facing:''},
        {kind: 'video', id: 'default', label:'', facing:''}
      ];
      successCb(infos);
    }, 0);
  };

  // Creates ICE server from the URL for FF.
  window.createIceServer = function(url, username, password) {
    var iceServer = null;
    var urlParts = url.split(':');
    if (urlParts[0].indexOf('stun') === 0) {
      // Create ICE server with STUN URL.
      iceServer = {
        'url': url
      };
    } else if (urlParts[0].indexOf('turn') === 0) {
      if (webrtcDetectedVersion < 27) {
        // Create iceServer with turn url.
        // Ignore the transport parameter from TURN url for FF version <=27.
        var turnUrlParts = url.split('?');
        // Return null for createIceServer if transport=tcp.
        if (turnUrlParts.length === 1 ||
          turnUrlParts[1].indexOf('transport=udp') === 0) {
          iceServer = {
            'url': turnUrlParts[0],
            'credential': password,
            'username': username
          };
        }
      } else {
        // FF 27 and above supports transport parameters in TURN url,
        // So passing in the full url to create iceServer.
        iceServer = {
          'url': url,
          'credential': password,
          'username': username
        };
      }
    }
    return iceServer;
  };

  window.createIceServers = function(urls, username, password) {
    var iceServers = [];
    // Use .url for FireFox.
    for (var i = 0; i < urls.length; i++) {
      var iceServer =
        window.createIceServer(urls[i], username, password);
      if (iceServer !== null) {
        iceServers.push(iceServer);
      }
    }
    return iceServers;
  };

  // Attach a media stream to an element.
  attachMediaStream = function(element, stream) {
    console.log('Attaching media stream');
    element.mozSrcObject = stream;
  };

  reattachMediaStream = function(to, from) {
    console.log('Reattaching media stream');
    to.mozSrcObject = from.mozSrcObject;
  };

} else if (typeof navigator !== 'undefined' && navigator.webkitGetUserMedia) {
  console.log('This appears to be Chrome');

  webrtcDetectedBrowser = 'chrome';
  // Temporary fix until crbug/374263 is fixed.
  // Setting Chrome version to 999, if version is unavailable.
  var result = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
  if (result !== null) {
    webrtcDetectedVersion = parseInt(result[2], 10);
  } else {
    webrtcDetectedVersion = 999;
  }

  // Creates iceServer from the url for Chrome M33 and earlier.
  window.createIceServer = function(url, username, password) {
    var iceServer = null;
    var urlParts = url.split(':');
    if (urlParts[0].indexOf('stun') === 0) {
      // Create iceServer with stun url.
      iceServer = {
        'url': url
      };
    } else if (urlParts[0].indexOf('turn') === 0) {
      // Chrome M28 & above uses below TURN format.
      iceServer = {
        'url': url,
        'credential': password,
        'username': username
      };
    }
    return iceServer;
  };

  // Creates an ICEServer object from multiple URLs.
  window.createIceServers = function(urls, username, password) {
    return {
      'urls': urls,
      'credential': password,
      'username': username
    };
  };

  // The RTCPeerConnection object.
  RTCPeerConnection = function(pcConfig, pcConstraints) {
    return new webkitRTCPeerConnection(pcConfig, pcConstraints);
  };

  // Get UserMedia (only difference is the prefix).
  // Code from Adam Barth.
  getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
  navigator.getUserMedia = getUserMedia;

  // Attach a media stream to an element.
  attachMediaStream = function(element, stream) {
    if (typeof element.srcObject !== 'undefined') {
      element.srcObject = stream;
    } else if (typeof element.mozSrcObject !== 'undefined') {
      element.mozSrcObject = stream;
    } else if (typeof element.src !== 'undefined') {
      element.src = URL.createObjectURL(stream);
    } else {
      console.log('Error attaching stream to element.');
    }
  };

  reattachMediaStream = function(to, from) {
    to.src = from.src;
  };
} else {
  console.log('Browser does not appear to be WebRTC-capable');
}

// Returns the result of getUserMedia as a Promise.
function requestUserMedia(constraints) {
  return new Promise(function(resolve, reject) {
    var onSuccess = function(stream) {
      resolve(stream);
    };
    var onError = function(error) {
      reject(error);
    };

    try {
      getUserMedia(constraints, onSuccess, onError);
    } catch (e) {
      reject(e);
    }
  });
}

if (typeof module !== 'undefined') {
  module.exports = {
    RTCPeerConnection: RTCPeerConnection,
    getUserMedia: getUserMedia,
    attachMediaStream: attachMediaStream,
    reattachMediaStream: reattachMediaStream,
    webrtcDetectedBrowser: webrtcDetectedBrowser,
    webrtcDetectedVersion: webrtcDetectedVersion,
    requestUserMedia: requestUserMedia,
    trace: trace
  };
}

},{}],23:[function(require,module,exports){
var adapter = require('./adapter');
var constants = require('./constants');
var cookieprop = require('./cookieprop');
var visibleprop = require('./visibleprop');
var dateformat = require('./dateformat');
var icon = require('./icon');
var prop = require('./prop');
var utils = require('./utils');
var eventbus = require('./eventbus');
var debug = require('./debug');
var bdsft = require('./bdsft');
var element = require('./element');
var factory = require('./factory');
var popup = require('./popup');
var loader = require('./loader');
var urlconfig = require('./urlconfig');
var cookieconfig = require('./cookieconfig');


module.exports = {adapter: adapter, constants: constants, cookieprop: cookieprop, visibleprop: visibleprop, dateformat:  dateformat,
icon: icon, prop: prop, utils: utils, eventbus: eventbus, debug: debug, bdsft: bdsft, element: element, factory: factory, popup: popup, 
loader: loader, urlconfig: urlconfig, cookieconfig: cookieconfig};
},{"./adapter":22,"./bdsft":24,"./constants":27,"./cookieconfig":28,"./cookieprop":29,"./dateformat":32,"./debug":33,"./element":34,"./eventbus":35,"./factory":36,"./icon":37,"./loader":38,"./popup":39,"./prop":40,"./urlconfig":42,"./utils":43,"./visibleprop":44}],24:[function(require,module,exports){
var utils = require('./utils')
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
var DataBinder = require('./databinder');
var Utils = require('./utils');
var StylesManager = require('./stylesmanager');

var databinder = function(name, constructorArgs, source) {
	var databinder;
	if (name === source._name || name === 'self') {
		if (!source.databinder) {
			throw Error('databinder : undefined on ' + source._name);
		}
		return source.databinder;
	}

	for (var i = 0; i < constructorArgs.length; i++) {
		if (constructorArgs[i]._name && (constructorArgs[i]._name === name || constructorArgs[i]._name.replace(/view$/, '') === name)) {
			if (!constructorArgs[i].databinder) {
				throw Error('databinder : undefined on ' + name);
			}
			return constructorArgs[i].databinder;
		}
	}

	// View without model
	if (name === source._name.replace(/view$/, '')) {
		return new DataBinder(name);
	}

	throw Error('databinder : ' + name + ' constructor argument missing in ' + source._name);
};
var bdsft = {
	View: View,
	Model: Model,
	databinder: databinder
};

module.exports = bdsft;

function View(constructor, options) {
	var self = {};

	self.options = options;
	self.argNames = argNamesFun(constructor);
	self.name = functionName(constructor);
	self.viewName = self.name.replace('view', '');
	self.constructor = constructor;

	self.create = function(constructorArgs, createOptions) {
		constructorArgs = constructorArgs || [];
		createOptions = createOptions || {};
		options = options || {};
		var object = createFun(constructor, constructorArgs);

		object.appendTo = function(view) {
			object.view.appendTo(view);
		};
		object.updateContentView = function(contentView, items, createItemViewCallback) {
			object._contentViews = object._contentViews || {};
			for (var name in items) {
				var item = items[name];
	      		var view = object._contentViews[name];
	      		if(!view) {
					var view = createItemViewCallback(item);
					object._contentViews[name] = view;
					view.view.appendTo(contentView);
	      		}
			}
			for(var name in object._contentViews) {
				if(!items[name]) {
					object._contentViews[name].view.remove();
					delete object._contentViews[name];
				}
			}
		};

		object._name = self.name;
		object.databinder = databinder(self.viewName, constructorArgs, object);
		var view = createOptions.template && createOptions.template[self.viewName] && createOptions.template[self.viewName]() || options.template && options.template[self.viewName] && options.template[self.viewName]() || object.template || require(self.viewName + '-bdsft-webrtc-templates')[self.viewName] && require(self.viewName + '-bdsft-webrtc-templates')[self.viewName]();
		if (!view) {
			console.error('no view template found : ' + self.viewName);
			return;
		}
		object.view = require('jquery')(view);
		(object.elements || []).forEach(function(element) {
			require('./app').element(object, element, object.databinder);
		});
		bindings(object, constructorArgs);
		call(object, 'listeners', options, constructorArgs);
		call(object, 'init', options, constructorArgs);

		StylesManager.inject(self.viewName, createOptions, options);

		var classesHolder = object.view.find('.classes:first');
		if (classesHolder.length === 0) {
			classesHolder = object.view;
		}
		var classes = classesHolder.attr('class');
		object.databinder.onModelPropChange('classes', function(value) {
			classesHolder.attr('class', classes + ' ' + value.join(' '));
		});

		return object;
	};

	return self;
}

function Model(constructor, options) {
	var self = {};

	self.create = function(constructorArgs, createOptions) {
		constructorArgs = constructorArgs || [];
		createOptions = createOptions || {};
		options = options || {};
		var object = createFun(constructor, constructorArgs);
		object._name = self.name;
		object.databinder = new DataBinder(self.name);
		var medias = utils.extend({},
			options.media,
			options.media && options.media['media'],
			options.media && options.media[self.name],
			createOptions.media && createOptions.media[self.name]
		);
		if (Object.keys(medias).length) {
			object.medias = medias;
		}
		var createConfig = createOptions.config && createOptions.config[self.name] || createOptions[self.name];
		var config = options.config && options.config[self.name] || options.config;
		if (config || createConfig) {
			var config = utils.extend({}, config, createConfig);
			for (var name in config) {
				require('./app')['prop'](object, {
					name: name,
					value: config[name]
				}, object.databinder);
			}
			if (!object.updateConfig) {
				object.updateConfig = function(config) {
					config = config || {};
					for (var name in config) {
						if (typeof object[name] !== 'undefined') {
							object[name] = config[name];
						}
					}
				};
			}
			if (!object.configChanges) {
				object.configChanges = function() {
					var changes = {};
					for (var name in config) {
						if (object[name] !== config[name]) {
							changes[name] = object[name];
						}
					}
					return changes;
				};
			}
		}
		(Array.isArray(object.props) && object.props || object.props && Object.keys(object.props) || []).forEach(function(name) {
			var value = object.props[name];
			var prop = utils.extend({
				name: name
			}, typeof value !== 'object' && {
				value: value
			} || value)
			var type = prop.type || object._propstype || object.props._type || '';
			if (type === 'default') {
				type = '';
			}
			if (name === 'visible') {
				type = 'visible';
			}
			require('./app')[type + 'prop'](object, prop, object.databinder);
		});
		bindings(object, constructorArgs);
		call(object, 'listeners', options, constructorArgs);
		call(object, 'init', options, constructorArgs);
		return object;
	};

	self.argNames = argNamesFun(constructor);
	self.name = functionName(constructor);
	self.options = options;
	self.constructor = constructor;

	return self;
};

function bindings(object, constructorArgs) {
	(object.bindings && Object.keys(object.bindings) || []).forEach(function(name) {
		var from = object.bindings[name];
		var binding;
		if (name === 'classes') {
			binding = require('./classesbinding')(object, name, from, constructorArgs);
		} else {
			binding = require('./binding')(object, name, from, constructorArgs);
		}
		binding.init();
	});
}

function functionName(fun) {
	var ret = fun.toString();
	ret = ret.substr('function '.length);
	ret = ret.substr(0, ret.indexOf('('));
	return ret.toLowerCase();
}

function argNamesFun(fun) {
	var fnStr = fun.toString().replace(STRIP_COMMENTS, '')
	var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES)
	if (result === null) {
		result = [];
	}
	return result;
}

function call(object, method, options, constructorArgs) {
	if (!object[method]) {
		return;
	}
	var argNames = argNamesFun(object[method]);
	var args = [];
	for (var i = 0; i < argNames.length; i++) {
		if (argNames[i].match(/databinder/i)) {
			var databinderArg = databinder(argNames[i].replace(/databinder/i, '') || object._name, constructorArgs, object);
			args.push(databinderArg);
		} else if (argNames[i] === 'options') {
			args.push(options);
		} else {
			// console.warn('no arg on '+ name +' found for : '+argNames[i]);
		}
	}
	return createFun(object[method], args);
}

function createFun(constructor, argArray) {
	var args = [null].concat(argArray);
	var factoryFunction = constructor.bind.apply(constructor, args);
	return new factoryFunction();
}
},{"./app":23,"./binding":25,"./classesbinding":26,"./databinder":31,"./stylesmanager":41,"./utils":43,"jquery":68}],25:[function(require,module,exports){
module.exports = Binding;
var bdsft = require('./bdsft');
var utils = require('./utils');

function Binding(object, toProp, from, constructorArgs) {
	var self = {};

	self.fromObject = function(fromModel) {
		var fromModelObj;
		if (object._name === fromModel || fromModel === 'self') {
			fromModelObj = object;
		} else {
			fromModelObj = constructorArgs.filter(function(arg) {
				return arg._name === fromModel;
			}).pop();
		}

		return fromModelObj;
	};

	self.init = function init() {
		var fromKeys = Object.keys(from);

		fromKeys.forEach(function(fromModel) {
			var databinder = bdsft.databinder(fromModel, constructorArgs, object);
			var fromProp = from[fromModel];
			var fromObj = self.fromObject(fromModel);
			if(fromObj) {
				if (Array.isArray(fromProp)) {
					fromProp.forEach(function(p) {
						if (!fromObj.hasOwnProperty(p)) {
							throw Error('binding error : '+p + ' does not exist in ' + fromModel);
						}
					})
				} else if (!fromObj.hasOwnProperty(fromProp)) {
					throw Error('binding error : '+fromProp + ' does not exist in ' + fromModel);
				}
			}

			var onChange = function(value, name) {
				var updateHandle = utils.camelize('update ' + toProp);
				if (typeof object[updateHandle] === 'function') {
					object[updateHandle](value, name);
				} else if (object.hasOwnProperty(updateHandle)) {
					object[updateHandle] = value;
				} else {
					var targetObj = self.fromObject(toProp);
					if(targetObj) {
						targetObj[name] = value;
						return;
					}
					
					if(!object.hasOwnProperty(toProp)) {
						throw Error('binding error : prop '+toProp + ' does not exist in ' + (object._name || object));
					}
					object[toProp] = value;
				}
			};
			databinder.onViewElChange(fromProp, onChange);
			databinder.onModelPropChange(fromProp, onChange);
		});
	};

	return self;
}
},{"./bdsft":24,"./utils":43}],26:[function(require,module,exports){
module.exports = ClassesBinding;

function ClassesBinding(object, toProp, from, constructorArgs) {
	var self = require('./binding')(object, toProp, from, constructorArgs);

	var value = function(fromObj, fromProp) {
		var val = fromObj[fromProp];
		if(typeof val === 'function') {
			val = val();
		}

		if (Array.isArray(val)) {
			return val;
		} else if (typeof val === 'string') {
			return val;
		} else if (typeof val === 'boolean' && fromProp.match(/visible/i)) {
			var prefix = fromProp.replace(/visible/i, '') || fromObj._name;
			return val ? prefix + '-shown' : prefix + '-hidden';
		} else {
			if (val) {
				return fromProp;
			}
		}
		return;
	};

	object.updateClasses = function() {
		var classes = [];
		Object.keys(from).forEach(function(fromModel) {
			var fromProp = from[fromModel];
			var fromObj = self.fromObject(fromModel);
			if(!fromObj) {
				throw Error('classes binding error : '+fromModel + ' does not exist in constructor of ' + object._name);
			}

			(Array.isArray(fromProp) && fromProp || [fromProp]).forEach(function(prop) {
				var val = value(fromObj, prop);
				if(!val) {
					return;
				} else if (Array.isArray(val)) {
					classes = classes.concat(val);
				} else {
					classes.push(val)
				}
			});
		});
		// prepend classes that start with a number with _
		classes = classes.map(function(clazz){
			return clazz.match(/^\d/) && '_' + clazz || clazz
		});
		// replace empty space with - and lower case 
		classes = classes.map(function(clazz){
			return clazz.trim().replace(/\s/, '-');
		});
		object[toProp] = classes;
	};

	return self;
}
},{"./binding":25}],27:[function(require,module,exports){
var C = {
    // RTCSession states
  STATE_CONNECTED: "connected",
  STATE_DISCONNECTED: "disconnected",
  STATE_CALLING: "calling",
  STATE_STARTED: "started",
  STATE_HELD: "held",
  
  WIDESCREEN: 'widescreen',
  STANDARD: 'standard',
  R_1920x1080: '1920x1080',
  R_1280x720: '1280x720',
  R_640x360: '640x360',
  R_320x180: '320x180',
  R_960x720: '960x720',
  R_640x480: '640x480',
  R_320x240: '320x240',
  EXPIRES: 365,

  STYLES: {
    iconHighlightColor: '#00adef'
  }

};

module.exports = C;
},{}],28:[function(require,module,exports){
module.exports = require('./bdsft').Model(CookieConfig);

var jQuery = $ = require('jquery');
require('jquery.cookie');

function CookieConfig() {
	var self = {};
	var prefix = 'bdsft_';

	self.get = function(name) {
		return $.cookie(prefix + name);
	};
	self.set = function(name, value) {
		return $.cookie(prefix + name, value);
	};

	self._propstype = 'cookie';

	self.props = ['authenticationUserid', 'userid', 'password', 'encodingResolution', 'displayResolution', 'hd', 'displayName', 'enableSelfView', 
		'bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'enableAutoAnswer'];

	return self;
}
},{"./bdsft":24,"jquery":68,"jquery.cookie":67}],29:[function(require,module,exports){
module.exports = CookieProp;

var Prop = require('./prop');
var C = require('./constants');
var Utils = require('./utils');
var $ = require('jquery');
require('jquery.cookie')

function CookieProp(obj, prop, databinder) {

	var self = {};

	var cookie = 'bdsft_'+ obj._name + '_' + prop.name;
	var expires = C.EXPIRES;

	var _onInit = prop.onInit;
	prop.onInit = function(){
		if(!prop.value && $.cookie(cookie)) {
			var value = $.cookie(cookie);
			if(value === 'true') {
 				obj[prop.name] = true;
			} else if(value === 'false') {
 				obj[prop.name] = false;
			} else {
 				obj[prop.name] = value;
			}
		}
		_onInit && _onInit();
		// console.log('cookie oninit : '+prop.name, obj[prop.name]);
	};

	var _onSet = prop.onSet;
	prop.onSet = function(value){
		if (value) {
			$.cookie(cookie, value, {
				expires: expires
			});
		} else {
			$.removeCookie(cookie);
		}
		_onSet && _onSet(value);
	};

	var propObj = Prop(obj, prop, databinder);

	return propObj;
}
},{"./constants":27,"./prop":40,"./utils":43,"jquery":68,"jquery.cookie":67}],30:[function(require,module,exports){
module.exports = CSS;

var ejs = require('ejs');
var utils = require('./utils');
var constants = require('./constants');

function CSS(name) {
	var self = {};

	var id = 'bdsft_css_'+name;

	var cssData = function(styleData, options){
		return utils.extend({}, options.constants && options.constants.STYLES || constants.STYLES, styleData);
	};

	var cssStr = function(styleData, options){
		var styles = options.style;
		if(!styles) {
			return;
		}
		return ejs.render(styles, cssData(styleData, options));
	};

	self.inject = function(styleData, options) {
		var css = cssStr(styleData, options);
		if(!css) {
			return;
		}
		var cssEl = utils.getElement('#'+id);
		if (!cssEl || cssEl.length === 0) {
			self.data = cssData(styleData, options);
			utils.createElement('<style>', {
				id: id,
				type: 'text/css',
				text: css
			}, {
				parent: 'head'
			});
		}
	};

	self.update = function(styleData, options) {
		var css = cssStr(styleData, options);
		if(!css) {
			return;
		}
		var cssEl = utils.getElement('#'+id);
		if (cssEl && cssEl.length > 0) {
			self.data = cssData(styleData, options);
			cssEl.text(css)
		}
	};

	return self;
}
},{"./constants":27,"./utils":43,"ejs":49}],31:[function(require,module,exports){
module.exports = DataBinder;

var ee = require('event-emitter');

function DataBinder( objectid ) {
  var emitter = ee({});

  var lastValues = {};
  var self = {};

  self.onModelChange = function(cb){
    emitter.on(objectid, function(data){
      if(!data.fromView) {
        cb(data.name, data.value, data.sender);
      }
    });
  };
  self.onModelPropChangeListener = function(name, cb){
    self.onModelChange(function(_name, value, sender){
      if(Array.isArray(name) && name.indexOf(_name) !== -1 || _name === name) {
        cb(value, _name, sender);
      }
    });
  };
  self.onModelPropChange = function(name, cb){
    self.onModelPropChangeListener(name, cb);
    (Array.isArray(name) && name || [name]).forEach(function(n){
      lastValues[n] !== undefined && cb(lastValues[n], n);
    });
  };
  self.onViewChange = function(cb){
    emitter.on(objectid, function(data){
      if(data.fromView) {
        cb(data.name, data.value, data.sender);
      }
    });
  };
  self.onViewElChangeListener = function(name, cb){
    self.onViewChange(function(_name, value, sender){
        if(Array.isArray(name) && name.indexOf(_name) !== -1 || _name === name) {
          cb(value, _name, sender);
        }
    });
  };
  self.onViewElChange = function(name, cb){
    self.onViewElChangeListener(name, cb);
    (Array.isArray(name) && name || [name]).forEach(function(n){
      lastValues[n] !== undefined && cb(lastValues[n], n);
    });
  };

  var emit  = function(name, value, fromView, sender, force){
    // break if both are NaNs as it does not match on equality
    if(value+'' === 'NaN' && lastValues[name]+'' === 'NaN') {
      return;
    }

    if(force || lastValues[name] !== value) {
      lastValues[name] = value;
      emitter.emit(objectid, {name: name, value: value, fromView: fromView, sender: sender});
    }
  };

  self.viewChanged = function(name, value, sender, force){
    emit(name, value, true, sender, force);
  };
  self.modelChanged = function(name, value, sender, force){
    emit(name, value, false, sender, force);
  };

  return self;
}

},{"event-emitter":52}],32:[function(require,module,exports){
module.exports = DateFormat;
var C = {
  dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  mthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
};
C.zeroPad = function(number) {
  return ("0" + number).substr(-2, 2);
};
C.dateMarkers = {
  d: ['getDate', function(v) {
    return C.zeroPad(v);
  }],
  m: ['getMonth', function(v) {
    return C.zeroPad(v + 1);
  }],
  n: ['getMonth', function(v) {
    return C.mthNames[v];
  }],
  w: ['getDay', function(v) {
    return C.dayNames[v];
  }],
  y: ['getFullYear', function(v) {
    return v;
  }],
  H: ['getHours', function(v) {
    return C.zeroPad(v);
  }],
  M: ['getMinutes', function(v) {
    return C.zeroPad(v);
  }],
  S: ['getSeconds', function(v) {
    return C.zeroPad(v);
  }],
  i: ['toISOString']
};

DateFormat.C = C;

function DateFormat(fstr) {
  this.formatString = fstr;
}

DateFormat.prototype = {
  format: function(date) {
    var dateTxt = this.formatString.replace(/%(.)/g, function(m, p) {
      var dateMarker = C.dateMarkers[p];
      var method = dateMarker[0];
      var rv = date[method]();

      if (dateMarker[1] !== null) {
        rv = dateMarker[1](rv);
      }

      return rv;

    });

    return dateTxt;
  }
};
},{}],33:[function(require,module,exports){
module.exports = require('./bdsft').Model(Debug, {
	config: require('../js/config')
})

var stacktrace = require('stacktrace-js');
var utils = require('./utils');
var debug = require('debug');
var enabled = {};
var levels = {
	debug: 0,
	log: 1,
	info: 2,
	warn: 3,
	error: 4
};
function Debug(options) {
	var self = {};
	options = options || {};
	var id = options && options.id || options || '';

	var prefix = (options.name || caller()) + ':' + id;
	var debugObj;

	self.init = function(){
		var logPrefix = self.names;
		if(logPrefix+'' === 'true') {
			logPrefix = '*'
		}

		if (logPrefix) {
			enabled[id] = utils.withArray(logPrefix).map(function(a){
				return a + ':' + id;
			});
		} else {
			delete enabled[id];
		}
		updateEnabled();

		debugObj = debug(prefix);
	};

	var printMsg = function(level, msg) {
		if(self.level && levels[level] >= levels[self.level]) {
			debugObj.log = console[level].bind(console);
			self.print(msg);
		}
	}
	self.print = function(msg) {
		debugObj(msg);
	};
	self.log = function(msg){
		printMsg('log', msg);
	};
	self.warn = function(msg){
		printMsg('warn', msg);
	};
	self.error = function(msg){
		printMsg('error', msg);
	};
	self.debug = function(msg){
		printMsg('debug', msg);
	};
	self.info = function(msg){
		printMsg('info', msg);
	};

	return self;
}

var caller = function(){
	var list = stacktrace();
	for(var i=list.length-1; i >= 0; i--) {
		var match = null;
		if((match = list[i].match(/([A-Z]\S*).*@/g))) {
			if(match !== 'Object') {
				return match;				
			}
		}
	}

	return stacktrace().pop().match('(.*)@').pop();
}
var updateEnabled = function() {
	var values = [];
	Object.keys(enabled).forEach(function(key) {
		if(Array.isArray(enabled[key])) {
			values = values.concat(enabled[key]);
		} else {
			values.push(enabled[key]);
		}
	});
	debug.enable(values.join(','));
};
// exports.enable = function(id){
// 	enabledList.push('*'+id);
// 	var enabledStr = enabledList.join(',');
// 	debug.enable(enabledStr);
// };
// exports.disable = function(){
// 	enabledList = [];
// 	debug.disable();
// };
// exports.log = debug.log;
},{"../js/config":20,"./bdsft":24,"./utils":43,"debug":45,"stacktrace-js":70}],34:[function(require,module,exports){
module.exports = Element;

function Element(object, name, databinder) {
	var self = {};

	var element = object.view.find('.' + name);
	if(!element || !element.length) {
		console.warn('no element found for ' + name + ' in template '+object._name);
		return;
	}

	object[name] = element;

	element.on('change', function(){
		databinder.viewChanged(name, get(), self);
	});

	var isCheckbox = function() {
		return element.attr('type') === 'checkbox';
	};

	var isTextbox = function() {
		return (element.attr('type') === 'text' || element.attr('type') === 'password' || element.is('textarea'));
	};

	var isSelect = function() {
		return element && element[0] && element[0].nodeName.match(/select/i);
	};

	var get = function(){
		if(isCheckbox()){
			return element.prop('checked')
		} else if(isTextbox() || isSelect()) {
			return element.val();
		} else {
			return element.text();
			// console.error('element is no input : ', element);
		}
	};

	var set = function(value){
		if(isCheckbox()){
			element.prop('checked', value);
		} else if(isTextbox() || isSelect()) {
			element.val(typeof value !== 'undefined' ? value : '');
		} else {
			element.text(typeof value !== 'undefined' ? value : '');
			// console.error('element is no input : ', element);
		}
	};

	databinder.onModelPropChange(name, function(value){
		set(value);
		// databinder.viewChanged(name, value);
	});

	// add view listener to handle mutliple views sync
	databinder.onViewElChange(name, function(value, name, sender){
		if(sender !== self) {
			set(value);
		}
	});

	return self;
}
},{}],35:[function(require,module,exports){
module.exports = require('./bdsft').Model(EventBus);

var ee = require('event-emitter');

function EventBus() {
	var self = {};

	var lastEvents = {};

	var emitter = ee({});

	self.on = function(type, listener) {
		if (Array.isArray(type)) {
			type.forEach(function(t) {
				emitter.on(t, listener);
			});
		} else {
			emitter.on(type, listener);
		}
	};
	self.once = function(type, listener) {
		if (Array.isArray(type)) {
			type.forEach(function(t) {
				emitter.once(t, listener);
			});
		} else {
			emitter.once(type, listener);
		}
	};
	var doEmit = function(type, obj) {
		lastEvents[type] = obj;
		emitter.emit(type, obj);
	};
	self.emit = function(type, obj) {
		if (Array.isArray(type)) {
			type.forEach(function(t) {
				doEmit(t, obj);
			});
		} else {
			doEmit(type, obj);
		}
	};
	self.endCall = function() {
		self.emit('endCall', {});
	};
	self.userMediaUpdated = function(localStream) {
		self.emit('userMediaUpdated', {localStream: localStream});
	};
	self.incomingCall = function(data) {
		self.emit('incomingCall', data);
	};
	self.progress = function(data) {
		self.emit('progress', data);
	};
	self.started = function(data) {
		self.emit('started', data);
	};
	self.failed = function(data) {
		self.emit('failed', data);
	};
	self.ended = function(data) {
		self.emit('ended', data);
	};
	self.held = function(data) {
		self.emit('held', data);
	};
	self.resumed = function(data) {
		self.emit('resumed', data);
	};
	self.dataSent = function(data) {
		self.emit('dataSent', data);
	};
	self.dataReceived = function(data) {
		self.emit('dataReceived', data);
	};
	self.newDTMF = function(data) {
		self.emit('newDTMF', data);
	};
	self.digit = function(digit, isFromDestination) {
		self.emit('digit', {
			digit: digit,
			isFromDestination: isFromDestination
		});
	};
	self.iceconnected = function(sender, data) {
		self.emit("iceconnected", {
			sender: sender,
			data: data
		});
	};
	self.icecompleted = function(sender, data) {
		self.emit("icecompleted", {
			sender: sender,
			data: data
		});
	};
	self.iceclosed = function(sender, data) {
		self.emit("iceclosed", {
			sender: sender,
			data: data
		});
	};
	self.calling = function(destination, session) {
		self.emit('calling', {
			destination: destination,
			session: session
		});
	};
	self.modifier = function(which) {
		self.emit('modifier', {
			which: which
		});
	};

	return self;
}
},{"./bdsft":24,"event-emitter":52}],36:[function(require,module,exports){
(function (global){
var $ = require('jquery');
var Utils = require('./utils');
module.exports = Factory;

function Factory(options) {
	options.dependencies = options.dependencies || {};

	function getId() {
		var id;
		if (typeof options === "object") {
			id = options.id;
		}
		return id || 'default';
	};

	function requireArg(argName, constructor) {
		var arg = options.dependencies[argName] || options.dependencies.core[argName];
		if(!arg && argName.match(/view/i)) {
			arg = options.dependencies[argName.replace(/view/i, '')];
			if(!arg) {
				throw Error('factory error : could not find dependency for '+argName + ' required by '+constructor.name + ' - dependencies : ', Object.keys(options.dependencies));
			}
			return arg.view;
		}

		if(!arg) {
			var keys = Object.keys(options.dependencies);
			for(var i=0; i < keys.length; i++){
				var dependency = options.dependencies[keys[i]][argName];
				if(dependency) {
					return dependency;
				}
			}
		}

		if(!arg) {
			throw Error('factory error : could not find dependency for '+argName + ' required by '+constructor.name + ' - dependencies : ', Object.keys(options.dependencies));
		}

		return arg.model || arg;
	}

	function args(constructor) {
		return (constructor.argNames || []).map(function(argName) {
			if (argName === 'options') {
				return options;
			}

			var argConstructor = requireArg(argName, constructor);
			if (argName === 'debug') {
				return argConstructor.create([Utils.extend({}, options, {
					name: constructor.name
				})]);
			}
			// console.log('arg : '+argName);
			var arg = create(argConstructor, constructor);
			return arg;
		});
	};

	function create(constructor, parent) {
		var prefix = options.namespace || 'bdsft_webrtc';
		global[prefix] = global[prefix] || {};
		var name = constructor.name;
		var id = getId(name);
		global[prefix][id] = global[prefix][id] || {};

		var createConstructor = function(){
			// console.log('factory : ' + id);
			var constructorArgs = args(constructor);
			// console.log('factory : create ' + id + ' with ', constructor.argNames);
			var constructorOptions = Utils.extend({}, parent && parent.options || {}, options);
			var object = constructor.create(constructorArgs, constructorOptions);
			return object;
		};

		// do not cache views
		if(name.match(/view/i)) {
			var object = createConstructor();
			if(!global[prefix][id][name]) {
				global[prefix][id][name] = object;
			} else {
				if(!Array.isArray(global[prefix][id][name])) {
					global[prefix][id][name] = [global[prefix][id][name]];
				}
				global[prefix][id][name].push(object);
			}
			return object;
		}

		if (!global[prefix][id][name]) {
			global[prefix][id][name] = createConstructor();
		}
		return global[prefix][id][name];
	}

	return create;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":43,"jquery":68}],37:[function(require,module,exports){
  module.exports = Icon;

  function Icon(element, sound) {
    this.element = element;
    this.sound = sound;
    this.disabled = false;
  }

  Icon.prototype = {
    css: function(name) {
      return this.element.css(name);
    },
    attr: function(name) {
      return this.element.attr(name);
    },
    disable: function() {
      this.disabled = true;
    },
    enable: function() {
      this.disabled = false;
    },
    onClick: function(handler) {
      var self = this;
      this.element.bind("click", function(e) {
        e.preventDefault();
        if (self.disabled) {
          return;
        }
        self.sound.playClick();
        handler(e);
      });
    }
  };
},{}],38:[function(require,module,exports){
(function (global){
// var jQuery = jquery = $ = require('jquery');
// require('jquery.cookie')
// var core = require('webrtc-core');
var Constants = require('./constants');
var Utils = require('./utils');
var Factory = require('./factory');
var StylesManager = require('./stylesmanager');

module.exports = Loader;

function Loader(Widget, options) {
  var self = {};

  self.asScript = function(src, config, styles) {
    var script = '<script src="' + src + '" ';
    var dataStrs = Object.keys(styles || {}).map(function(key) {
      var value = styles[key];
      return "data-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '="' + value + '"';
    });
    script += dataStrs.join(' ');
    script += '>\n' + (config && Object.keys(config).length ? JSON.stringify(config, undefined, 2) : '') + '\n</script>';
    return script;
  };

  var currentScript = Utils.getElement('script').last();
  Utils.getElement(document).ready(function() {
    window.BroadSoftWebRTC = window.BroadSoftWebRTC || {};
    window.BroadSoftWebRTC.widgets = [];

    // for mocha tests
    if(!currentScript[0]) {
      return;
    }
    var configData = currentScript.text().trim() ? JSON.parse(currentScript.text()) : {};
    console.log("script config : ", configData);
    var styleData = currentScript.data();
    var src = currentScript[0].src;
    var widget = self.create(configData, styleData, src);
    widget.appendTo(currentScript.parent());
    currentScript.remove();
    window.BroadSoftWebRTC.widgets.push(widget);
  });

  self.create = function create(configData, styleData, src) {
    var count = window.BroadSoftWebRTC && window.BroadSoftWebRTC.widgets && window.BroadSoftWebRTC.widgets.length;
    var id =  (!count || count === 0) && 'default' || 'webrtc'+count;
    var namespace = "bdsft_webrtc";
    var factoryOptions = require('deep-extend')({id: id, namespace: namespace}, options, configData);
    factoryOptions.dependencies.core = require('../');
    factoryOptions.styleData = styleData;
    var widget = Factory(factoryOptions)(Widget.view);

    var modules = function(){
      return (window[factoryOptions.namespace] || global[factoryOptions.namespace])[factoryOptions.id];
    }
    if(!widget.asScript) {
      widget.asScript = function(){
        var configs = {};
        for(var name in modules()) {
          var module = modules()[name];
          var configChanges = module.configChanges && module.configChanges();
          if(configChanges && Object.keys(configChanges).length) {
            var changesObj = {};
            changesObj[name] = configChanges; 
            configs = Utils.extend(configs, changesObj);
          }
        }
        return self.asScript(src, configs, StylesManager.changes());
      };
    }
    if(!widget.updateConfigs) {
      widget.updateConfigs = function(config){
        for(var name in modules()) {
          var module = modules()[name];
          module.updateConfig && module.updateConfig(config && config[name] || config);
        }
      };
    }
    if(!widget.updateStyles) {
      widget.updateStyles = function(styles){
        StylesManager.update(styles);
      };
    }
    return widget;
  }


  // (function($) {
  //   $.isBlank = function(obj) {
  //     return (!obj || $.trim(obj) === "");
  //   };
  // })(jQuery);

  if (typeof String.prototype.endsWith !== 'function') {
    String.prototype.endsWith = function(suffix) {
      return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
  }

  return self;
}

// Object.defineProperties(WebRTC, {
//   version: {
//     get: function() {
//       return '<%= pkg.version %>';
//     }
//   },
//   name: {
//     get: function() {
//       return '<%= pkg.title %>';
//     }
//   }
// });

// if(!jQuery.fn) {
//   jQuery.fn = {};
// }
// jQuery.fn.putCursorAtEnd = function() {

//   return this.each(function() {

//     $(this).focus();

//     // If this function exists...
//     if (this.setSelectionRange) {
//       // ... then use it (Doesn't work in IE)

//       // Double the length because Opera is inconsistent about whether a carriage return is one character or two. Sigh.
//       var len = $(this).val().length * 2;

//       this.setSelectionRange(len, len);

//     } else {
//       // ... otherwise replace the contents with itself
//       // (Doesn't work in Google Chrome)

//       $(this).val($(this).val());

//     }

//     // Scroll to the bottom, in case we're in a tall textarea
//     // (Necessary for Firefox and Google Chrome)
//     this.scrollTop = 999999;

//   });

// };

// if(!jQuery.cssHooks) {
//   jQuery.cssHooks = {};
// }
// jQuery.cssHooks.backgroundColor = {
//   get: function(elem) {
//     var bg = null;
//     if (elem.currentStyle) {
//       bg = elem.currentStyle.backgroundColor;
//     } else if (window.getComputedStyle) {
//       bg = document.defaultView.getComputedStyle(elem,
//         null).getPropertyValue("background-color");
//     }
//     if (bg.search("rgb") === -1 || bg === 'transparent') {
//       return bg;
//     } else {
//       bg = bg.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+).*\)$/);
//       var hex = function(x) {
//         return ("0" + parseInt(x, 10).toString(16)).slice(-2);
//       };
//       return "#" + hex(bg[1]) + hex(bg[2]) + hex(bg[3]);
//     }
//   }
// };
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../":23,"./constants":27,"./factory":36,"./stylesmanager":41,"./utils":43,"deep-extend":48}],39:[function(require,module,exports){
module.exports = PopupView;
var $ = require('jquery');

function PopupView(view, eventbus, opts) {
  opts = opts || {};
  view.attached = false;

  view.visible = false;

  view.show = function() {
    view.setVisible(true);
  };

  view.hide = function() {
    view.setVisible(false);
  };

  view.toggle = function(visible) {
    view.setVisible(typeof visible !== undefined && visible || !view.model.visible || !view.visible);
  };

  view.appendTo = function(parent) {
    view.view.appendTo(parent);
  };

  view.setVisible = function(visible) {
    view.visible = visible;
    view.model.visible = visible;
  };

  if(opts.modifier) {
    eventbus.on('modifier', function(e) {
      if (e.which === opts.modifier) {
        view.toggle();
      }
    });    
  }

  if (!view.attached) {
    view.appendTo(opts.parent && $(opts.parent) || $('body'));
    // document.body.appendChild(view.view[0]);
    view.attached = true;
  }

  return view;
}
},{"jquery":68}],40:[function(require,module,exports){
module.exports = Prop;

var ArrayObserver = require('observe-js').ArrayObserver;
var ObjectObserver = require('observe-js').ObjectObserver;

function Prop(obj, prop, databinder) {
	var self = {};

	var _name = self._name = prop.name || prop;
	var internal;

	var __get = function() {
		return internal;
	};
	var __init = function() {
		if (typeof prop.value !== 'undefined') {
			if (typeof prop.value === 'function') {
				__set(prop.value());
			} else {
				__set(prop.value);
			}
		}
		prop.onInit && prop.onInit();
	};
	var __set = function(value) {
		internal = value;
		if(Array.isArray(internal)) {
			var observer = new ArrayObserver(internal);
			observer.open(function(splices) {
				databinder.modelChanged(_name, internal, self, true);
			});
		}
		else if(typeof internal === 'object') {
			var observer = new ObjectObserver(internal);
			observer.open(function(added, removed, changed, getOldValueFn) {
				databinder.modelChanged(_name, internal, self, true);
			});
		}
		databinder.modelChanged(_name, value, self);
		prop.onSet && prop.onSet(value);
	};

	databinder.onViewElChange(_name, function(value) {
		internal = value;
		prop.onSet && prop.onSet(value);
	});

	Object.defineProperty(obj, _name, {
		writeable: false,
		configurable: true,
		get: prop.get || __get,
		set: prop.set || __set
	});

	__init();

	return self;
}
},{"observe-js":69}],41:[function(require,module,exports){
var utils = require('./utils');
var constants = require('./constants');
var cssCore = require('./css')('core');
var stylesCore = require('../js/styles').core;

function Styl(viewName, createOptions, viewOptions) {
	var self = {};

	var css = require('./css')(viewName);

	var style = function(){
		return createOptions.style && createOptions.style[viewName] 
		|| viewOptions.style && viewOptions.style[viewName]
		|| viewOptions.style && viewOptions.style['styles']
		|| viewOptions.style;
	};

	var data = function(){
		var styleData = utils.extend({}, createOptions.styleData);
		var images = utils.extend({}, 
			viewOptions.image,
			viewOptions.image && viewOptions.image['images'],
			viewOptions.image && viewOptions.image[viewName],
			createOptions.image && createOptions.image[viewName]
		);
		if(Object.keys(images).length) {
			styleData = utils.extend(styleData, images);
		}
		return styleData;
	};

	self.update = function(styles){
		// only update if view contains constants.STYLES and styles keys
		if(viewOptions.constants && viewOptions.constants.STYLES && utils.contains(viewOptions.constants.STYLES, styles)) {
			css.update(utils.extend(data(), styles), {constants: viewOptions.constants, style: style()});
		}
	};

	self.changes = function(){
		var changes = {};
		if(viewOptions.constants && viewOptions.constants.STYLES) {
			for(var name in viewOptions.constants.STYLES) {
				var value = viewOptions.constants.STYLES[name];
				if(css.data && css.data[name] !== value) {
					changes[name] = css.data[name];
				}
			}
		}
		return changes;
	};

	self.inject = function(){
		if(style()) {
			css.inject(data(), {constants: viewOptions.constants, style: style()});
		}
	}

	return self;
};

function StylesManager(){
	var self = {};

	self.styles = {};

	self.changes = function() {
		var changes = {};
        for(var name in self.styles) {
          var style = self.styles[name];
          changes = utils.extend(changes, style.changes());
        }
        return changes;
	};

	self.update = function(styles) {
        for(var name in styles) {
          var style = self.styles[name];
          style.update(styles && styles[name] || styles);
        }
	};

	self.inject = function(viewName, createOptions, viewOptions){
		if(!self.styles['core']) {
			var style = Styl('core', createOptions, {style: stylesCore, constants: constants});
			style.inject();
			self.styles['core'] = style;
		}

		if(!self.styles[viewName]) {
			var style = Styl(viewName, createOptions, viewOptions);
			style.inject();
			self.styles[viewName] = style;
		}
	}

	return self;
};

module.exports = StylesManager();
},{"../js/styles":21,"./constants":27,"./css":30,"./utils":43}],42:[function(require,module,exports){
module.exports = require('./bdsft').Model(URLConfig, {
	config: require('../js/config')
});

var Flags = {
	enableCallControl: 1,
	enableCallTimer: 2,
	enableCallHistory: 4,
	enableFullscreen: 8,
	enableSelfView: 16,
	enableCallStats: 32,
	enableScreenshare: 64,
	enableMute: 128,
	enableMessages: 256,
	enableRegistrationStatus: 512,
	enableConnectionStatus: 1024,
	enableSettings: 2048,
	enableAutoAnswer: 4096,
	enableConnectLocalMedia: 8192,
	enableTransfer: 16384,
	enableHold: 32768,
	enableIms: 65536
};

var Utils = require('./utils');

function URLConfig() {
	var self = {};

	var contains = function(name, value) {
		var val = self.props[name];
		return val && val.indexOf(value) !== -1
	};
	var isTrue = function(name) {
		return Utils.getSearchVariable(name);
	};
	var isFeature = function(name) {
		var features = Utils.getSearchVariable('features');
		if(!features){
			return;
		}
		return (features & Flags[name]) === Flags[name];
	};
	var isTrueOrFeature = function(name) {
		var search = Utils.getSearchVariable(name);
		if(search !== undefined) {
			return search;
		}
		return isFeature(name);
	}

	self.props = {
		audioOnly: isTrue("audioOnly"),
		hd: isTrue("hd"),
		view: Utils.getSearchVariable("view") || self.view,
		maxCallLength: Utils.getSearchVariable("maxCallLength"),
		destination: Utils.getSearchVariable("destination"),
		networkUserId: Utils.getSearchVariable("networkUserId"),
		displayName: Utils.getSearchVariable("displayName"),
		size: Utils.getSearchVariable("size"),
		features: Utils.getSearchVariable("features"),
		enableCallControl: isTrueOrFeature('enableCallControl'),
		enableCallTimer: isTrueOrFeature('enableCallTimer'),
		enableCallHistory: isTrueOrFeature('enableCallHistory'),
		enableFullscreen: isTrueOrFeature('enableFullscreen'),
		enableScreenshare: isTrueOrFeature('enableScreenshare'),
		enableSelfView: isTrueOrFeature('enableSelfView'),
		enableCallStats: isTrueOrFeature('enableCallStats'),
		enableMute: isTrueOrFeature('enableMute'),
		enableMessages: isTrueOrFeature('enableMessages'),
		enableRegistrationStatus: isTrueOrFeature('enableRegistrationStatus'),
		enableConnectionStatus: isTrueOrFeature('enableConnectionStatus'),
		enableSettings: isTrueOrFeature('enableSettings'),
		enableAutoAnswer: isTrueOrFeature('enableAutoAnswer'),
		enableConnectLocalMedia: isTrueOrFeature('enableConnectLocalMedia'),
		enableTransfer: isTrueOrFeature('enableTransfer'),
		enableHold: isTrueOrFeature('enableHold'),
		enableIms: isTrueOrFeature('enableIms')
	}

	self.props.audioOnlyView = self.props.view && self.props.view.indexOf('audioOnly') !== -1;

	self.getFeatures = function() {
		var flags = 0;
		for (var flag in Flags) {
			var value = Flags[flag];
			if (self[flag]) {
				flags |= value;
			}
		}
		return flags;
	};

	self.setFeatures = function(flags) {
		for (var flag in Flags) {
			var value = Flags[flag];
			if (flags & value) {
				self[flag] = true;
			} else {
				self[flag] = false;
			}
		}
	};

	return self;
}
},{"../js/config":20,"./bdsft":24,"./utils":43}],43:[function(require,module,exports){
var adapter = require('./adapter');
var $ = require('jquery');

var __slice = [].slice;

var Utils = {
  createFun: function(fun, argArray, target) {
    var args = [target || null].concat(argArray);
    var factoryFunction = fun.bind.apply(fun, args);
    return new factoryFunction();
  },
  toArray: function(args) {
      return Array.prototype.slice.call(args);
  },
  getElement: function(selector) {
    return $(selector);
  },
  createEvent: function(eventName) {
    return $.Event(eventName)
  },
  createElement: function(tagName, attributes, options) {
    options = options || {};
    var el = $(tagName, attributes);
    el.appendTo(options.parent || $('body'));
    return el;
  },
  resolutionWidth: function(resolution) {
    if (resolution) {
      var resolutions = resolution.split('x');
      return parseInt(resolutions[0], 10);
    }
  },
  resolutionHeight: function(resolution) {
    if (resolution) {
      var resolutions = resolution.split('x');
      return parseInt(resolutions[1], 10);
    }
  },
  withArray: function(arg) {
      return Array.isArray(arg) ? arg : [arg];
  },
  capitalizeFirstLetter: function(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  },
  lowercaseFirstLetter: function(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  },
  extend: function () {
    var consumer = arguments[0],
        providers = __slice.call(arguments, 1),
        key,
        i,
        provider;

    for (i = 0; i < providers.length; ++i) {
      provider = providers[i];
      for (key in provider) {
        if (provider.hasOwnProperty(key)) {
          consumer[key] = provider[key];
        };
      };
    };
    return consumer;
  },
  clone: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  rstring: function() { 
    return Math.random().toString().slice(2,8); 
  },
  dataURItoBlob: function(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    var byteString = atob(dataURI.split(',')[1]);

    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

    // write the bytes of the string to an ArrayBuffer
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);
    for (var i = 0; i < byteString.length; i++) {
      ia[i] = byteString.charCodeAt(i);
    }

    // write the ArrayBuffer to a blob, and you're done
    var blob = new Blob([ab], {type: mimeString});
    return blob;
  },

  camelize: function (str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function(match, index) {
      if (+match === 0) return ""; // or if (/\s+/.test(match)) for white spaces
      return index == 0 ? match.toLowerCase() : match.toUpperCase();
    });
  },

  format: function(seconds)
  {
    var hrs = Math.floor(seconds / 3600);
    seconds %= 3600;
    var mns = Math.floor(seconds / 60);
    seconds %= 60;
    var formatedDuration = (hrs < 10 ? "0" : "") + hrs + ":" + (mns < 10 ? "0" : "") + mns + ":" + (seconds < 10 ? "0" : "") + seconds;
    return(formatedDuration);
  },
  /* format date and time for call history */
  formatDateTime: function (dateStr){
    var date = new Date(dateStr);
    var strDate =  (date.getMonth() + 1) + "/" + date.getDate();
    var hours = date.getHours();
    var minutes = date.getMinutes();
    var ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours : 12; 
    minutes = minutes < 10 ? '0'+minutes : minutes;
    var strTime = hours + ':' + minutes + ' ' + ampm;
    return strDate + " - " + strTime;
  },
  /* Pull the URL variables out of URL */
  getSearchVariable: function(variable)
  {
    if(typeof location === 'undefined') {
      return;
    }
    var search = decodeURIComponent($(location).attr('search').substring(1));
    var vars = search.split("&");
    for (var i=0;i<vars.length;i++)
    {
      var pair = vars[i].split("=");
      if(pair[0] === variable)
      {
        if(pair[1] === 'true') {
          return true;
        } else if(pair[1] === 'false') {
          return false
        } else {
          return pair[1];
        }
      }
    }
    return undefined;
  },

  contains: function(srcObject, dstObject) {
    return Object.keys(this.pick(srcObject, Object.keys(dstObject))).length;
  },

  containsKey: function(object, value) {
    return this.keyIndex(object, value) !== -1;
  },

  keyIndex: function(object, value) {
    return $.inArray(value, $.map(object, function(key) { return key; }));
  },

  containsValue: function(object, value) {
    return this.valueIndex(object, value) !== -1;
  },

  valueIndex: function(object, value) {
    return $.inArray(value, $.map(object, function(key, value) { return value; }));
  },

  addSelectOptions: function(options, selector, value) {
    $.each(options, function(key, value) {
      $(selector)
        .append($('<option>', { value : value })
        .text(key));
    });
    if(value) {
      selector.val(value);
    }
  },

  // Generate a random userid
  randomUserid: function()
  {
    var chars = "0123456789abcdef";
    var string_length = 10;
    var userid = '';
    for (var i=0; i<string_length; i++)
    {
      var rnum = Math.floor(Math.random() * chars.length);
      userid += chars.substring(rnum,rnum+1);
    }
    return userid;
  },

  whiteboardCompabilityCheck: function()
  {
    var isChrome = this.isChrome();

    // Only Chrome 34+
    if (!isChrome)
    {
      return "Chrome is required for whiteboard feature, please go to:<br>" +
        "<a href='http://chrome.google.com'>http://chrome.google.com</a>";
    }
    var major = this.majorVersion();
    if (isChrome && major < 34)
    {
      return "Your version of Chrome must be upgraded to at least version 34 in order to be able to use the whiteboard<br>" +
        "Please go to: <a href='http://chrome.google.com'>http://chrome.google.com</a> or <a href='https://www.google.com/intl/en/chrome/browser/canary.html'>https://www.google.com/intl/en/chrome/browser/canary.html</a>";
    }
  },

  compatibilityCheck: function()
  {
    var isChrome = this.isChrome();
    var isFirefox = this.isFirefox();

    // Only Chrome 25+ and Firefox 22+ are supported
    if (!isChrome && !isFirefox)
    {
      return "Chrome or Firefox is required, please go to:<br>" +
        "<a href='http://chrome.google.com'>http://chrome.google.com</a> or <a href='http:www.mozilla.org'>http://www.mozilla.org</a>";
    }
    var major = this.majorVersion();
    if (isChrome && major < 25)
    {
      return "Your version of Chrome must be upgraded to at least version 25<br>" +
        "Please go to: <a href='http://chrome.google.com'>http://chrome.google.com</a>";
    }
    else
    {
      if (isFirefox && major < 22)
      {
        return "Your version of Firefox must be upgraded to at least version 22y<br>" +
          "Please go to: <a href='http://www.mozilla.org'>http://www.mozilla.org</a>";
      }
    }
  },

  isValidUsPstn: function(pstn){
    pstn = pstn.replace(/-/g, '').replace(/\(/g, '').replace(/\)/g, '');
    return pstn.match(/^1?\d{10}$/) !== null;
  },

  majorVersion: function(){
    return adapter.webrtcDetectedVersion;
  },

  isChrome: function(){
    return adapter.webrtcDetectedBrowser === 'chrome';
  },

  isFirefox: function(){
    return adapter.webrtcDetectedBrowser === 'firefox';
  },

  toArray: function(elements){
    return $(elements).map (function () {return this.toArray(); } );
  },

  rebindListeners: function(type, elements, listener){
    for(var i=0; i<elements.length; i++) {
      this.rebindListener(type, elements[i], listener);
    }
  },

  rebindListener: function(type, element, listener){
    element.off(type);
    element.on(type, listener);
  },

  pick: function(sourceObject, keys) {
    var newObject = {};
    keys.forEach(function(key) {
      if (typeof sourceObject[key] !== 'undefined') {
        newObject[key] = sourceObject[key];
      }
    });
    return newObject;
  },

  colorNameToHex: function(color){
    if(!color) {
      return false;
    }
    var colors = {"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff",
      "beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887",
      "cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff",
      "darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f",
      "darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1",
      "darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff",
      "firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff",
      "gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f",
      "honeydew":"#f0fff0","hotpink":"#ff69b4",
      "indianred ":"#cd5c5c","indigo ":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c",
      "lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2",
      "lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de",
      "lightyellow":"#ffffe0","lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6",
      "magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee",
      "mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5",
      "navajowhite":"#ffdead","navy":"#000080",
      "oldlace":"#fdf5e6","olive":"#808000","olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6",
      "palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080",
      "red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1",
      "saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4",
      "tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0",
      "violet":"#ee82ee",
      "wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5",
      "yellow":"#ffff00","yellowgreen":"#9acd32","transparent":"transparent"};

    if (typeof colors[color.toLowerCase()] !== 'undefined') {
      return colors[color.toLowerCase()];
    }

    return this.isHexColor(color) ? (color.indexOf("#") !== -1 ? color : "#"+color) : false;
  },

  isHexColor: function(color) {
    return (/(^#?[0-9A-F]{6}$)|(^#?[0-9A-F]{3}$)/i.test(color));
  },

  parseDTMFTones: function(destination) {
    if(!destination) {
      return null;
    }
    var dtmfMatch = destination.match(/,[0-9A-D#*,]+/, '');
    return dtmfMatch ? dtmfMatch[0] : null;
  }
};

module.exports = Utils;
},{"./adapter":22,"jquery":68}],44:[function(require,module,exports){
module.exports = VisibleProp;

var Prop = require('./prop');
var C = require('./constants');
var Utils = require('./utils');

function VisibleProp(obj, prop, databinder) {

	var self = {};

	if(!obj.toggle) {
		obj.toggle = function(){
			obj.visible = !obj.visible;
		};
	}
	if(!obj.show) {
		obj.show = function(){
			obj.visible = true;
		};
	}
	if(!obj.hide) {
		obj.hide = function(){
			obj.visible = false;
		};
	}
	var propObj = Prop(obj, prop, databinder);

	return propObj;
}
},{"./constants":27,"./prop":40,"./utils":43}],45:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = window.localStorage;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":46}],46:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":47}],47:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],48:[function(require,module,exports){
(function (Buffer){
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

'use strict';

function isSpecificValue(val) {
	return (
		val instanceof Buffer
		|| val instanceof Date
		|| val instanceof RegExp
	) ? true : false;
}

function cloneSpecificValue(val) {
	if (val instanceof Buffer) {
		var x = new Buffer(val.length);
		val.copy(x);
		return x;
	} else if (val instanceof Date) {
		return new Date(val.getTime());
	} else if (val instanceof RegExp) {
		return new RegExp(val);
	} else {
		throw new Error('Unexpected situation');
	}
}

/**
 * Recursive cloning array.
 */
function deepCloneArray(arr) {
	var clone = [];
	arr.forEach(function (item, index) {
		if (typeof item === 'object' && item !== null) {
			if (Array.isArray(item)) {
				clone[index] = deepCloneArray(item);
			} else if (isSpecificValue(item)) {
				clone[index] = cloneSpecificValue(item);
			} else {
				clone[index] = deepExtend({}, item);
			}
		} else {
			clone[index] = item;
		}
	});
	return clone;
}

/**
 * Extening object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */
var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {
	if (arguments.length < 1 || typeof arguments[0] !== 'object') {
		return false;
	}

	if (arguments.length < 2) {
		return arguments[0];
	}

	var target = arguments[0];

	// convert arguments to array and cut off target object
	var args = Array.prototype.slice.call(arguments, 1);

	var val, src, clone;

	args.forEach(function (obj) {
		// skip argument if it is array or isn't object
		if (typeof obj !== 'object' || Array.isArray(obj)) {
			return;
		}

		Object.keys(obj).forEach(function (key) {
			src = target[key]; // source value
			val = obj[key]; // new value

			// recursion prevention
			if (val === target) {
				return;

			/**
			 * if new value isn't object then just overwrite by new value
			 * instead of extending.
			 */
			} else if (typeof val !== 'object' || val === null) {
				target[key] = val;
				return;

			// just clone arrays (and recursive clone objects inside)
			} else if (Array.isArray(val)) {
				target[key] = deepCloneArray(val);
				return;

			// custom cloning and overwrite for specific objects
			} else if (isSpecificValue(val)) {
				target[key] = cloneSpecificValue(val);
				return;

			// overwrite by new value if source isn't object or array
			} else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
				target[key] = deepExtend({}, val);
				return;

			// source value and new value is objects both, extending...
			} else {
				target[key] = deepExtend(src, val);
				return;
			}
		});
	});

	return target;
}

}).call(this,require("buffer").Buffer)
},{"buffer":8}],49:[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2012 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var utils = require('./utils')
  , path = require('path')
  , dirname = path.dirname
  , extname = path.extname
  , join = path.join
  , fs = require('fs')
  , read = fs.readFileSync;

/**
 * Filters.
 *
 * @type Object
 */

var filters = exports.filters = require('./filters');

/**
 * Intermediate js cache.
 *
 * @type Object
 */

var cache = {};

/**
 * Clear intermediate js cache.
 *
 * @api public
 */

exports.clearCache = function(){
  cache = {};
};

/**
 * Translate filtered code into function calls.
 *
 * @param {String} js
 * @return {String}
 * @api private
 */

function filtered(js) {
  return js.substr(1).split('|').reduce(function(js, filter){
    var parts = filter.split(':')
      , name = parts.shift()
      , args = parts.join(':') || '';
    if (args) args = ', ' + args;
    return 'filters.' + name + '(' + js + args + ')';
  });
};

/**
 * Re-throw the given `err` in context to the
 * `str` of ejs, `filename`, and `lineno`.
 *
 * @param {Error} err
 * @param {String} str
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

function rethrow(err, str, filename, lineno){
  var lines = str.split('\n')
    , start = Math.max(lineno - 3, 0)
    , end = Math.min(lines.length, lineno + 3);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? ' >> ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'ejs') + ':'
    + lineno + '\n'
    + context + '\n\n'
    + err.message;

  throw err;
}

/**
 * Parse the given `str` of ejs, returning the function body.
 *
 * @param {String} str
 * @return {String}
 * @api public
 */

var parse = exports.parse = function(str, options){
  var options = options || {}
    , open = options.open || exports.open || '<%'
    , close = options.close || exports.close || '%>'
    , filename = options.filename
    , compileDebug = options.compileDebug !== false
    , buf = "";

  buf += 'var buf = [];';
  if (false !== options._with) buf += '\nwith (locals || {}) { (function(){ ';
  buf += '\n buf.push(\'';

  var lineno = 1;

  var consumeEOL = false;
  for (var i = 0, len = str.length; i < len; ++i) {
    var stri = str[i];
    if (str.slice(i, open.length + i) == open) {
      i += open.length

      var prefix, postfix, line = (compileDebug ? '__stack.lineno=' : '') + lineno;
      switch (str[i]) {
        case '=':
          prefix = "', escape((" + line + ', ';
          postfix = ")), '";
          ++i;
          break;
        case '-':
          prefix = "', (" + line + ', ';
          postfix = "), '";
          ++i;
          break;
        default:
          prefix = "');" + line + ';';
          postfix = "; buf.push('";
      }

      var end = str.indexOf(close, i);

      if (end < 0){
        throw new Error('Could not find matching close tag "' + close + '".');
      }

      var js = str.substring(i, end)
        , start = i
        , include = null
        , n = 0;

      if ('-' == js[js.length-1]){
        js = js.substring(0, js.length - 2);
        consumeEOL = true;
      }

      if (0 == js.trim().indexOf('include')) {
        var name = js.trim().slice(7).trim();
        if (!filename) throw new Error('filename option is required for includes');
        var path = resolveInclude(name, filename);
        include = read(path, 'utf8');
        include = exports.parse(include, { filename: path, _with: false, open: open, close: close, compileDebug: compileDebug });
        buf += "' + (function(){" + include + "})() + '";
        js = '';
      }

      while (~(n = js.indexOf("\n", n))) n++, lineno++;
      if (js.substr(0, 1) == ':') js = filtered(js);
      if (js) {
        if (js.lastIndexOf('//') > js.lastIndexOf('\n')) js += '\n';
        buf += prefix;
        buf += js;
        buf += postfix;
      }
      i += end - start + close.length - 1;

    } else if (stri == "\\") {
      buf += "\\\\";
    } else if (stri == "'") {
      buf += "\\'";
    } else if (stri == "\r") {
      // ignore
    } else if (stri == "\n") {
      if (consumeEOL) {
        consumeEOL = false;
      } else {
        buf += "\\n";
        lineno++;
      }
    } else {
      buf += stri;
    }
  }

  if (false !== options._with) buf += "'); })();\n} \nreturn buf.join('');";
  else buf += "');\nreturn buf.join('');";
  return buf;
};

/**
 * Compile the given `str` of ejs into a `Function`.
 *
 * @param {String} str
 * @param {Object} options
 * @return {Function}
 * @api public
 */

var compile = exports.compile = function(str, options){
  options = options || {};
  var escape = options.escape || utils.escape;

  var input = JSON.stringify(str)
    , compileDebug = options.compileDebug !== false
    , client = options.client
    , filename = options.filename
        ? JSON.stringify(options.filename)
        : 'undefined';

  if (compileDebug) {
    // Adds the fancy stack trace meta info
    str = [
      'var __stack = { lineno: 1, input: ' + input + ', filename: ' + filename + ' };',
      rethrow.toString(),
      'try {',
      exports.parse(str, options),
      '} catch (err) {',
      '  rethrow(err, __stack.input, __stack.filename, __stack.lineno);',
      '}'
    ].join("\n");
  } else {
    str = exports.parse(str, options);
  }

  if (options.debug) console.log(str);
  if (client) str = 'escape = escape || ' + escape.toString() + ';\n' + str;

  try {
    var fn = new Function('locals, filters, escape, rethrow', str);
  } catch (err) {
    if ('SyntaxError' == err.name) {
      err.message += options.filename
        ? ' in ' + filename
        : ' while compiling ejs';
    }
    throw err;
  }

  if (client) return fn;

  return function(locals){
    return fn.call(this, locals, filters, escape, rethrow);
  }
};

/**
 * Render the given `str` of ejs.
 *
 * Options:
 *
 *   - `locals`          Local variables object
 *   - `cache`           Compiled functions are cached, requires `filename`
 *   - `filename`        Used by `cache` to key caches
 *   - `scope`           Function execution context
 *   - `debug`           Output generated function body
 *   - `open`            Open tag, defaulting to "<%"
 *   - `close`           Closing tag, defaulting to "%>"
 *
 * @param {String} str
 * @param {Object} options
 * @return {String}
 * @api public
 */

exports.render = function(str, options){
  var fn
    , options = options || {};

  if (options.cache) {
    if (options.filename) {
      fn = cache[options.filename] || (cache[options.filename] = compile(str, options));
    } else {
      throw new Error('"cache" option requires "filename".');
    }
  } else {
    fn = compile(str, options);
  }

  options.__proto__ = options.locals;
  return fn.call(options.scope, options);
};

/**
 * Render an EJS file at the given `path` and callback `fn(err, str)`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function} fn
 * @api public
 */

exports.renderFile = function(path, options, fn){
  var key = path + ':string';

  if ('function' == typeof options) {
    fn = options, options = {};
  }

  options.filename = path;

  var str;
  try {
    str = options.cache
      ? cache[key] || (cache[key] = read(path, 'utf8'))
      : read(path, 'utf8');
  } catch (err) {
    fn(err);
    return;
  }
  fn(null, exports.render(str, options));
};

/**
 * Resolve include `name` relative to `filename`.
 *
 * @param {String} name
 * @param {String} filename
 * @return {String}
 * @api private
 */

function resolveInclude(name, filename) {
  var path = join(dirname(filename), name);
  var ext = extname(name);
  if (!ext) path += '.ejs';
  return path;
}

// express support

exports.__express = exports.renderFile;

/**
 * Expose to require().
 */

if (require.extensions) {
  require.extensions['.ejs'] = function (module, filename) {
    filename = filename || module.filename;
    var options = { filename: filename, client: true }
      , template = fs.readFileSync(filename).toString()
      , fn = compile(template, options);
    module._compile('module.exports = ' + fn.toString() + ';', filename);
  };
} else if (require.registerExtension) {
  require.registerExtension('.ejs', function(src) {
    return compile(src, {});
  });
}

},{"./filters":50,"./utils":51,"fs":7,"path":12}],50:[function(require,module,exports){
/*!
 * EJS - Filters
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * First element of the target `obj`.
 */

exports.first = function(obj) {
  return obj[0];
};

/**
 * Last element of the target `obj`.
 */

exports.last = function(obj) {
  return obj[obj.length - 1];
};

/**
 * Capitalize the first letter of the target `str`.
 */

exports.capitalize = function(str){
  str = String(str);
  return str[0].toUpperCase() + str.substr(1, str.length);
};

/**
 * Downcase the target `str`.
 */

exports.downcase = function(str){
  return String(str).toLowerCase();
};

/**
 * Uppercase the target `str`.
 */

exports.upcase = function(str){
  return String(str).toUpperCase();
};

/**
 * Sort the target `obj`.
 */

exports.sort = function(obj){
  return Object.create(obj).sort();
};

/**
 * Sort the target `obj` by the given `prop` ascending.
 */

exports.sort_by = function(obj, prop){
  return Object.create(obj).sort(function(a, b){
    a = a[prop], b = b[prop];
    if (a > b) return 1;
    if (a < b) return -1;
    return 0;
  });
};

/**
 * Size or length of the target `obj`.
 */

exports.size = exports.length = function(obj) {
  return obj.length;
};

/**
 * Add `a` and `b`.
 */

exports.plus = function(a, b){
  return Number(a) + Number(b);
};

/**
 * Subtract `b` from `a`.
 */

exports.minus = function(a, b){
  return Number(a) - Number(b);
};

/**
 * Multiply `a` by `b`.
 */

exports.times = function(a, b){
  return Number(a) * Number(b);
};

/**
 * Divide `a` by `b`.
 */

exports.divided_by = function(a, b){
  return Number(a) / Number(b);
};

/**
 * Join `obj` with the given `str`.
 */

exports.join = function(obj, str){
  return obj.join(str || ', ');
};

/**
 * Truncate `str` to `len`.
 */

exports.truncate = function(str, len, append){
  str = String(str);
  if (str.length > len) {
    str = str.slice(0, len);
    if (append) str += append;
  }
  return str;
};

/**
 * Truncate `str` to `n` words.
 */

exports.truncate_words = function(str, n){
  var str = String(str)
    , words = str.split(/ +/);
  return words.slice(0, n).join(' ');
};

/**
 * Replace `pattern` with `substitution` in `str`.
 */

exports.replace = function(str, pattern, substitution){
  return String(str).replace(pattern, substitution || '');
};

/**
 * Prepend `val` to `obj`.
 */

exports.prepend = function(obj, val){
  return Array.isArray(obj)
    ? [val].concat(obj)
    : val + obj;
};

/**
 * Append `val` to `obj`.
 */

exports.append = function(obj, val){
  return Array.isArray(obj)
    ? obj.concat(val)
    : obj + val;
};

/**
 * Map the given `prop`.
 */

exports.map = function(arr, prop){
  return arr.map(function(obj){
    return obj[prop];
  });
};

/**
 * Reverse the given `obj`.
 */

exports.reverse = function(obj){
  return Array.isArray(obj)
    ? obj.reverse()
    : String(obj).split('').reverse().join('');
};

/**
 * Get `prop` of the given `obj`.
 */

exports.get = function(obj, prop){
  return obj[prop];
};

/**
 * Packs the given `obj` into json string
 */
exports.json = function(obj){
  return JSON.stringify(obj);
};

},{}],51:[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html){
  return String(html)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/'/g, '&#39;')
    .replace(/"/g, '&quot;');
};
 

},{}],52:[function(require,module,exports){
'use strict';

var d        = require('d')
  , callable = require('es5-ext/object/valid-callable')

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;

},{"d":53,"es5-ext/object/valid-callable":62}],53:[function(require,module,exports){
'use strict';

var assign        = require('es5-ext/object/assign')
  , normalizeOpts = require('es5-ext/object/normalize-options')
  , isCallable    = require('es5-ext/object/is-callable')
  , contains      = require('es5-ext/string/#/contains')

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

},{"es5-ext/object/assign":54,"es5-ext/object/is-callable":57,"es5-ext/object/normalize-options":61,"es5-ext/string/#/contains":64}],54:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.assign
	: require('./shim');

},{"./is-implemented":55,"./shim":56}],55:[function(require,module,exports){
'use strict';

module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== 'function') return false;
	obj = { foo: 'raz' };
	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
	return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
};

},{}],56:[function(require,module,exports){
'use strict';

var keys  = require('../keys')
  , value = require('../valid-value')

  , max = Math.max;

module.exports = function (dest, src/*, srcn*/) {
	var error, i, l = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try { dest[key] = src[key]; } catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < l; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};

},{"../keys":58,"../valid-value":63}],57:[function(require,module,exports){
// Deprecated

'use strict';

module.exports = function (obj) { return typeof obj === 'function'; };

},{}],58:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.keys
	: require('./shim');

},{"./is-implemented":59,"./shim":60}],59:[function(require,module,exports){
'use strict';

module.exports = function () {
	try {
		Object.keys('primitive');
		return true;
	} catch (e) { return false; }
};

},{}],60:[function(require,module,exports){
'use strict';

var keys = Object.keys;

module.exports = function (object) {
	return keys(object == null ? object : Object(object));
};

},{}],61:[function(require,module,exports){
'use strict';

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

module.exports = function (options/*, options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (options == null) return;
		process(Object(options), result);
	});
	return result;
};

},{}],62:[function(require,module,exports){
'use strict';

module.exports = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

},{}],63:[function(require,module,exports){
'use strict';

module.exports = function (value) {
	if (value == null) throw new TypeError("Cannot use null or undefined");
	return value;
};

},{}],64:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? String.prototype.contains
	: require('./shim');

},{"./is-implemented":65,"./shim":66}],65:[function(require,module,exports){
'use strict';

var str = 'razdwatrzy';

module.exports = function () {
	if (typeof str.contains !== 'function') return false;
	return ((str.contains('dwa') === true) && (str.contains('foo') === false));
};

},{}],66:[function(require,module,exports){
'use strict';

var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

},{}],67:[function(require,module,exports){
/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		factory(require('jquery'));
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (value !== undefined && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setTime(+t + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {};

		// To prevent the for loop in the first place assign an empty array
		// in case there are no cookies at all. Also prevents odd result when
		// calling $.cookie().
		var cookies = document.cookie ? document.cookie.split('; ') : [];

		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = parts.join('=');

			if (key && key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) === undefined) {
			return false;
		}

		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));

},{"jquery":68}],68:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.3",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],69:[function(require,module,exports){
(function (global){
/*
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(global) {
  'use strict';

  var testingExposeCycleCount = global.testingExposeCycleCount;

  // Detect and do basic sanity checking on Object/Array.observe.
  function detectObjectObserve() {
    if (typeof Object.observe !== 'function' ||
        typeof Array.observe !== 'function') {
      return false;
    }

    var records = [];

    function callback(recs) {
      records = recs;
    }

    var test = {};
    var arr = [];
    Object.observe(test, callback);
    Array.observe(arr, callback);
    test.id = 1;
    test.id = 2;
    delete test.id;
    arr.push(1, 2);
    arr.length = 0;

    Object.deliverChangeRecords(callback);
    if (records.length !== 5)
      return false;

    if (records[0].type != 'add' ||
        records[1].type != 'update' ||
        records[2].type != 'delete' ||
        records[3].type != 'splice' ||
        records[4].type != 'splice') {
      return false;
    }

    Object.unobserve(test, callback);
    Array.unobserve(arr, callback);

    return true;
  }

  var hasObserve = detectObjectObserve();

  function detectEval() {
    // Don't test for eval if we're running in a Chrome App environment.
    // We check for APIs set that only exist in a Chrome App context.
    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {
      return false;
    }

    // Firefox OS Apps do not allow eval. This feature detection is very hacky
    // but even if some other platform adds support for this function this code
    // will continue to work.
    if (typeof navigator != 'undefined' && navigator.getDeviceStorage) {
      return false;
    }

    try {
      var f = new Function('', 'return true;');
      return f();
    } catch (ex) {
      return false;
    }
  }

  var hasEval = detectEval();

  function isIndex(s) {
    return +s === s >>> 0 && s !== '';
  }

  function toNumber(s) {
    return +s;
  }

  function isObject(obj) {
    return obj === Object(obj);
  }

  var numberIsNaN = global.Number.isNaN || function(value) {
    return typeof value === 'number' && global.isNaN(value);
  }

  function areSameValue(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    if (numberIsNaN(left) && numberIsNaN(right))
      return true;

    return left !== left && right !== right;
  }

  var createObject = ('__proto__' in {}) ?
    function(obj) { return obj; } :
    function(obj) {
      var proto = obj.__proto__;
      if (!proto)
        return obj;
      var newObject = Object.create(proto);
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        Object.defineProperty(newObject, name,
                             Object.getOwnPropertyDescriptor(obj, name));
      });
      return newObject;
    };

  var identStart = '[\$_a-zA-Z]';
  var identPart = '[\$_a-zA-Z0-9]';
  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');

  function getPathCharType(char) {
    if (char === undefined)
      return 'eof';

    var code = char.charCodeAt(0);

    switch(code) {
      case 0x5B: // [
      case 0x5D: // ]
      case 0x2E: // .
      case 0x22: // "
      case 0x27: // '
      case 0x30: // 0
        return char;

      case 0x5F: // _
      case 0x24: // $
        return 'ident';

      case 0x20: // Space
      case 0x09: // Tab
      case 0x0A: // Newline
      case 0x0D: // Return
      case 0xA0:  // No-break space
      case 0xFEFF:  // Byte Order Mark
      case 0x2028:  // Line Separator
      case 0x2029:  // Paragraph Separator
        return 'ws';
    }

    // a-z, A-Z
    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))
      return 'ident';

    // 1-9
    if (0x31 <= code && code <= 0x39)
      return 'number';

    return 'else';
  }

  var pathStateMachine = {
    'beforePath': {
      'ws': ['beforePath'],
      'ident': ['inIdent', 'append'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'inPath': {
      'ws': ['inPath'],
      '.': ['beforeIdent'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'beforeIdent': {
      'ws': ['beforeIdent'],
      'ident': ['inIdent', 'append']
    },

    'inIdent': {
      'ident': ['inIdent', 'append'],
      '0': ['inIdent', 'append'],
      'number': ['inIdent', 'append'],
      'ws': ['inPath', 'push'],
      '.': ['beforeIdent', 'push'],
      '[': ['beforeElement', 'push'],
      'eof': ['afterPath', 'push']
    },

    'beforeElement': {
      'ws': ['beforeElement'],
      '0': ['afterZero', 'append'],
      'number': ['inIndex', 'append'],
      "'": ['inSingleQuote', 'append', ''],
      '"': ['inDoubleQuote', 'append', '']
    },

    'afterZero': {
      'ws': ['afterElement', 'push'],
      ']': ['inPath', 'push']
    },

    'inIndex': {
      '0': ['inIndex', 'append'],
      'number': ['inIndex', 'append'],
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    },

    'inSingleQuote': {
      "'": ['afterElement'],
      'eof': ['error'],
      'else': ['inSingleQuote', 'append']
    },

    'inDoubleQuote': {
      '"': ['afterElement'],
      'eof': ['error'],
      'else': ['inDoubleQuote', 'append']
    },

    'afterElement': {
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    }
  }

  function noop() {}

  function parsePath(path) {
    var keys = [];
    var index = -1;
    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';

    var actions = {
      push: function() {
        if (key === undefined)
          return;

        keys.push(key);
        key = undefined;
      },

      append: function() {
        if (key === undefined)
          key = newChar
        else
          key += newChar;
      }
    };

    function maybeUnescapeQuote() {
      if (index >= path.length)
        return;

      var nextChar = path[index + 1];
      if ((mode == 'inSingleQuote' && nextChar == "'") ||
          (mode == 'inDoubleQuote' && nextChar == '"')) {
        index++;
        newChar = nextChar;
        actions.append();
        return true;
      }
    }

    while (mode) {
      index++;
      c = path[index];

      if (c == '\\' && maybeUnescapeQuote(mode))
        continue;

      type = getPathCharType(c);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap['else'] || 'error';

      if (transition == 'error')
        return; // parse error;

      mode = transition[0];
      action = actions[transition[1]] || noop;
      newChar = transition[2] === undefined ? c : transition[2];
      action();

      if (mode === 'afterPath') {
        return keys;
      }
    }

    return; // parse error
  }

  function isIdent(s) {
    return identRegExp.test(s);
  }

  var constructorIsPrivate = {};

  function Path(parts, privateToken) {
    if (privateToken !== constructorIsPrivate)
      throw Error('Use Path.get to retrieve path objects');

    for (var i = 0; i < parts.length; i++) {
      this.push(String(parts[i]));
    }

    if (hasEval && this.length) {
      this.getValueFrom = this.compiledGetValueFromFn();
    }
  }

  // TODO(rafaelw): Make simple LRU cache
  var pathCache = {};

  function getPath(pathString) {
    if (pathString instanceof Path)
      return pathString;

    if (pathString == null || pathString.length == 0)
      pathString = '';

    if (typeof pathString != 'string') {
      if (isIndex(pathString.length)) {
        // Constructed with array-like (pre-parsed) keys
        return new Path(pathString, constructorIsPrivate);
      }

      pathString = String(pathString);
    }

    var path = pathCache[pathString];
    if (path)
      return path;

    var parts = parsePath(pathString);
    if (!parts)
      return invalidPath;

    var path = new Path(parts, constructorIsPrivate);
    pathCache[pathString] = path;
    return path;
  }

  Path.get = getPath;

  function formatAccessor(key) {
    if (isIndex(key)) {
      return '[' + key + ']';
    } else {
      return '["' + key.replace(/"/g, '\\"') + '"]';
    }
  }

  Path.prototype = createObject({
    __proto__: [],
    valid: true,

    toString: function() {
      var pathString = '';
      for (var i = 0; i < this.length; i++) {
        var key = this[i];
        if (isIdent(key)) {
          pathString += i ? '.' + key : key;
        } else {
          pathString += formatAccessor(key);
        }
      }

      return pathString;
    },

    getValueFrom: function(obj, directObserver) {
      for (var i = 0; i < this.length; i++) {
        if (obj == null)
          return;
        obj = obj[this[i]];
      }
      return obj;
    },

    iterateObjects: function(obj, observe) {
      for (var i = 0; i < this.length; i++) {
        if (i)
          obj = obj[this[i - 1]];
        if (!isObject(obj))
          return;
        observe(obj, this[i]);
      }
    },

    compiledGetValueFromFn: function() {
      var str = '';
      var pathString = 'obj';
      str += 'if (obj != null';
      var i = 0;
      var key;
      for (; i < (this.length - 1); i++) {
        key = this[i];
        pathString += isIdent(key) ? '.' + key : formatAccessor(key);
        str += ' &&\n     ' + pathString + ' != null';
      }
      str += ')\n';

      var key = this[i];
      pathString += isIdent(key) ? '.' + key : formatAccessor(key);

      str += '  return ' + pathString + ';\nelse\n  return undefined;';
      return new Function('obj', str);
    },

    setValueFrom: function(obj, value) {
      if (!this.length)
        return false;

      for (var i = 0; i < this.length - 1; i++) {
        if (!isObject(obj))
          return false;
        obj = obj[this[i]];
      }

      if (!isObject(obj))
        return false;

      obj[this[i]] = value;
      return true;
    }
  });

  var invalidPath = new Path('', constructorIsPrivate);
  invalidPath.valid = false;
  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};

  var MAX_DIRTY_CHECK_CYCLES = 1000;

  function dirtyCheck(observer) {
    var cycles = 0;
    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {
      cycles++;
    }
    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    return cycles > 0;
  }

  function objectIsEmpty(object) {
    for (var prop in object)
      return false;
    return true;
  }

  function diffIsEmpty(diff) {
    return objectIsEmpty(diff.added) &&
           objectIsEmpty(diff.removed) &&
           objectIsEmpty(diff.changed);
  }

  function diffObjectFromOldObject(object, oldObject) {
    var added = {};
    var removed = {};
    var changed = {};

    for (var prop in oldObject) {
      var newValue = object[prop];

      if (newValue !== undefined && newValue === oldObject[prop])
        continue;

      if (!(prop in object)) {
        removed[prop] = undefined;
        continue;
      }

      if (newValue !== oldObject[prop])
        changed[prop] = newValue;
    }

    for (var prop in object) {
      if (prop in oldObject)
        continue;

      added[prop] = object[prop];
    }

    if (Array.isArray(object) && object.length !== oldObject.length)
      changed.length = object.length;

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  var eomTasks = [];
  function runEOMTasks() {
    if (!eomTasks.length)
      return false;

    for (var i = 0; i < eomTasks.length; i++) {
      eomTasks[i]();
    }
    eomTasks.length = 0;
    return true;
  }

  var runEOM = hasObserve ? (function(){
    return function(fn) {
      return Promise.resolve().then(fn);
    }
  })() :
  (function() {
    return function(fn) {
      eomTasks.push(fn);
    };
  })();

  var observedObjectCache = [];

  function newObservedObject() {
    var observer;
    var object;
    var discardRecords = false;
    var first = true;

    function callback(records) {
      if (observer && observer.state_ === OPENED && !discardRecords)
        observer.check_(records);
    }

    return {
      open: function(obs) {
        if (observer)
          throw Error('ObservedObject in use');

        if (!first)
          Object.deliverChangeRecords(callback);

        observer = obs;
        first = false;
      },
      observe: function(obj, arrayObserve) {
        object = obj;
        if (arrayObserve)
          Array.observe(object, callback);
        else
          Object.observe(object, callback);
      },
      deliver: function(discard) {
        discardRecords = discard;
        Object.deliverChangeRecords(callback);
        discardRecords = false;
      },
      close: function() {
        observer = undefined;
        Object.unobserve(object, callback);
        observedObjectCache.push(this);
      }
    };
  }

  /*
   * The observedSet abstraction is a perf optimization which reduces the total
   * number of Object.observe observations of a set of objects. The idea is that
   * groups of Observers will have some object dependencies in common and this
   * observed set ensures that each object in the transitive closure of
   * dependencies is only observed once. The observedSet acts as a write barrier
   * such that whenever any change comes through, all Observers are checked for
   * changed values.
   *
   * Note that this optimization is explicitly moving work from setup-time to
   * change-time.
   *
   * TODO(rafaelw): Implement "garbage collection". In order to move work off
   * the critical path, when Observers are closed, their observed objects are
   * not Object.unobserve(d). As a result, it's possible that if the observedSet
   * is kept open, but some Observers have been closed, it could cause "leaks"
   * (prevent otherwise collectable objects from being collected). At some
   * point, we should implement incremental "gc" which keeps a list of
   * observedSets which may need clean-up and does small amounts of cleanup on a
   * timeout until all is clean.
   */

  function getObservedObject(observer, object, arrayObserve) {
    var dir = observedObjectCache.pop() || newObservedObject();
    dir.open(observer);
    dir.observe(object, arrayObserve);
    return dir;
  }

  var observedSetCache = [];

  function newObservedSet() {
    var observerCount = 0;
    var observers = [];
    var objects = [];
    var rootObj;
    var rootObjProps;

    function observe(obj, prop) {
      if (!obj)
        return;

      if (obj === rootObj)
        rootObjProps[prop] = true;

      if (objects.indexOf(obj) < 0) {
        objects.push(obj);
        Object.observe(obj, callback);
      }

      observe(Object.getPrototypeOf(obj), prop);
    }

    function allRootObjNonObservedProps(recs) {
      for (var i = 0; i < recs.length; i++) {
        var rec = recs[i];
        if (rec.object !== rootObj ||
            rootObjProps[rec.name] ||
            rec.type === 'setPrototype') {
          return false;
        }
      }
      return true;
    }

    function callback(recs) {
      if (allRootObjNonObservedProps(recs))
        return;

      var observer;
      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.iterateObjects_(observe);
        }
      }

      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.check_();
        }
      }
    }

    var record = {
      objects: objects,
      get rootObject() { return rootObj; },
      set rootObject(value) {
        rootObj = value;
        rootObjProps = {};
      },
      open: function(obs, object) {
        observers.push(obs);
        observerCount++;
        obs.iterateObjects_(observe);
      },
      close: function(obs) {
        observerCount--;
        if (observerCount > 0) {
          return;
        }

        for (var i = 0; i < objects.length; i++) {
          Object.unobserve(objects[i], callback);
          Observer.unobservedCount++;
        }

        observers.length = 0;
        objects.length = 0;
        rootObj = undefined;
        rootObjProps = undefined;
        observedSetCache.push(this);
        if (lastObservedSet === this)
          lastObservedSet = null;
      },
    };

    return record;
  }

  var lastObservedSet;

  function getObservedSet(observer, obj) {
    if (!lastObservedSet || lastObservedSet.rootObject !== obj) {
      lastObservedSet = observedSetCache.pop() || newObservedSet();
      lastObservedSet.rootObject = obj;
    }
    lastObservedSet.open(observer, obj);
    return lastObservedSet;
  }

  var UNOPENED = 0;
  var OPENED = 1;
  var CLOSED = 2;
  var RESETTING = 3;

  var nextObserverId = 1;

  function Observer() {
    this.state_ = UNOPENED;
    this.callback_ = undefined;
    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef
    this.directObserver_ = undefined;
    this.value_ = undefined;
    this.id_ = nextObserverId++;
  }

  Observer.prototype = {
    open: function(callback, target) {
      if (this.state_ != UNOPENED)
        throw Error('Observer has already been opened.');

      addToAll(this);
      this.callback_ = callback;
      this.target_ = target;
      this.connect_();
      this.state_ = OPENED;
      return this.value_;
    },

    close: function() {
      if (this.state_ != OPENED)
        return;

      removeFromAll(this);
      this.disconnect_();
      this.value_ = undefined;
      this.callback_ = undefined;
      this.target_ = undefined;
      this.state_ = CLOSED;
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      dirtyCheck(this);
    },

    report_: function(changes) {
      try {
        this.callback_.apply(this.target_, changes);
      } catch (ex) {
        Observer._errorThrownDuringCallback = true;
        console.error('Exception caught during observer callback: ' +
                       (ex.stack || ex));
      }
    },

    discardChanges: function() {
      this.check_(undefined, true);
      return this.value_;
    }
  }

  var collectObservers = !hasObserve;
  var allObservers;
  Observer._allObserversCount = 0;

  if (collectObservers) {
    allObservers = [];
  }

  function addToAll(observer) {
    Observer._allObserversCount++;
    if (!collectObservers)
      return;

    allObservers.push(observer);
  }

  function removeFromAll(observer) {
    Observer._allObserversCount--;
  }

  var runningMicrotaskCheckpoint = false;

  global.Platform = global.Platform || {};

  global.Platform.performMicrotaskCheckpoint = function() {
    if (runningMicrotaskCheckpoint)
      return;

    if (!collectObservers)
      return;

    runningMicrotaskCheckpoint = true;

    var cycles = 0;
    var anyChanged, toCheck;

    do {
      cycles++;
      toCheck = allObservers;
      allObservers = [];
      anyChanged = false;

      for (var i = 0; i < toCheck.length; i++) {
        var observer = toCheck[i];
        if (observer.state_ != OPENED)
          continue;

        if (observer.check_())
          anyChanged = true;

        allObservers.push(observer);
      }
      if (runEOMTasks())
        anyChanged = true;
    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);

    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    runningMicrotaskCheckpoint = false;
  };

  if (collectObservers) {
    global.Platform.clearObservers = function() {
      allObservers = [];
    };
  }

  function ObjectObserver(object) {
    Observer.call(this);
    this.value_ = object;
    this.oldObject_ = undefined;
  }

  ObjectObserver.prototype = createObject({
    __proto__: Observer.prototype,

    arrayObserve: false,

    connect_: function(callback, target) {
      if (hasObserve) {
        this.directObserver_ = getObservedObject(this, this.value_,
                                                 this.arrayObserve);
      } else {
        this.oldObject_ = this.copyObject(this.value_);
      }

    },

    copyObject: function(object) {
      var copy = Array.isArray(object) ? [] : {};
      for (var prop in object) {
        copy[prop] = object[prop];
      };
      if (Array.isArray(object))
        copy.length = object.length;
      return copy;
    },

    check_: function(changeRecords, skipChanges) {
      var diff;
      var oldValues;
      if (hasObserve) {
        if (!changeRecords)
          return false;

        oldValues = {};
        diff = diffObjectFromChangeRecords(this.value_, changeRecords,
                                           oldValues);
      } else {
        oldValues = this.oldObject_;
        diff = diffObjectFromOldObject(this.value_, this.oldObject_);
      }

      if (diffIsEmpty(diff))
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([
        diff.added || {},
        diff.removed || {},
        diff.changed || {},
        function(property) {
          return oldValues[property];
        }
      ]);

      return true;
    },

    disconnect_: function() {
      if (hasObserve) {
        this.directObserver_.close();
        this.directObserver_ = undefined;
      } else {
        this.oldObject_ = undefined;
      }
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      if (hasObserve)
        this.directObserver_.deliver(false);
      else
        dirtyCheck(this);
    },

    discardChanges: function() {
      if (this.directObserver_)
        this.directObserver_.deliver(true);
      else
        this.oldObject_ = this.copyObject(this.value_);

      return this.value_;
    }
  });

  function ArrayObserver(array) {
    if (!Array.isArray(array))
      throw Error('Provided object is not an Array');
    ObjectObserver.call(this, array);
  }

  ArrayObserver.prototype = createObject({

    __proto__: ObjectObserver.prototype,

    arrayObserve: true,

    copyObject: function(arr) {
      return arr.slice();
    },

    check_: function(changeRecords) {
      var splices;
      if (hasObserve) {
        if (!changeRecords)
          return false;
        splices = projectArraySplices(this.value_, changeRecords);
      } else {
        splices = calcSplices(this.value_, 0, this.value_.length,
                              this.oldObject_, 0, this.oldObject_.length);
      }

      if (!splices || !splices.length)
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([splices]);
      return true;
    }
  });

  ArrayObserver.applySplices = function(previous, current, splices) {
    splices.forEach(function(splice) {
      var spliceArgs = [splice.index, splice.removed.length];
      var addIndex = splice.index;
      while (addIndex < splice.index + splice.addedCount) {
        spliceArgs.push(current[addIndex]);
        addIndex++;
      }

      Array.prototype.splice.apply(previous, spliceArgs);
    });
  };

  function PathObserver(object, path) {
    Observer.call(this);

    this.object_ = object;
    this.path_ = getPath(path);
    this.directObserver_ = undefined;
  }

  PathObserver.prototype = createObject({
    __proto__: Observer.prototype,

    get path() {
      return this.path_;
    },

    connect_: function() {
      if (hasObserve)
        this.directObserver_ = getObservedSet(this, this.object_);

      this.check_(undefined, true);
    },

    disconnect_: function() {
      this.value_ = undefined;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    iterateObjects_: function(observe) {
      this.path_.iterateObjects(this.object_, observe);
    },

    check_: function(changeRecords, skipChanges) {
      var oldValue = this.value_;
      this.value_ = this.path_.getValueFrom(this.object_);
      if (skipChanges || areSameValue(this.value_, oldValue))
        return false;

      this.report_([this.value_, oldValue, this]);
      return true;
    },

    setValue: function(newValue) {
      if (this.path_)
        this.path_.setValueFrom(this.object_, newValue);
    }
  });

  function CompoundObserver(reportChangesOnOpen) {
    Observer.call(this);

    this.reportChangesOnOpen_ = reportChangesOnOpen;
    this.value_ = [];
    this.directObserver_ = undefined;
    this.observed_ = [];
  }

  var observerSentinel = {};

  CompoundObserver.prototype = createObject({
    __proto__: Observer.prototype,

    connect_: function() {
      if (hasObserve) {
        var object;
        var needsDirectObserver = false;
        for (var i = 0; i < this.observed_.length; i += 2) {
          object = this.observed_[i]
          if (object !== observerSentinel) {
            needsDirectObserver = true;
            break;
          }
        }

        if (needsDirectObserver)
          this.directObserver_ = getObservedSet(this, object);
      }

      this.check_(undefined, !this.reportChangesOnOpen_);
    },

    disconnect_: function() {
      for (var i = 0; i < this.observed_.length; i += 2) {
        if (this.observed_[i] === observerSentinel)
          this.observed_[i + 1].close();
      }
      this.observed_.length = 0;
      this.value_.length = 0;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    addPath: function(object, path) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add paths once started.');

      var path = getPath(path);
      this.observed_.push(object, path);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = path.getValueFrom(object);
    },

    addObserver: function(observer) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add observers once started.');

      this.observed_.push(observerSentinel, observer);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = observer.open(this.deliver, this);
    },

    startReset: function() {
      if (this.state_ != OPENED)
        throw Error('Can only reset while open');

      this.state_ = RESETTING;
      this.disconnect_();
    },

    finishReset: function() {
      if (this.state_ != RESETTING)
        throw Error('Can only finishReset after startReset');
      this.state_ = OPENED;
      this.connect_();

      return this.value_;
    },

    iterateObjects_: function(observe) {
      var object;
      for (var i = 0; i < this.observed_.length; i += 2) {
        object = this.observed_[i]
        if (object !== observerSentinel)
          this.observed_[i + 1].iterateObjects(object, observe)
      }
    },

    check_: function(changeRecords, skipChanges) {
      var oldValues;
      for (var i = 0; i < this.observed_.length; i += 2) {
        var object = this.observed_[i];
        var path = this.observed_[i+1];
        var value;
        if (object === observerSentinel) {
          var observable = path;
          value = this.state_ === UNOPENED ?
              observable.open(this.deliver, this) :
              observable.discardChanges();
        } else {
          value = path.getValueFrom(object);
        }

        if (skipChanges) {
          this.value_[i / 2] = value;
          continue;
        }

        if (areSameValue(value, this.value_[i / 2]))
          continue;

        oldValues = oldValues || [];
        oldValues[i / 2] = this.value_[i / 2];
        this.value_[i / 2] = value;
      }

      if (!oldValues)
        return false;

      // TODO(rafaelw): Having observed_ as the third callback arg here is
      // pretty lame API. Fix.
      this.report_([this.value_, oldValues, this.observed_]);
      return true;
    }
  });

  function identFn(value) { return value; }

  function ObserverTransform(observable, getValueFn, setValueFn,
                             dontPassThroughSet) {
    this.callback_ = undefined;
    this.target_ = undefined;
    this.value_ = undefined;
    this.observable_ = observable;
    this.getValueFn_ = getValueFn || identFn;
    this.setValueFn_ = setValueFn || identFn;
    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this
    // at the moment because of a bug in it's dependency tracking.
    this.dontPassThroughSet_ = dontPassThroughSet;
  }

  ObserverTransform.prototype = {
    open: function(callback, target) {
      this.callback_ = callback;
      this.target_ = target;
      this.value_ =
          this.getValueFn_(this.observable_.open(this.observedCallback_, this));
      return this.value_;
    },

    observedCallback_: function(value) {
      value = this.getValueFn_(value);
      if (areSameValue(value, this.value_))
        return;
      var oldValue = this.value_;
      this.value_ = value;
      this.callback_.call(this.target_, this.value_, oldValue);
    },

    discardChanges: function() {
      this.value_ = this.getValueFn_(this.observable_.discardChanges());
      return this.value_;
    },

    deliver: function() {
      return this.observable_.deliver();
    },

    setValue: function(value) {
      value = this.setValueFn_(value);
      if (!this.dontPassThroughSet_ && this.observable_.setValue)
        return this.observable_.setValue(value);
    },

    close: function() {
      if (this.observable_)
        this.observable_.close();
      this.callback_ = undefined;
      this.target_ = undefined;
      this.observable_ = undefined;
      this.value_ = undefined;
      this.getValueFn_ = undefined;
      this.setValueFn_ = undefined;
    }
  }

  var expectedRecordTypes = {
    add: true,
    update: true,
    delete: true
  };

  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {
    var added = {};
    var removed = {};

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      if (!expectedRecordTypes[record.type]) {
        console.error('Unknown changeRecord type: ' + record.type);
        console.error(record);
        continue;
      }

      if (!(record.name in oldValues))
        oldValues[record.name] = record.oldValue;

      if (record.type == 'update')
        continue;

      if (record.type == 'add') {
        if (record.name in removed)
          delete removed[record.name];
        else
          added[record.name] = true;

        continue;
      }

      // type = 'delete'
      if (record.name in added) {
        delete added[record.name];
        delete oldValues[record.name];
      } else {
        removed[record.name] = true;
      }
    }

    for (var prop in added)
      added[prop] = object[prop];

    for (var prop in removed)
      removed[prop] = undefined;

    var changed = {};
    for (var prop in oldValues) {
      if (prop in added || prop in removed)
        continue;

      var newValue = object[prop];
      if (oldValues[prop] !== newValue)
        changed[prop] = newValue;
    }

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  function ArraySplice() {}

  ArraySplice.prototype = {

    // Note: This function is *based* on the computation of the Levenshtein
    // "edit" distance. The one change is that "updates" are treated as two
    // edits - not one. With Array splices, an update is really a delete
    // followed by an add. By retaining this, we optimize for "keeping" the
    // maximum array items in the original array. For example:
    //
    //   'xxxx123' -> '123yyyy'
    //
    // With 1-edit updates, the shortest path would be just to update all seven
    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
    // leaves the substring '123' intact.
    calcEditDistances: function(current, currentStart, currentEnd,
                                old, oldStart, oldEnd) {
      // "Deletion" columns
      var rowCount = oldEnd - oldStart + 1;
      var columnCount = currentEnd - currentStart + 1;
      var distances = new Array(rowCount);

      // "Addition" rows. Initialize null column.
      for (var i = 0; i < rowCount; i++) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }

      // Initialize null row
      for (var j = 0; j < columnCount; j++)
        distances[0][j] = j;

      for (var i = 1; i < rowCount; i++) {
        for (var j = 1; j < columnCount; j++) {
          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
            distances[i][j] = distances[i - 1][j - 1];
          else {
            var north = distances[i - 1][j] + 1;
            var west = distances[i][j - 1] + 1;
            distances[i][j] = north < west ? north : west;
          }
        }
      }

      return distances;
    },

    // This starts at the final weight, and walks "backward" by finding
    // the minimum previous weight recursively until the origin of the weight
    // matrix.
    spliceOperationsFromEditDistances: function(distances) {
      var i = distances.length - 1;
      var j = distances[0].length - 1;
      var current = distances[i][j];
      var edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        var northWest = distances[i - 1][j - 1];
        var west = distances[i - 1][j];
        var north = distances[i][j - 1];

        var min;
        if (west < north)
          min = west < northWest ? west : northWest;
        else
          min = north < northWest ? north : northWest;

        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }

      edits.reverse();
      return edits;
    },

    /**
     * Splice Projection functions:
     *
     * A splice map is a representation of how a previous array of items
     * was transformed into a new array of items. Conceptually it is a list of
     * tuples of
     *
     *   <index, removed, addedCount>
     *
     * which are kept in ascending index order of. The tuple represents that at
     * the |index|, |removed| sequence of items were removed, and counting forward
     * from |index|, |addedCount| items were added.
     */

    /**
     * Lacking individual splice mutation information, the minimal set of
     * splices can be synthesized given the previous state and final state of an
     * array. The basic approach is to calculate the edit distance matrix and
     * choose the shortest path through it.
     *
     * Complexity: O(l * p)
     *   l: The length of the current array
     *   p: The length of the old array
     */
    calcSplices: function(current, currentStart, currentEnd,
                          old, oldStart, oldEnd) {
      var prefixCount = 0;
      var suffixCount = 0;

      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0)
        prefixCount = this.sharedPrefix(current, old, minLength);

      if (currentEnd == current.length && oldEnd == old.length)
        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);

      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;

      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
        return [];

      if (currentStart == currentEnd) {
        var splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd)
          splice.removed.push(old[oldStart++]);

        return [ splice ];
      } else if (oldStart == oldEnd)
        return [ newSplice(currentStart, [], currentEnd - currentStart) ];

      var ops = this.spliceOperationsFromEditDistances(
          this.calcEditDistances(current, currentStart, currentEnd,
                                 old, oldStart, oldEnd));

      var splice = undefined;
      var splices = [];
      var index = currentStart;
      var oldIndex = oldStart;
      for (var i = 0; i < ops.length; i++) {
        switch(ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }

            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }

      if (splice) {
        splices.push(splice);
      }
      return splices;
    },

    sharedPrefix: function(current, old, searchLength) {
      for (var i = 0; i < searchLength; i++)
        if (!this.equals(current[i], old[i]))
          return i;
      return searchLength;
    },

    sharedSuffix: function(current, old, searchLength) {
      var index1 = current.length;
      var index2 = old.length;
      var count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2]))
        count++;

      return count;
    },

    calculateSplices: function(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0,
                              previous.length);
    },

    equals: function(currentValue, previousValue) {
      return currentValue === previousValue;
    }
  };

  var arraySplice = new ArraySplice();

  function calcSplices(current, currentStart, currentEnd,
                       old, oldStart, oldEnd) {
    return arraySplice.calcSplices(current, currentStart, currentEnd,
                                   old, oldStart, oldEnd);
  }

  function intersect(start1, end1, start2, end2) {
    // Disjoint
    if (end1 < start2 || end2 < start1)
      return -1;

    // Adjacent
    if (end1 == start2 || end2 == start1)
      return 0;

    // Non-zero intersect, span1 first
    if (start1 < start2) {
      if (end1 < end2)
        return end1 - start2; // Overlap
      else
        return end2 - start2; // Contained
    } else {
      // Non-zero intersect, span2 first
      if (end2 < end1)
        return end2 - start1; // Overlap
      else
        return end1 - start1; // Contained
    }
  }

  function mergeSplice(splices, index, removed, addedCount) {

    var splice = newSplice(index, removed, addedCount);

    var inserted = false;
    var insertionOffset = 0;

    for (var i = 0; i < splices.length; i++) {
      var current = splices[i];
      current.index += insertionOffset;

      if (inserted)
        continue;

      var intersectCount = intersect(splice.index,
                                     splice.index + splice.removed.length,
                                     current.index,
                                     current.index + current.addedCount);

      if (intersectCount >= 0) {
        // Merge the two splices

        splices.splice(i, 1);
        i--;

        insertionOffset -= current.addedCount - current.removed.length;

        splice.addedCount += current.addedCount - intersectCount;
        var deleteCount = splice.removed.length +
                          current.removed.length - intersectCount;

        if (!splice.addedCount && !deleteCount) {
          // merged splice is a noop. discard.
          inserted = true;
        } else {
          var removed = current.removed;

          if (splice.index < current.index) {
            // some prefix of splice.removed is prepended to current.removed.
            var prepend = splice.removed.slice(0, current.index - splice.index);
            Array.prototype.push.apply(prepend, removed);
            removed = prepend;
          }

          if (splice.index + splice.removed.length > current.index + current.addedCount) {
            // some suffix of splice.removed is appended to current.removed.
            var append = splice.removed.slice(current.index + current.addedCount - splice.index);
            Array.prototype.push.apply(removed, append);
          }

          splice.removed = removed;
          if (current.index < splice.index) {
            splice.index = current.index;
          }
        }
      } else if (splice.index < current.index) {
        // Insert splice here.

        inserted = true;

        splices.splice(i, 0, splice);
        i++;

        var offset = splice.addedCount - splice.removed.length
        current.index += offset;
        insertionOffset += offset;
      }
    }

    if (!inserted)
      splices.push(splice);
  }

  function createInitialSplices(array, changeRecords) {
    var splices = [];

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      switch(record.type) {
        case 'splice':
          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
          break;
        case 'add':
        case 'update':
        case 'delete':
          if (!isIndex(record.name))
            continue;
          var index = toNumber(record.name);
          if (index < 0)
            continue;
          mergeSplice(splices, index, [record.oldValue], 1);
          break;
        default:
          console.error('Unexpected record type: ' + JSON.stringify(record));
          break;
      }
    }

    return splices;
  }

  function projectArraySplices(array, changeRecords) {
    var splices = [];

    createInitialSplices(array, changeRecords).forEach(function(splice) {
      if (splice.addedCount == 1 && splice.removed.length == 1) {
        if (splice.removed[0] !== array[splice.index])
          splices.push(splice);

        return
      };

      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,
                                           splice.removed, 0, splice.removed.length));
    });

    return splices;
  }

  // Export the observe-js object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, export as a global object.

  var expose = global;

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      expose = exports = module.exports;
    }
    expose = exports;
  } 

  expose.Observer = Observer;
  expose.Observer.runEOM_ = runEOM;
  expose.Observer.observerSentinel_ = observerSentinel; // for testing.
  expose.Observer.hasObjectObserve = hasObserve;
  expose.ArrayObserver = ArrayObserver;
  expose.ArrayObserver.calculateSplices = function(current, previous) {
    return arraySplice.calculateSplices(current, previous);
  };

  expose.ArraySplice = ArraySplice;
  expose.ObjectObserver = ObjectObserver;
  expose.PathObserver = PathObserver;
  expose.CompoundObserver = CompoundObserver;
  expose.Path = Path;
  expose.ObserverTransform = ObserverTransform;
  
})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],70:[function(require,module,exports){
// Domain Public by Eric Wendelin http://www.eriwen.com/ (2008)
//                  Luke Smith http://lucassmith.name/ (2008)
//                  Loic Dachary <loic@dachary.org> (2008)
//                  Johan Euphrosine <proppy@aminche.com> (2008)
//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)
/*global module, exports, define, ActiveXObject*/
(function(global, factory) {
    if (typeof exports === 'object') {
        // Node
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else {
        // Browser globals
        global.printStackTrace = factory();
    }
}(this, function() {
    /**
     * Main function giving a function stack trace with a forced or passed in Error
     *
     * @cfg {Error} e The error to create a stacktrace from (optional)
     * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions
     * @return {Array} of Strings with functions, lines, files, and arguments where possible
     */
    function printStackTrace(options) {
        options = options || {guess: true};
        var ex = options.e || null, guess = !!options.guess, mode = options.mode || null;
        var p = new printStackTrace.implementation(), result = p.run(ex, mode);
        return (guess) ? p.guessAnonymousFunctions(result) : result;
    }

    printStackTrace.implementation = function() {
    };

    printStackTrace.implementation.prototype = {
        /**
         * @param {Error} [ex] The error to create a stacktrace from (optional)
         * @param {String} [mode] Forced mode (optional, mostly for unit tests)
         */
        run: function(ex, mode) {
            ex = ex || this.createException();
            mode = mode || this.mode(ex);
            if (mode === 'other') {
                return this.other(arguments.callee);
            } else {
                return this[mode](ex);
            }
        },

        createException: function() {
            try {
                this.undef();
            } catch (e) {
                return e;
            }
        },

        /**
         * Mode could differ for different exception, e.g.
         * exceptions in Chrome may or may not have arguments or stack.
         *
         * @return {String} mode of operation for the exception
         */
        mode: function(e) {
            if (typeof window !== 'undefined' && window.navigator.userAgent.indexOf('PhantomJS') > -1) {
                return 'phantomjs';
            }

            if (e['arguments'] && e.stack) {
                return 'chrome';
            }

            if (e.stack && e.sourceURL) {
                return 'safari';
            }

            if (e.stack && e.number) {
                return 'ie';
            }

            if (e.stack && e.fileName) {
                return 'firefox';
            }

            if (e.message && e['opera#sourceloc']) {
                // e.message.indexOf("Backtrace:") > -1 -> opera9
                // 'opera#sourceloc' in e -> opera9, opera10a
                // !e.stacktrace -> opera9
                if (!e.stacktrace) {
                    return 'opera9'; // use e.message
                }
                if (e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
                    // e.message may have more stack entries than e.stacktrace
                    return 'opera9'; // use e.message
                }
                return 'opera10a'; // use e.stacktrace
            }

            if (e.message && e.stack && e.stacktrace) {
                // e.stacktrace && e.stack -> opera10b
                if (e.stacktrace.indexOf("called from line") < 0) {
                    return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'
                }
                // e.stacktrace && e.stack -> opera11
                return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'
            }

            if (e.stack && !e.fileName) {
                // Chrome 27 does not have e.arguments as earlier versions,
                // but still does not have e.fileName as Firefox
                return 'chrome';
            }

            return 'other';
        },

        /**
         * Given a context, function name, and callback function, overwrite it so that it calls
         * printStackTrace() first with a callback and then runs the rest of the body.
         *
         * @param {Object} context of execution (e.g. window)
         * @param {String} functionName to instrument
         * @param {Function} callback function to call with a stack trace on invocation
         */
        instrumentFunction: function(context, functionName, callback) {
            context = context || window;
            var original = context[functionName];
            context[functionName] = function instrumented() {
                callback.call(this, printStackTrace().slice(4));
                return context[functionName]._instrumented.apply(this, arguments);
            };
            context[functionName]._instrumented = original;
        },

        /**
         * Given a context and function name of a function that has been
         * instrumented, revert the function to it's original (non-instrumented)
         * state.
         *
         * @param {Object} context of execution (e.g. window)
         * @param {String} functionName to de-instrument
         */
        deinstrumentFunction: function(context, functionName) {
            if (context[functionName].constructor === Function &&
                context[functionName]._instrumented &&
                context[functionName]._instrumented.constructor === Function) {
                context[functionName] = context[functionName]._instrumented;
            }
        },

        /**
         * Given an Error object, return a formatted Array based on Chrome's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        chrome: function(e) {
            return (e.stack + '\n')
                .replace(/^[\s\S]+?\s+at\s+/, ' at ') // remove message
                .replace(/^\s+(at eval )?at\s+/gm, '') // remove 'at' and indentation
                .replace(/^([^\(]+?)([\n$])/gm, '{anonymous}() ($1)$2')
                .replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}() ($1)')
                .replace(/^(.+) \((.+)\)$/gm, '$1@$2')
                .split('\n')
                .slice(0, -1);
        },

        /**
         * Given an Error object, return a formatted Array based on Safari's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        safari: function(e) {
            return e.stack.replace(/\[native code\]\n/m, '')
                .replace(/^(?=\w+Error\:).*$\n/m, '')
                .replace(/^@/gm, '{anonymous}()@')
                .split('\n');
        },

        /**
         * Given an Error object, return a formatted Array based on IE's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        ie: function(e) {
            return e.stack
                .replace(/^\s*at\s+(.*)$/gm, '$1')
                .replace(/^Anonymous function\s+/gm, '{anonymous}() ')
                .replace(/^(.+)\s+\((.+)\)$/gm, '$1@$2')
                .split('\n')
                .slice(1);
        },

        /**
         * Given an Error object, return a formatted Array based on Firefox's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        firefox: function(e) {
            return e.stack.replace(/(?:\n@:0)?\s+$/m, '')
                .replace(/^(?:\((\S*)\))?@/gm, '{anonymous}($1)@')
                .split('\n');
        },

        opera11: function(e) {
            var ANON = '{anonymous}', lineRE = /^.*line (\d+), column (\d+)(?: in (.+))? in (\S+):$/;
            var lines = e.stacktrace.split('\n'), result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    var location = match[4] + ':' + match[1] + ':' + match[2];
                    var fnName = match[3] || "global code";
                    fnName = fnName.replace(/<anonymous function: (\S+)>/, "$1").replace(/<anonymous function>/, ANON);
                    result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
                }
            }

            return result;
        },

        opera10b: function(e) {
            // "<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\n" +
            // "printStackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\n" +
            // "@file://localhost/G:/js/test/functional/testcase1.html:15"
            var lineRE = /^(.*)@(.+):(\d+)$/;
            var lines = e.stacktrace.split('\n'), result = [];

            for (var i = 0, len = lines.length; i < len; i++) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    var fnName = match[1] ? (match[1] + '()') : "global code";
                    result.push(fnName + '@' + match[2] + ':' + match[3]);
                }
            }

            return result;
        },

        /**
         * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        opera10a: function(e) {
            // "  Line 27 of linked script file://localhost/G:/js/stacktrace.js\n"
            // "  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\n"
            var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n'), result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    var fnName = match[3] || ANON;
                    result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
                }
            }

            return result;
        },

        // Opera 7.x-9.2x only!
        opera9: function(e) {
            // "  Line 43 of linked script file://localhost/G:/js/stacktrace.js\n"
            // "  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\n"
            var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n'), result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
                }
            }

            return result;
        },

        phantomjs: function(e) {
            var ANON = '{anonymous}', lineRE = /(\S+) \((\S+)\)/i;
            var lines = e.stack.split('\n'), result = [];

            for (var i = 1, len = lines.length; i < len; i++) {
                lines[i] = lines[i].replace(/^\s+at\s+/gm, '');
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(match[1] + '()@' + match[2]);
                }
                else {
                    result.push(ANON + '()@' + lines[i]);
                }
            }

            return result;
        },

        // Safari 5-, IE 9-, and others
        other: function(curr) {
            var ANON = '{anonymous}', fnRE = /function(?:\s+([\w$]+))?\s*\(/, stack = [], fn, args, maxStackSize = 10;
            var slice = Array.prototype.slice;
            while (curr && stack.length < maxStackSize) {
                fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
                try {
                    args = slice.call(curr['arguments'] || []);
                } catch (e) {
                    args = ['Cannot access arguments: ' + e];
                }
                stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
                try {
                    curr = curr.caller;
                } catch (e) {
                    stack[stack.length] = 'Cannot access caller: ' + e;
                    break;
                }
            }
            return stack;
        },

        /**
         * Given arguments array as a String, substituting type names for non-string types.
         *
         * @param {Arguments,Array} args
         * @return {String} stringified arguments
         */
        stringifyArguments: function(args) {
            var result = [];
            var slice = Array.prototype.slice;
            for (var i = 0; i < args.length; ++i) {
                var arg = args[i];
                if (arg === undefined) {
                    result[i] = 'undefined';
                } else if (arg === null) {
                    result[i] = 'null';
                } else if (arg.constructor) {
                    // TODO constructor comparison does not work for iframes
                    if (arg.constructor === Array) {
                        if (arg.length < 3) {
                            result[i] = '[' + this.stringifyArguments(arg) + ']';
                        } else {
                            result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                        }
                    } else if (arg.constructor === Object) {
                        result[i] = '#object';
                    } else if (arg.constructor === Function) {
                        result[i] = '#function';
                    } else if (arg.constructor === String) {
                        result[i] = '"' + arg + '"';
                    } else if (arg.constructor === Number) {
                        result[i] = arg;
                    } else {
                        result[i] = '?';
                    }
                }
            }
            return result.join(',');
        },

        sourceCache: {},

        /**
         * @return {String} the text from a given URL
         */
        ajax: function(url) {
            var req = this.createXMLHTTPObject();
            if (req) {
                try {
                    req.open('GET', url, false);
                    //req.overrideMimeType('text/plain');
                    //req.overrideMimeType('text/javascript');
                    req.send(null);
                    //return req.status == 200 ? req.responseText : '';
                    return req.responseText;
                } catch (e) {
                }
            }
            return '';
        },

        /**
         * Try XHR methods in order and store XHR factory.
         *
         * @return {XMLHttpRequest} XHR function or equivalent
         */
        createXMLHTTPObject: function() {
            var xmlhttp, XMLHttpFactories = [
                function() {
                    return new XMLHttpRequest();
                }, function() {
                    return new ActiveXObject('Msxml2.XMLHTTP');
                }, function() {
                    return new ActiveXObject('Msxml3.XMLHTTP');
                }, function() {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                }
            ];
            for (var i = 0; i < XMLHttpFactories.length; i++) {
                try {
                    xmlhttp = XMLHttpFactories[i]();
                    // Use memoization to cache the factory
                    this.createXMLHTTPObject = XMLHttpFactories[i];
                    return xmlhttp;
                } catch (e) {
                }
            }
        },

        /**
         * Given a URL, check if it is in the same domain (so we can get the source
         * via Ajax).
         *
         * @param url {String} source url
         * @return {Boolean} False if we need a cross-domain request
         */
        isSameDomain: function(url) {
            return typeof location !== "undefined" && url.indexOf(location.hostname) !== -1; // location may not be defined, e.g. when running from nodejs.
        },

        /**
         * Get source code from given URL if in the same domain.
         *
         * @param url {String} JS source URL
         * @return {Array} Array of source code lines
         */
        getSource: function(url) {
            // TODO reuse source from script tags?
            if (!(url in this.sourceCache)) {
                this.sourceCache[url] = this.ajax(url).split('\n');
            }
            return this.sourceCache[url];
        },

        guessAnonymousFunctions: function(stack) {
            for (var i = 0; i < stack.length; ++i) {
                var reStack = /\{anonymous\}\(.*\)@(.*)/,
                    reRef = /^(.*?)(?::(\d+))(?::(\d+))?(?: -- .+)?$/,
                    frame = stack[i], ref = reStack.exec(frame);

                if (ref) {
                    var m = reRef.exec(ref[1]);
                    if (m) { // If falsey, we did not get any file/line information
                        var file = m[1], lineno = m[2], charno = m[3] || 0;
                        if (file && this.isSameDomain(file) && lineno) {
                            var functionName = this.guessAnonymousFunction(file, lineno, charno);
                            stack[i] = frame.replace('{anonymous}', functionName);
                        }
                    }
                }
            }
            return stack;
        },

        guessAnonymousFunction: function(url, lineNo, charNo) {
            var ret;
            try {
                ret = this.findFunctionName(this.getSource(url), lineNo);
            } catch (e) {
                ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
            }
            return ret;
        },

        findFunctionName: function(source, lineNo) {
            // FIXME findFunctionName fails for compressed source
            // (more than one function on the same line)
            // function {name}({args}) m[1]=name m[2]=args
            var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
            // {name} = function ({args}) TODO args capture
            // /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
            var reFunctionExpression = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/;
            // {name} = eval()
            var reFunctionEvaluation = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
            // Walk backwards in the source lines until we find
            // the line which matches one of the patterns above
            var code = "", line, maxLines = Math.min(lineNo, 20), m, commentPos;
            for (var i = 0; i < maxLines; ++i) {
                // lineNo is 1-based, source[] is 0-based
                line = source[lineNo - i - 1];
                commentPos = line.indexOf('//');
                if (commentPos >= 0) {
                    line = line.substr(0, commentPos);
                }
                // TODO check other types of comments? Commented code may lead to false positive
                if (line) {
                    code = line + code;
                    m = reFunctionExpression.exec(code);
                    if (m && m[1]) {
                        return m[1];
                    }
                    m = reFunctionDeclaration.exec(code);
                    if (m && m[1]) {
                        //return m[1] + "(" + (m[2] || "") + ")";
                        return m[1];
                    }
                    m = reFunctionEvaluation.exec(code);
                    if (m && m[1]) {
                        return m[1];
                    }
                }
            }
            return '(?)';
        }
    };

    return printStackTrace;
}));

},{}],71:[function(require,module,exports){
module.exports = {view: require('./lib/views/authentication'), model: require('./lib/models/authentication')};
},{"./lib/models/authentication":75,"./lib/views/authentication":76}],72:[function(require,module,exports){
module.exports = {
    register: false
};
},{}],73:[function(require,module,exports){
module.exports = {"authentication":".bdsft-webrtc .authenticationView span{color:#999;font-size:14px;line-height:18px}.bdsft-webrtc .authenticationView input{background:#666;border-bottom:1px solid #333;border-left:1px solid #000;border-right:1px solid #333;border-top:1px solid #000;color:#fff;border-radius:3px;font-family:arial;font-size:16px;padding:6px 6px 4px;width:200px}.bdsft-webrtc .authenticationView button{border-color:#999;border-width:1px;border-radius:4px;color:#333;cursor:pointer;padding:6px 6px 4px;margin-top:10px;font-size:12px;width:200px}.bdsft-webrtc .authenticationView .alert{font-size:20px;text-align:center;color:#f00}.bdsft-webrtc .authenticationView .signIn,.bdsft-webrtc .authenticationView .signOut{display:none}.bdsft-webrtc .authenticationView:not(.disconnected).authentication-shown,.bdsft-webrtc .authenticationView:not(.registered):not(.registering).register{transition:all 1s linear;opacity:1;z-index:100}.bdsft-webrtc .authenticationView.disconnected,.bdsft-webrtc .authenticationView:not(.authentication-shown),.bdsft-webrtc .authenticationView.registered{transition:all 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .authenticationView:not(.registered) .signIn,.bdsft-webrtc .authenticationView.registered .signOut{display:block}.bdsft-webrtc .authenticationView.registered .userid,.bdsft-webrtc .authenticationView.registered .authenticationUserid,.bdsft-webrtc .authenticationView.registered .password{pointer-events:none;cursor:default;background-color:#999;opacity:.5}.bdsft-webrtc .authenticationView.registering .signIn,.bdsft-webrtc .authenticationView.unregistering .signOut{pointer-events:none;cursor:default;background-color:#999;opacity:.5}"}
},{}],74:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // authentication.jade compiled template
    templatizer["authentication"] = function tmpl_authentication() {
        return '<div class="bdsft-webrtc"><div class="authenticationView fadeable popup classes centered"><span>User ID</span><br/><input type="text" value="" class="userid"/><br/><span>Auth User ID</span><br/><input type="text" value="" class="authenticationUserid"/><br/><span>Password</span><br/><input type="password" value="" class="password"/><br/><br/><div class="alert"></div><button type="button" class="signIn button">Sign in</button><br/><button type="button" class="signOut button">Sign out</button></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],75:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Authentication, {
  config: require('../../js/config.js')
});

var Utils = require('webrtc-core').utils;

function Authentication(debug, cookieconfig, sipstack) {
  var self = {};

  var signingOut = false;

  self.props = ['userid', 'authenticationUserid', 'password', 'classes', 'visible'];

  self.bindings = {
    'classes': {
      authentication: ['visible', 'register'],
      sipstack: ['callState', 'registered', 'registering']
    },
    'cookieconfig': {
      authentication: ['userid', 'password', 'authenticationUserid']
    }
  }

  self.listeners = function(databinder, sipstackDatabinder, cookieconfigDatabinder) {
    cookieconfigDatabinder.onModelPropChange(['userid', 'password', 'authenticationUserid'], function(value, name) {
      if(value) {
        self[name] = value;
      }
    });
    sipstackDatabinder.onModelPropChange('registered', function(value) {
      if(value) {
        self.hide();
      }
    });
    sipstackDatabinder.onModelPropChange('unregistering', function(value) {
      if(!value && signingOut) {
        debug.log('clear authentication after sign out');
        cookieconfig.userid = undefined;
        cookieconfig.authenticationUserid = undefined;
        cookieconfig.password = undefined;
        signingOut = false;
      }
    });
    sipstackDatabinder.onModelPropChange('registrationStatus', function(status) {
      if (status && ((status === "403" && cookieconfig.userid && !cookieconfig.password) || self.register)) {
        self.show();
      }
      // WRTC-16 : use PAI on 404 to register
      if(!self.register && status === '404' && sipstack.pAssertedIdentity) {
        cookieconfig.userid = undefined;
        cookieconfig.authenticationUserid = undefined;
      }
    });
  };

  self.signOut = function() {
    signingOut = true;
    sipstack.unregister();
  };

  self.signIn = function() {
    if (!self.userid) {
      return;
    }
    self.hide();
    cookieconfig.userid = self.userid;
    cookieconfig.authenticationUserid = self.authenticationUserid;
    cookieconfig.password = self.password;
    sipstack.register();
  };

  return self;
}
},{"../../js/config.js":72,"webrtc-core":253}],76:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(AuthenticationView, {
  template: require('../../js/templates'),
  style: require('../../js/styles')
});

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function AuthenticationView(authentication) {
  var self = {};

  self.model = authentication;

  self.elements = ['signIn', 'signOut', 'userid', 'authenticationUserid', 'password'];

  self.listeners = function() {
    self.password.keypress(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        self.password.trigger('change');
        authentication.signIn();
      }
    });
    self.signIn.bind('click', function(e) {
      e.preventDefault();
      authentication.signIn();
    });
    self.signOut.bind('click', function(e) {
      e.preventDefault();
      authentication.signOut();
    });

    self.view.bind('keypress', function(e) {
      if (e.which === 13) {
        self.signIn.click();
      }
    });
  };

  return self;
}
},{"../../js/styles":73,"../../js/templates":74,"webrtc-core":253}],77:[function(require,module,exports){
module.exports = {view: require('./lib/views/callcontrol'), model: require('./lib/models/callcontrol')};
},{"./lib/models/callcontrol":81,"./lib/views/callcontrol":82}],78:[function(require,module,exports){
module.exports = {
    enableCallControl: true,
    allowOutside: true,
    domainTo: 'broadsoftlabs.com',
    messageOutsideDomain: "Invalid Destination",
    messageEmptyDestination: "Invalid Destination"
};
},{}],79:[function(require,module,exports){
module.exports = {"callcontrol":".bdsft-webrtc .callControl{padding:15px;background:#292929;border:1px solid #3c3c3c;position:absolute;bottom:40px;right:auto;top:auto;left:0;letter-spacing:5px;z-index:100;box-sizing:content-box;padding-left:14px}.bdsft-webrtc .callControl .destination::-webkit-input-placeholder{color:#04aff0;font-style:italic;padding-left:5px;font-weight:400}.bdsft-webrtc .callControl hr{border:0;border-bottom:1px solid #3c3c3c}.bdsft-webrtc .callControl input{box-sizing:border-box;width:171px;line-height:30px;padding-left:8px;padding-right:35px}.bdsft-webrtc .callControl .historyButton{font-size:16px!important;padding-top:5px;padding-bottom:5px;outline:0;position:absolute;right:10px;top:23px;width:25px;padding:0;margin:0;background:0;border:0;border-radius:0;color:#b3b3b3}.bdsft-webrtc .callControl .historyButton.active{color:#04aff0}.bdsft-webrtc .callControl .control-bar{margin-top:6px}.bdsft-webrtc .callControl .control-bar .main-button{background:#3da005;border-radius:14px;width:70px;padding:5px;margin:0 auto}.bdsft-webrtc .callControl .control-bar a{color:#fff;text-decoration:none;text-align:center;width:100%;display:inline-block;font-size:14px;font-weight:700;letter-spacing:1}.bdsft-webrtc .callControl .control-bar a span{margin-right:5px}.bdsft-webrtc .callControl .call{display:none;position:absolute;z-index:10;top:25px;left:265px;display:block;position:static;top:auto;left:auto}.bdsft-webrtc .callControl.audioOnly{top:45px;bottom:auto}.bdsft-webrtc .callControl.enableCallControl.callcontrol-shown{transition:all 1s linear;opacity:1;z-index:100}.bdsft-webrtc .callControl.calling .call,.bdsft-webrtc .callControl:not(.connected) .call,.bdsft-webrtc .callControl.enableCallControl:not(.callcontrol-shown){transition:all 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .callControl.enableCallControl.connected .call{transition:all 1s linear;opacity:1;z-index:20}"}
},{}],80:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // callcontrol.jade compiled template
    templatizer["callcontrol"] = function tmpl_callcontrol() {
        return '<div class="bdsft-webrtc"><div class="callControl destination-container fadeable popup classes"><input type="text" onclick="this.focus();this.select()" class="destination"/><button title="Call History" class="historyButton"><i class="icon-clock"></i></button><hr/><div class="dialpadHolder"></div><div class="control-bar"><div class="call main-button"><a href="">Call</a></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],81:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(CallControl, {
  config: require('../../js/config.js')
});

var fs = require('fs');
var C = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function CallControl(eventbus, debug, urlconfig, sipstack, sound, messages) {
  var self = {};

  self.updateDestination = function(value) {
    var valueFormatted = value && value.replace(/[^a-z0-9()@\.\-\s]+/ig, '');
    if(self.destination !== valueFormatted) {
      debug.log('formatted destination from '+value+' to '+valueFormatted);
      self.destination = valueFormatted;
    }
  };

  self.props = ['destination', 'classes', 'visible'];

  self.bindings = {
    classes: {
        callcontrol: ['visible', 'enableCallControl'],
        sipstack: 'callState',
        urlconfig: 'view'
    },
    enableCallControl: {
      urlconfig: 'enableCallControl'
    },
    destination: {
      callcontrol: 'destination'
    }
  }

  self.listeners = function(databinder, sipstackDatabinder) {
    if (!sipstack.enableConnectLocalMedia && urlconfig.destination) {
      var called = false;
      sipstackDatabinder.onModelPropChange('connected', function(connected){
        if(connected && !called) {
          called = true;
          self.call(urlconfig.destination);
        }
      });
    } else if(urlconfig.destination){
      eventbus.once('userMediaUpdated', function(e) {
        self.call(urlconfig.destination);
      });
    }
    eventbus.on('calling', function(e) {
      self.destination = e.destination.replace('sip:', '').replace('@'+self.domainTo, '');
    });
    eventbus.on('digit', function(e) {
      self.processDigitInput(e.digit, e.isFromDestination);
    });
    eventbus.on('started', function(e) {
      self.hide();
      if(!destinationOnStart) {
        destinationOnStart = self.destination;
      }
    });
    eventbus.on('ended', function(e) {
      resetDestination();
    });
  };

  var destinationOnStart = undefined;
  var resetDestination = function(){
    if(!sipstack.sessions.length) {
      self.destination = destinationOnStart;
      destinationOnStart = undefined;
    }
  };

  var appendDigit = function(digit){
    self.destination = (self.destination || '') + digit;
  };

  self.pressDTMF = function(digit) {
    if (digit.length !== 1) {
      return;
    }
    if (sipstack.isStarted()) {
      appendDigit(digit);
      sound.playClick();
      sipstack.sendDTMF(digit);
    }
  };

  self.processDigitInput = function(digit, isFromDestination) {
    if (!sipstack.isStarted() && self.visible) {
      if(isFromDestination) {
        return;
      }
      appendDigit(digit);
    } else if (digit.match(/^[0-9A-D#*,]+$/i)) {
      self.pressDTMF(digit);
    }
  };

  self.formatDestination = function(destination, domainTo) {
    if (destination.indexOf("@") === -1) {
      destination = (destination + "@" + domainTo);
    }

    var domain = destination.substring(destination.indexOf("@"));
    if (domain.indexOf(".") === -1) {
      destination = destination + "." + domainTo;
    }

    // WEBRTC-35 : filter out dtmf tones from destination
    return destination.replace(/,[0-9A-D#*,]+/, '');
  };

  self.isValidDestination = function(destination, allowOutside, domainTo) {
    if (!allowOutside && !new RegExp("[.||@]" + domainTo).test(destination)) {
      return false;
    }
    return true;
  };


  // Make sure destination allowed and in proper format
  self.validateDestination = function(destination) {
    if (!destination) {
      messages.alert(self.messageEmptyDestination);
      return false;
    }

    if (!self.isValidDestination(destination, self.allowOutside, self.domainTo)) {
      messages.alert(self.messageOutsideDomain);
      return false;
    }

    if (destination.indexOf("sip:") === -1) {
      destination = ("sip:" + destination);
    }

    return self.formatDestination(destination, self.domainTo);
  };

  // URL call
  self.call = function(destinationToValidate) {
    if (sipstack.callState !== C.STATE_CONNECTED) {
      debug.info('Already in call with state : ' + sipstack.callState);
      return;
    }

    var destination = self.validateDestination(destinationToValidate);
    if (!destination) {
      debug.warn("destination is not valid : " + destinationToValidate);
      return;
    }

    debug.log("calling destination : " + destination);

    // Start the Call
    sipstack.call(destination);

    var dtmfTones = Utils.parseDTMFTones(destinationToValidate);
    if(dtmfTones) {
      debug.info("DTMF tones found in destination - sending DTMF tones when started : " + dtmfTones);
      eventbus.once("started", function(e) {
        sound.muteDTMF(true);
        sipstack.sendDTMF(dtmfTones);
      });
      eventbus.once("newDTMF", function(e) {
       var digit = e.data.tone;
        if(digit === '#') {
          sound.muteDTMF(false);
        }
      });
    }
  };


  return self;
}
},{"../../js/config.js":78,"fs":7,"webrtc-core":86}],82:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(CallControlView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function CallControlView(eventbus, callcontrol, sipstack, sound, dialpadView, history) {
  var self = {};

  self.model = callcontrol;
  

  self.elements = ['historyButton', 'destination', 'call', 'dialpadHolder'];

  self.init = function() {
    dialpadView.view.appendTo(self.dialpadHolder);
  };

  self.listeners = function(databinder, historyDatabinder) {
    self.destination.keypress(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        callcontrol.call(self.destination.val());
      }
    });
    self.historyButton.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.toggle();
    });
    self.call.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      var destination = self.destination.val();
      var lastCall = history.lastCall();
      if(!destination && lastCall) {
        self.destination.val(lastCall.destinationWithoutSip());
        self.destination.trigger('change');
      } else {
        callcontrol.call(destination);
      }
    });
    databinder.onModelPropChange('visible', function(visible){
      visible && self.destination.focus();
    });
    historyDatabinder.onModelPropChange('visible', function(visible){
      if (visible) {
        self.historyButton.removeClass("active");
      } else {
        self.historyButton.addClass("active");
      }
    });
    var isTextInputTarget = function(event) {
      var d = event.srcElement || event.target;
      var type = d.type && d.type.toUpperCase();
      var tagName = d.tagName && d.tagName.toUpperCase();
      return (tagName === 'INPUT' && (type === 'TEXT' || type === 'PASSWORD' || type === 'FILE' || type === 'EMAIL')) || tagName === 'TEXTAREA';
    };
    // Prevent the backspace key from navigating back if callcontrol is shown
    Utils.getElement(document).bind('keydown', function(event) {
      if (self.visible) {
        var doPrevent = false;
        if (event.keyCode === 8) {
          if (isTextInputTarget(event)) {
            doPrevent = d.readOnly || d.disabled;
          } else {
            doPrevent = true;
            var value = self.destination.val();
            if(value) {
              self.destination.val( value.slice(0, value.length - 1));
              self.destination.trigger('change');
            }
          }
        }

        if (doPrevent) {
          event.preventDefault();
          return;
        }
      }

      if(self.destination.is(event.target) || !isTextInputTarget(event)) {
        var digit = String.fromCharCode(event.which);
        eventbus.digit(digit, self.destination.is(event.target));
      }

      // TODO - look how to activate without affecting other inputs
      // var len = self.destination.val().length * 2;
      // self.destination[0].setSelectionRange(len, len);
    });
  };

  return self;
}
},{"../../js/styles":79,"../../js/templates":80,"webrtc-core":86}],83:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],84:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],85:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],86:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":85,"./bdsft":87,"./constants":90,"./cookieconfig":91,"./cookieprop":92,"./dateformat":95,"./debug":96,"./element":97,"./eventbus":98,"./factory":99,"./icon":100,"./loader":101,"./popup":102,"./prop":103,"./urlconfig":105,"./utils":106,"./visibleprop":107,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],87:[function(require,module,exports){
module.exports=require(24)
},{"./app":86,"./binding":88,"./classesbinding":89,"./databinder":94,"./stylesmanager":104,"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":131}],88:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":87,"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],89:[function(require,module,exports){
module.exports=require(26)
},{"./binding":88,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],90:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],91:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":87,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":131,"jquery.cookie":130}],92:[function(require,module,exports){
module.exports=require(29)
},{"./constants":90,"./prop":103,"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":131,"jquery.cookie":130}],93:[function(require,module,exports){
module.exports=require(30)
},{"./constants":90,"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":112}],94:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":115}],95:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],96:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":83,"./bdsft":87,"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":108,"stacktrace-js":133}],97:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],98:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":87,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":115}],99:[function(require,module,exports){
module.exports=require(36)
},{"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":131}],100:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],101:[function(require,module,exports){
module.exports=require(38)
},{"../":86,"./constants":90,"./factory":99,"./stylesmanager":104,"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":111}],102:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":131}],103:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":132}],104:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":84,"./constants":90,"./css":93,"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],105:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":83,"./bdsft":87,"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],106:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":85,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":131}],107:[function(require,module,exports){
module.exports=require(44)
},{"./constants":90,"./prop":103,"./utils":106,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],108:[function(require,module,exports){
module.exports=require(45)
},{"./debug":109,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],109:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":110}],110:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],111:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],112:[function(require,module,exports){
module.exports=require(49)
},{"./filters":113,"./utils":114,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],113:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],114:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],115:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":116,"es5-ext/object/valid-callable":125}],116:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":117,"es5-ext/object/is-callable":120,"es5-ext/object/normalize-options":124,"es5-ext/string/#/contains":127}],117:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":118,"./shim":119,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],118:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],119:[function(require,module,exports){
module.exports=require(56)
},{"../keys":121,"../valid-value":126,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],120:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],121:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":122,"./shim":123,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],122:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],123:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],124:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],125:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],126:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],127:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":128,"./shim":129,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],128:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],129:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],130:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":131}],131:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],132:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],133:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],134:[function(require,module,exports){
module.exports = {view: require('./lib/views/chat'), model: require('./lib/models/chat')};
},{"./lib/models/chat":138,"./lib/views/chat":140}],135:[function(require,module,exports){
module.exports = {
    enableChat: false
};
},{}],136:[function(require,module,exports){
module.exports = {"chat":".bdsft-webrtc .chat{position:absolute;display:none;border:1px solid #000}.bdsft-webrtc .chat .input{height:20px;display:block;background:#fff;border:1px solid #d6d6d6;color:#606060;font-size:14px;padding:8px;border-radius:0}.bdsft-webrtc .chat .messagesContent{height:auto}.bdsft-webrtc .chat.enableChat.enableDatachannel.started{display:block}.bdsft-webrtc .chat:not(.started) .input{pointer-events:none;cursor:default;background-color:#999;opacity:.5}","message":".bdsft-webrtc .message{height:auto}.bdsft-webrtc .message .body{font-size:12px}"}
},{}],137:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // chat.jade compiled template
    templatizer["chat"] = function tmpl_chat() {
        return '<div class="bdsft-webrtc"><div class="chat classes bottomleft"><input type="text" class="input"/><div class="messagesContent"></div></div></div>';
    };

    // message.jade compiled template
    templatizer["message"] = function tmpl_message() {
        return '<div class="message"><span class="body"></span></div>';
    };

    return templatizer;
}));
},{"fs":7}],138:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Chat, {
  config: require('../../js/config.js')
});

var Message = require('./message');
var Utils = require('webrtc-core').utils;

function Chat(eventbus, debug, sipstack) {
  var self = {};

  self.props = ['input', 'messages', 'classes', 'visible'];

  self.bindings = {
    classes: {
        self: ['enableChat', 'visible'],
        sipstack: ['callState', 'enableDatachannel']
    }
  }

  var addMessage = function(text) {
    var message = Message.create([text]);
    self.messages.push(message);
  }

  self.send = function(){
    sipstack.sendData("chat:" + self.input);
    addMessage(self.input);
    self.input = '';
  };

  self.init = function() {
    self.messages = [];
  };

  self.listeners = function() {
    eventbus.on('dataReceived', function(e) {
      var data = e.data;
      var regex = /^chat:/;
      if (data.match(regex)) {
        data = data.replace(regex, '');
        addMessage(data);
      }
    });
  };

  return self;
}
},{"../../js/config.js":135,"./message":139,"webrtc-core":145}],139:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Message);

function Message(text) {
	var self = {};

	self.props = ['body', 'time'];

	self.init = function(){
		self.body = text;
		self.time = new Date();
	};

	return self;
}

},{"webrtc-core":145}],140:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(ChatView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

var MessageView = require('./message');

function ChatView(chat) {
  var self = {};

  self.model = chat;
  
  self.updateContactsContent = function(messages){
    self.updateContentView(self.messagesContent, messages, function(message){
      return MessageView.create([message]);
    });
  };

  self.elements = ['messagesContent', 'input'];

  self.bindings = {
    messagesContent: {
      chat: 'messages'
    }
  }

  self.listeners = function(){
  	self.input.keypress(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        chat.send();
      }
    });

  }

  return self;
}
},{"../../js/styles":136,"../../js/templates":137,"./message":141,"webrtc-core":145}],141:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(MessageView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

function MessageView(message) {
  var self = {};

  self.elements = ['body'];

  return self;

}
},{"../../js/styles":136,"../../js/templates":137,"webrtc-core":145}],142:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],143:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],144:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],145:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":144,"./bdsft":146,"./constants":149,"./cookieconfig":150,"./cookieprop":151,"./dateformat":154,"./debug":155,"./element":156,"./eventbus":157,"./factory":158,"./icon":159,"./loader":160,"./popup":161,"./prop":162,"./urlconfig":164,"./utils":165,"./visibleprop":166,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],146:[function(require,module,exports){
module.exports=require(24)
},{"./app":145,"./binding":147,"./classesbinding":148,"./databinder":153,"./stylesmanager":163,"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":190}],147:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":146,"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],148:[function(require,module,exports){
module.exports=require(26)
},{"./binding":147,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],149:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],150:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":146,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":190,"jquery.cookie":189}],151:[function(require,module,exports){
module.exports=require(29)
},{"./constants":149,"./prop":162,"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":190,"jquery.cookie":189}],152:[function(require,module,exports){
module.exports=require(30)
},{"./constants":149,"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":171}],153:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":174}],154:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],155:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":142,"./bdsft":146,"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":167,"stacktrace-js":192}],156:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],157:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":146,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":174}],158:[function(require,module,exports){
module.exports=require(36)
},{"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":190}],159:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],160:[function(require,module,exports){
module.exports=require(38)
},{"../":145,"./constants":149,"./factory":158,"./stylesmanager":163,"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":170}],161:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":190}],162:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":191}],163:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":143,"./constants":149,"./css":152,"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],164:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":142,"./bdsft":146,"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],165:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":144,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":190}],166:[function(require,module,exports){
module.exports=require(44)
},{"./constants":149,"./prop":162,"./utils":165,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],167:[function(require,module,exports){
module.exports=require(45)
},{"./debug":168,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],168:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":169}],169:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],170:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],171:[function(require,module,exports){
module.exports=require(49)
},{"./filters":172,"./utils":173,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],172:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],173:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],174:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":175,"es5-ext/object/valid-callable":184}],175:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":176,"es5-ext/object/is-callable":179,"es5-ext/object/normalize-options":183,"es5-ext/string/#/contains":186}],176:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":177,"./shim":178,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],177:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],178:[function(require,module,exports){
module.exports=require(56)
},{"../keys":180,"../valid-value":185,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],179:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],180:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":181,"./shim":182,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],181:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],182:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],183:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],184:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],185:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],186:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":187,"./shim":188,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],187:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],188:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],189:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":190}],190:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],191:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],192:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],193:[function(require,module,exports){
module.exports = {view: require('./lib/views/connectionstatus'), model: require('./lib/models/connectionstatus')};
},{"./lib/models/connectionstatus":197,"./lib/views/connectionstatus":198}],194:[function(require,module,exports){
module.exports = {
    enableRegistrationStatus: true,
    enableConnectionStatus: true
};
},{}],195:[function(require,module,exports){
module.exports = {"connectionstatus":".bdsft-webrtc .connection-status{position:absolute;top:13px;right:0}.bdsft-webrtc .connection-status .icon{display:inline-block!important}.bdsft-webrtc .connection-status .icon.success{color:#008000}.bdsft-webrtc .connection-status .icon.alert{color:#f00}"}
},{}],196:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // connectionstatus.jade compiled template
    templatizer["connectionstatus"] = function tmpl_connectionstatus() {
        return '<div class="bdsft-webrtc"><div class="connection-status"><div class="icon connectedIcon fadeable"><span title="Websockets Status" class="icon-link exario"></span></div><div class="icon registeredIcon fadeable"><span title="Registered" class="icon-link exario"></span></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],197:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(ConnectionStatus, {
  config: require('../../js/config.js')
})

var Utils = require('webrtc-core').utils;

function ConnectionStatus(options, urlconfig, sipstack) {
  var self = {};

  self.props = ['connected', 'registered'];

  self.bindings = {
    enableRegistrationStatus: {
      urlconfig: 'enableRegistrationStatus'
    },
    enableConnectionStatus: {
      urlconfig: 'enableConnectionStatus'
    }
  };

  self.listeners = function(sipstackDatabinder) {
    sipstackDatabinder.onModelPropChange('connected', function(value){
      if (self.enableConnectionStatus) {
        self.connected = value;
      }
    });
    sipstackDatabinder.onModelPropChange('registered', function(value){
      if (self.enableRegistrationStatus) {
        self.registered = value;
      }
    });
  };

  return self;
}
},{"../../js/config.js":194,"webrtc-core":202}],198:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(ConnectionStatusView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

function ConnectionStatusView(connectionstatus) {
  var self = {};

  self.model = connectionstatus;
  
  self.elements = ['connectedIcon', 'registeredIcon'];

  var isEnabled = function(icon){
    return icon.hasClass('success');
  };

  var enableIcon = function(icon, enable){
    if(enable) {
      show(icon, 'success', 3000);
    } else {
      show(icon, 'alert');
    }
  };

  self.connected = function(value){
    if(arguments.length === 1) {
      enableIcon(self.connectedIcon, value);
    } else {
      return isEnabled(self.connectedIcon);
    }
  };
  self.registered = function(value){
    if(arguments.length === 1) {
      enableIcon(self.registeredIcon, value);
    } else {
      return isEnabled(self.registeredIcon);
    }
  };

  var levels = ['success', 'alert'];
  var show = function(element, level, hideDelay){
    levels.forEach(function(l){
      element.toggleClass(l, l === level);
    });
    element.toggleClass('fadeOut', false);
    element.toggleClass('fadeIn', true);
    if(hideDelay) {
      window.setTimeout(function(){
        hide(element);
      }, hideDelay);
    }
  };

  var hide = function(element){
    element.toggleClass('fadeIn', false);
    element.toggleClass('fadeOut', true);
  };

  return self;
}
},{"../../js/styles":195,"../../js/templates":196,"webrtc-core":202}],199:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],200:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],201:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],202:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":201,"./bdsft":203,"./constants":206,"./cookieconfig":207,"./cookieprop":208,"./dateformat":211,"./debug":212,"./element":213,"./eventbus":214,"./factory":215,"./icon":216,"./loader":217,"./popup":218,"./prop":219,"./urlconfig":221,"./utils":222,"./visibleprop":223,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],203:[function(require,module,exports){
module.exports=require(24)
},{"./app":202,"./binding":204,"./classesbinding":205,"./databinder":210,"./stylesmanager":220,"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":247}],204:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":203,"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],205:[function(require,module,exports){
module.exports=require(26)
},{"./binding":204,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],206:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],207:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":203,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":247,"jquery.cookie":246}],208:[function(require,module,exports){
module.exports=require(29)
},{"./constants":206,"./prop":219,"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":247,"jquery.cookie":246}],209:[function(require,module,exports){
module.exports=require(30)
},{"./constants":206,"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":228}],210:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":231}],211:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],212:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":199,"./bdsft":203,"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":224,"stacktrace-js":249}],213:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],214:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":203,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":231}],215:[function(require,module,exports){
module.exports=require(36)
},{"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":247}],216:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],217:[function(require,module,exports){
module.exports=require(38)
},{"../":202,"./constants":206,"./factory":215,"./stylesmanager":220,"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":227}],218:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":247}],219:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":248}],220:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":200,"./constants":206,"./css":209,"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],221:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":199,"./bdsft":203,"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],222:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":201,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":247}],223:[function(require,module,exports){
module.exports=require(44)
},{"./constants":206,"./prop":219,"./utils":222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],224:[function(require,module,exports){
module.exports=require(45)
},{"./debug":225,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],225:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":226}],226:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],227:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],228:[function(require,module,exports){
module.exports=require(49)
},{"./filters":229,"./utils":230,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],229:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],230:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],231:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":232,"es5-ext/object/valid-callable":241}],232:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":233,"es5-ext/object/is-callable":236,"es5-ext/object/normalize-options":240,"es5-ext/string/#/contains":243}],233:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":234,"./shim":235,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],234:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],235:[function(require,module,exports){
module.exports=require(56)
},{"../keys":237,"../valid-value":242,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],236:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],237:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":238,"./shim":239,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],238:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],239:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],240:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],241:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],242:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],243:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":244,"./shim":245,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],244:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],245:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],246:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":247}],247:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],248:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],249:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],250:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],251:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],252:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],253:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":252,"./bdsft":254,"./constants":257,"./cookieconfig":258,"./cookieprop":259,"./dateformat":262,"./debug":263,"./element":264,"./eventbus":265,"./factory":266,"./icon":267,"./loader":268,"./popup":269,"./prop":270,"./urlconfig":272,"./utils":273,"./visibleprop":274,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],254:[function(require,module,exports){
module.exports=require(24)
},{"./app":253,"./binding":255,"./classesbinding":256,"./databinder":261,"./stylesmanager":271,"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":298}],255:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":254,"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],256:[function(require,module,exports){
module.exports=require(26)
},{"./binding":255,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],257:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],258:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":254,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":298,"jquery.cookie":297}],259:[function(require,module,exports){
module.exports=require(29)
},{"./constants":257,"./prop":270,"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":298,"jquery.cookie":297}],260:[function(require,module,exports){
module.exports=require(30)
},{"./constants":257,"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":279}],261:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":282}],262:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],263:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":250,"./bdsft":254,"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":275,"stacktrace-js":300}],264:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],265:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":254,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":282}],266:[function(require,module,exports){
module.exports=require(36)
},{"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":298}],267:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],268:[function(require,module,exports){
module.exports=require(38)
},{"../":253,"./constants":257,"./factory":266,"./stylesmanager":271,"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":278}],269:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":298}],270:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":299}],271:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":251,"./constants":257,"./css":260,"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],272:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":250,"./bdsft":254,"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],273:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":252,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":298}],274:[function(require,module,exports){
module.exports=require(44)
},{"./constants":257,"./prop":270,"./utils":273,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],275:[function(require,module,exports){
module.exports=require(45)
},{"./debug":276,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],276:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":277}],277:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],278:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],279:[function(require,module,exports){
module.exports=require(49)
},{"./filters":280,"./utils":281,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],280:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],281:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],282:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":283,"es5-ext/object/valid-callable":292}],283:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":284,"es5-ext/object/is-callable":287,"es5-ext/object/normalize-options":291,"es5-ext/string/#/contains":294}],284:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":285,"./shim":286,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],285:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],286:[function(require,module,exports){
module.exports=require(56)
},{"../keys":288,"../valid-value":293,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],287:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],288:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":289,"./shim":290,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],289:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],290:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],291:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],292:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],293:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],294:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":295,"./shim":296,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],295:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],296:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],297:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":298}],298:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],299:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],300:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],301:[function(require,module,exports){
module.exports = {view: require('./lib/views/dialpad')};
},{"./lib/views/dialpad":304}],302:[function(require,module,exports){
module.exports = {"dialpad":".bdsft-webrtc .dialpad button{text-align:center;opacity:.8;font-family:arial;font-size:20px;line-height:33px;cursor:pointer;color:#b3b3b3;background:0;font-weight:normal;padding:0;margin:0;border:0;width:50px}.bdsft-webrtc .dialpad button:active{color:#04aff0;background:-webkit-gradient(linear,left top,left bottom,from(#f47a20),to(#faa51a));background:linear-gradient(to left bottom,#f47a20,#faa51a)}.bdsft-webrtc .dialpad button:hover{box-shadow:1px 1px 20px #999;background:#3a3a3a;box-shadow:none}.bdsft-webrtc .dialpad button:focus{outline:0}.bdsft-webrtc .dialpad button span{display:block;font-size:8px;text-align:center;font-weight:bold;margin-top:-13px;color:#2d7b99}.bdsft-webrtc .dialpad .button-row{text-align:center}.bdsft-webrtc .dialpad .btn-star{font-size:30px;vertical-align:middle}"}
},{}],303:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // dialpad.jade compiled template
    templatizer["dialpad"] = function tmpl_dialpad() {
        return '<div class="bdsft-webrtc"><div class="dialpad"><div class="button-row"><button class="keys">1</button><button class="keys">2</button><button class="keys">3</button></div><div class="button-row"><button class="keys">4</button><button class="keys">5</button><button class="keys">6</button></div><div class="button-row"><button class="keys">7</button><button class="keys">8</button><button class="keys">9</button></div><div class="button-row"><button class="keys btn-star">*</button><button class="keys">0</button><button class="keys">#</button></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],304:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(DialpadView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

function DialpadView(eventbus, sound) {
  var self = {};

  self.elements = ['keys'];

  self.listeners = function() {
    self.keys.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      eventbus.digit(this.firstChild.nodeValue);
    });
  };

  return self;
}
},{"../../js/styles":302,"../../js/templates":303,"webrtc-core":253}],305:[function(require,module,exports){
module.exports = {view: require('./lib/views/fullscreen'), model: require('./lib/models/fullscreen')};
},{"./lib/models/fullscreen":309,"./lib/views/fullscreen":310}],306:[function(require,module,exports){
module.exports = {
	enableFullscreen: true
}

},{}],307:[function(require,module,exports){
module.exports = {"fullscreen":".bdsft-webrtc .enableFullscreen:not(.fullscreen-shown) .fullscreenExpand,.bdsft-webrtc .enableFullscreen.fullscreen-shown .fullscreenContract{transition:all 1s linear;opacity:1;z-index:20}.bdsft-webrtc .enableFullscreen.fullscreen-shown .fullscreenExpand,.bdsft-webrtc .enableFullscreen:not(.fullscreen-shown) .fullscreenContract{transition:all 1s linear;opacity:0;z-index:-1}.bdsft-webrtc :not(.enableFullscreen).cell-fullScreen{display:none!important}.bdsft-webrtc .conference .fullscreenExpand,.bdsft-webrtc .conference .fullscreenContract{text-align:left!important}.bdsft-webrtc .audioOnly .fullscreenExpand,.bdsft-webrtc .audioOnly .fullscreenContract,.bdsft-webrtc .audioOnly .cell-fullScreen{display:none!important}"}
},{}],308:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // fullscreen.jade compiled template
    templatizer["fullscreen"] = function tmpl_fullscreen() {
        return '<div class="bdsft-webrtc"><div class="cell cell-fullScreen classes"><div class="fullscreenExpand icon fadeable"><a href="" title="Expand Full Screen" class="icon-fullscreenExpand"></a></div><div class="fullscreenContract icon fadeable"><a href="" title="Contract Full Screen" class="icon-fullscreenContract"></a></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],309:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Fullscreen, {
  config: require('../../js/config')
})

var Utils = require('webrtc-core').utils;

function Fullscreen(eventbus, urlconfig) {
  var self = {};

  self.updateWebkitFullscreen = function(){
    if(!self.visible) {
      if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      }
    } else {
      if (document.webkitRequestFullScreen) {
        document.webkitRequestFullScreen();
      }      
    }
  };

  self.props = ['visible', 'classes'];

  self.bindings = {
    classes: {
      fullscreen: ['visible', 'enableFullscreen'],
      urlconfig: ['view']
    },
    enableFullscreen: {
      urlconfig: 'enableFullscreen'
    },
    webkitFullscreen: {
      fullscreen: 'visible'
    }
  }

  self.start = function() {
    self.visible = true;
  };
  self.stop = function(){
    self.visible = false;
  };

  self.listeners = function() {
    Utils.getElement(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function(e) {
      var enable = document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen;
      if(enable) {
        self.start();
      } else {
        self.stop();
      }
    });
    eventbus.on('endCall', function(){
      self.stop();
    });
  };

  return self;
}
},{"../../js/config":306,"webrtc-core":253}],310:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(FullscreenView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

function FullscreenView(fullscreen, sound) {
  var self = {};

  self.elements = ['fullscreenExpand', 'fullscreenContract'];

  var clickHander = function(callback){
    return function(e) {
      e.preventDefault();
      sound.playClick();
      callback();
    }
  }

  self.listeners = function() {
    self.fullscreenExpand.bind('click', clickHander(function() {
      fullscreen.start();
    }));
    self.fullscreenContract.bind('click', clickHander(function() {
      fullscreen.stop();
    }));
  };

  return self;
}
},{"../../js/styles":307,"../../js/templates":308,"webrtc-core":253}],311:[function(require,module,exports){
module.exports = {view: require('./lib/views/history'), model: require('./lib/models/history')};

},{"./lib/models/history":316,"./lib/views/history":317}],312:[function(require,module,exports){
module.exports = {
    enableCallHistory: true
};
},{}],313:[function(require,module,exports){
module.exports = {"history":".bdsft-webrtc .callHistory{position:absolute;right:auto;left:200px;bottom:40px;top:auto;background:#292929;background-color:#292929;border-radius:0;border:1px solid #3c3c3c;box-shadow:none;color:#999;z-index:200;padding:10px}.bdsft-webrtc .callHistory .details{display:none}.bdsft-webrtc .callHistory .rowSpace{padding:.5em}.bdsft-webrtc .callHistory .actions,.bdsft-webrtc .callHistory .classHistoryActions{text-align:center;vertical-align:middle;height:40px}.bdsft-webrtc .callHistory .classHistoryActions{min-width:160px}.bdsft-webrtc .callHistory .classHistoryActions .paging{display:inline-block;width:20px;text-align:center}.bdsft-webrtc .callHistory .content{padding:0;margin-bottom:10px}.bdsft-webrtc .callHistory .close a{color:#04aff0;font-size:14px;font-weight:700;text-decoration:none;margin-left:8px}.bdsft-webrtc .callHistory .close a:hover{color:#017ead}.bdsft-webrtc .callHistory .callLink{display:inline-block;background:#6f6f6f;padding:6px 10px 6px 10px;text-decoration:none;font-weight:bold;color:#fff!important;border-radius:50px}.bdsft-webrtc .callHistory .callHistoryDetails{padding:10px;background:#292929;vertical-align:top;font-size:14px!important;box-shadow:2px 0 0 0 #888,0 2px 0 0 #888,2px 2px 0 0 #888,2px 0 0 0 #888 inset,0 2px 0 0 #888 inset}.bdsft-webrtc .callHistory .callHistoryDetails .detailsClose a{text-decoration:none;outline-color:rgba(0,0,0,0);color:#aaa;font-size:18px}.bdsft-webrtc .callHistory .clear a{text-decoration:none;color:#fff;font-size:14px;font-weight:700;background:#6f6f6f;border-radius:20px;padding:5px 10px;margin-left:15px}.bdsft-webrtc .callHistory .clear a:hover{background:#4e4e4e}.bdsft-webrtc .callHistory .statsHolder .stats{position:static;opacity:1;border:0;padding:0}.bdsft-webrtc .callHistory .statsHolder .stats .statsVar{color:#2ba6cb;display:block}.bdsft-webrtc .callHistory .statsHolder .stats span{display:inline!important}.bdsft-webrtc .callHistory .statsHolder .stats .col{width:115px;display:inline-block;white-space:nowrap}.bdsft-webrtc .callHistory.audioOnly{top:45px;bottom:auto}.bdsft-webrtc .callHistory.started .hist-details-arrow,.bdsft-webrtc .callHistory.started .callHistoryDetails{display:none!important}.bdsft-webrtc .callHistory.enableCallHistory.history-shown{transition:all 1s linear;opacity:1;z-index:100}.bdsft-webrtc .callHistory.enableCallHistory:not(.history-shown){transition:all 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .callHistory.enableCallHistory:not(.connected) .callLink{display:none}.bdsft-webrtc .callHistory[class*=\"call-selected\"] .details{display:table-cell}.bdsft-webrtc .callHistory[class*=\"call-selected-0\"] #call_0,.bdsft-webrtc .callHistory[class*=\"call-selected-1\"] #call_1,.bdsft-webrtc .callHistory[class*=\"call-selected-2\"] #call_2,.bdsft-webrtc .callHistory[class*=\"call-selected-3\"] #call_3,.bdsft-webrtc .callHistory[class*=\"call-selected-4\"] #call_4,.bdsft-webrtc .callHistory[class*=\"call-selected-5\"] #call_5,.bdsft-webrtc .callHistory[class*=\"call-selected-6\"] #call_6,.bdsft-webrtc .callHistory[class*=\"call-selected-7\"] #call_7,.bdsft-webrtc .callHistory[class*=\"call-selected-8\"] #call_8,.bdsft-webrtc .callHistory[class*=\"call-selected-9\"] #call_9,.bdsft-webrtc .callHistory[class*=\"call-selected-10\"] #call_10,.bdsft-webrtc .callHistory[class*=\"call-selected-11\"] #call_11,.bdsft-webrtc .callHistory[class*=\"call-selected-12\"] #call_12,.bdsft-webrtc .callHistory[class*=\"call-selected-13\"] #call_13,.bdsft-webrtc .callHistory[class*=\"call-selected-14\"] #call_14,.bdsft-webrtc .callHistory[class*=\"call-selected-15\"] #call_15,.bdsft-webrtc .callHistory[class*=\"call-selected-16\"] #call_16,.bdsft-webrtc .callHistory[class*=\"call-selected-17\"] #call_17,.bdsft-webrtc .callHistory[class*=\"call-selected-18\"] #call_18,.bdsft-webrtc .callHistory[class*=\"call-selected-19\"] #call_19,.bdsft-webrtc .callHistory[class*=\"call-selected-20\"] #call_20,.bdsft-webrtc .callHistory[class*=\"call-selected-21\"] #call_21,.bdsft-webrtc .callHistory[class*=\"call-selected-22\"] #call_22,.bdsft-webrtc .callHistory[class*=\"call-selected-23\"] #call_23,.bdsft-webrtc .callHistory[class*=\"call-selected-24\"] #call_24,.bdsft-webrtc .callHistory[class*=\"call-selected-25\"] #call_25,.bdsft-webrtc .callHistory[class*=\"call-selected-26\"] #call_26,.bdsft-webrtc .callHistory[class*=\"call-selected-27\"] #call_27,.bdsft-webrtc .callHistory[class*=\"call-selected-28\"] #call_28,.bdsft-webrtc .callHistory[class*=\"call-selected-29\"] #call_29,.bdsft-webrtc .callHistory[class*=\"call-selected-30\"] #call_30{box-shadow:2px 0 0 0 #292929,0 2px 0 0 #888,2px 2px 0 0 #888,2px 0 0 0 #888 inset,0 2px 0 0 #888 inset;position:relative}","historyrow":".bdsft-webrtc .history-row:hover,.bdsft-webrtc .history-row.active{background:#353535}.bdsft-webrtc .history-row{cursor:pointer;position:relative;padding:5px}.bdsft-webrtc .history-row span{padding:0 5px}.bdsft-webrtc .history-row .row{height:46px}.bdsft-webrtc .history-row .direction{color:#3da005;font-size:18px}.bdsft-webrtc .history-row .icon-arrow-down-thick{color:#e9651d}.bdsft-webrtc .history-row .destination{color:#b3b3b3;font-size:18px;text-decoration:none}.bdsft-webrtc .history-row .date{color:#b3b3b3;font-size:10px}.bdsft-webrtc .history-row .length{color:#b3b3b3;font-size:10px}.bdsft-webrtc .history-row .details-arrow{font-size:16px}"}
},{}],314:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // history.jade compiled template
    templatizer["history"] = function tmpl_history() {
        return '<div class="bdsft-webrtc"><div class="callHistory popup fadeable classes"><div class="table"><div class="row"><div class="cell"><div class="content"></div></div><div class="cell callHistoryDetails details"><div id="history-dt-close-container"><span class="detailsClose cell"><a href="" title="Close" class="icon-cancel3"></a></span></div><div class="statsHolder"></div></div></div><div class="row"><div class="cell classHistoryActions"><span class="paging"><div class="forward"><a href="" title="Next" class="historyForwardIcon icon-arrow-down-thick"></a></div></span><span class="paging"><div class="back"><a href="" title="Previous" class="historyBackIcon icon-arrow-up-thick"></a></div></span><span class="clear"><a href="" title="Clear History">Clear</a></span><span class="close"><a href="" title="Close History">Close</a></span></div><div class="cell actions details"><a href="" title="Call" class="callLink"></a></div></div></div></div></div>';
    };

    // historyrow.jade compiled template
    templatizer["historyrow"] = function tmpl_historyrow() {
        return '<div class="bdsft-webrtc"><div class="history-row"><div class="row"><span class="direction"></span><a href="" title="Number" class="destination"></a><span class="details-arrow icon-angle-right"></span><div>         <span class="length"></span><span class="date"></span></div></div></div></div>';
    };

    // stats.jade compiled template
    templatizer["stats"] = function tmpl_stats() {
        return '<div class="bdsft-webrtc"><div class="stats classes"><div class="avgVideoGoogFrameWidthReceivedRow"><div class="col">Resolution In</div><div class="col"><span class="statsVar avgVideoGoogFrameWidthReceived"></span> x <span class="statsVar avgVideoGoogFrameHeightReceived"></span></div></div><div class="avgVideoGoogFrameWidthSentRow"><div class="col">Resolution Out</div><div class="col"><span class="statsVar avgVideoGoogFrameWidthSent"></span> x <span class="statsVar avgVideoGoogFrameHeightSent"></span></div></div><div class="avgVideoKiloBitsReceivedPerSecondRow"><div class="col">Video Bitrate In</div><div class="col"><div class="statsVar avgVideoKiloBitsReceivedPerSecond"></div></div></div><div class="avgVideoKiloBitsSentPerSecondRow"><div class="col">Video Bitrate Out</div><div class="col"><div class="statsVar avgVideoKiloBitsSentPerSecond"></div></div></div><div class="avgAudioKiloBitsReceivedPerSecondRow"><div class="col">Audio Bitrate In</div><div class="col"><div class="statsVar avgAudioKiloBitsReceivedPerSecond"></div></div></div><div class="avgAudioKiloBitsSentPerSecondRow"><div class="col">Audio Bitrate Out</div><div class="col"><div class="statsVar avgAudioKiloBitsSentPerSecond"></div></div></div><div class="avgVideoGoogFrameRateReceivedRow"><div class="col">Frame Rate In</div><div class="col"><div class="statsVar avgVideoGoogFrameRateReceived"></div></div></div><div class="avgVideoGoogFrameRateSentRow"><div class="col">Frame Rate Out</div><div class="col"><div class="statsVar avgVideoGoogFrameRateSent"></div></div></div><div class="avgVideoPacketsLostPerRow"><div class="col">Video Lost</div><div class="col"><div class="statsVar avgVideoPacketsLostPer">%</div></div></div><div class="avgAudioPacketsLostPerRow"><div class="col">Audio Lost</div><div class="col"><div class="statsVar avgAudioPacketsLostPer">%</div></div></div><div class="avgAudioGoogJitterReceivedRow"><div class="col">Jitter</div><div class="col"><div class="statsVar avgAudioGoogJitterReceived"></div></div></div><div class="videoGoogFrameWidthReceived hidden"></div><div class="videoGoogFrameHeightReceived hidden"></div><div class="videoGoogFrameWidthSent hidden"></div><div class="videoGoogFrameHeightSent hidden"></div><div class="videoKiloBitsReceivedPerSecond hidden"></div><div class="videoKiloBitsSentPerSecond hidden"></div><div class="audioKiloBitsReceivedPerSecond hidden"></div><div class="audioKiloBitsSentPerSecond hidden"></div><div class="videoGoogFrameRateReceived hidden"></div><div class="videoGoogFrameRateSent hidden"></div><div class="videoPacketsLostPer hidden"></div><div class="audioPacketsLostPer hidden"></div><div class="videoPacketsLost hidden"></div><div class="audioPacketsLost hidden"></div><div class="audioAudioInputLevel hidden"></div><div class="audioAudioOutputLevel hidden"></div><div class="audioGoogRtt hidden"></div><div class="avgVideoPacketsLost hidden"></div><div class="avgAudioPacketsLost hidden"></div><div class="avgAudioAudioInputLevel hidden"></div><div class="avgAudioAudioOutputLevel hidden"></div><div class="avgAudioGoogRtt hidden"></div><div class="audioGoogJitterReceived hidden"></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],315:[function(require,module,exports){
var C = {};
module.exports = C;

C.HISTORY_PAGE_PREFIX = 'bdsft_webrtc_page_';

},{}],316:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(History, {
  config: require('../../js/config.js')
})

var Utils = require('webrtc-core').utils;
var Constants = require('../constants');

function Page(number, callsValue) {
  var self = {};

  self.callsAsString = function() {
    return self.calls.map(function(call) {
      return call.toString();
    }).join("~");
  };
  self.parseCalls = function(callsValue) {
    var calls = [];
    if (callsValue.trim().length > 0) {
      var callsArray = callsValue.split("~");
      for (var i = 0; i < callsArray.length; i++) {
        calls.push(new Call(i, callsArray[i]));
      }
    }
    return calls;
  };

  self.calls = self.parseCalls(callsValue);
  self.number = number;

  return self;
}

function Call(id, value) {
  var self = {};

  var values = value ? value.split("|") : [];
  self.id = id;
  self.startTime = values[0];
  self.destination = values[1];
  self.direction = values[2];
  self.stats = values[3] && JSON.parse(values[3]);
  self.length = values[4];

  self.startDate = function() {
    var date = new Date();
    date.setTime(self.startTime);
    return date.toLocaleString();
  };
  self.destinationWithoutSip = function() {
    return self.destination.replace(/sip:([^@]+)@.+/, "$1");
  };
  self.toString = function() {
    var values = [self.startTime, self.destination, self.direction, JSON.stringify(self.stats), self.length];
    return values.join("|");
  };

  return self;
}

function History(stats, eventbus, sipstack, urlconfig) {
  var self = {};

  self.props = ['isForwardEnabled', 'isBackEnabled', 'calls', 'classes', 'visible', 'pageNumber', 'callsPerPage', 'maxPages', 'callSelected'];

  self.bindings = {
    classes: {
      history: ['visible', 'enableCallHistory', 'callSelected'],
      sipstack: 'callState',
      urlconfig: 'view'
    },
    content: {
      history: ['visible', 'pageNumber']
    },
    enableCallHistory: {
      urlconfig: 'enableCallHistory'
    }
  }

  var createCall = function(rtcSession) {
    var call = new Call(self.calls.length);
    var start = rtcSession.start_time;
    call.startTime = new Date(start).getTime();
    call.destination = rtcSession.remote_identity.uri;
    if (rtcSession.direction === "outgoing") {
      call.direction = "up";
    } else {
      call.direction = "down";
    }
    call.stats = stats.getAllAvg();
    call.length = Utils.format(Math.round(Math.abs((rtcSession.end_time - start) / 1000)));
    return call;
  };

  var updateNavigation = function() {
    var pages = self.pages();
    var pagesCount = pages ? pages.length - 1 : 0;
    self.isForwardEnabled = self.pageNumber < pagesCount;
    self.isBackEnabled = self.pageNumber > 0;
  };

  self.updateContent = function() {
    updateNavigation();
    var allCalls = self.getAllCalls();
    var startPos = self.callsPerPage * self.pageNumber;
    var endPos = Math.min(startPos + self.callsPerPage, allCalls.length);
    self.calls = allCalls.slice(startPos, endPos);
  };

  self.pagesAsString = function() {
    return self.pages().map(function(page) {
      return page.callsAsString();
    });
  };

  self.pages = function() {
    var pages = [];
    for (var i = 0; i < localStorage.length; i++) {
      var key = localStorage.key(i);
      var regex = new RegExp(Constants.HISTORY_PAGE_PREFIX + '(.*)', 'g');
      var match = regex.exec(key);
      if (match !== null && match.length > 1) {
        var value = localStorage.getItem(key);
        var page = new Page(parseInt(match[1], 10), value);
        pages.push(page);
      }
    }
    // sort pages descendingly
    pages.sort(function(page1, page2) {
      return page2.number - page1.number;
    });
    return pages;
  };

  self.deselectCall = function() {
    self.callSelected = undefined;
  };

  self.selectCall = function(index) {
    self.callSelected = 'call-selected-'+index;
  };

  self.lastCall = function() {
    return self.getAllCalls().pop();
  };

  self.getAllCalls = function() {
    var pages = self.pages();
    var calls = [];
    for (var i = 0; i < pages.length; i++) {
      calls = calls.concat(pages[i].calls);
    }
    return calls;
  };

  self.forward = function() {
    self.deselectCall();
    self.pageNumber = self.pageNumber + 1;
  };

  self.back = function() {
    self.deselectCall();
    self.pageNumber = self.pageNumber - 1;
  };

  self.clear = function() {
    var pages = self.pages();
    for (var i = 0; i < pages.length; i++) {
      localStorage.removeItem(Constants.HISTORY_PAGE_PREFIX + (pages[i].number));
    }
    self.pageNumber = 0;
    self.updateContent();
  };

  self.init = function() {
    self.pageNumber = 0;
    self.callsPerPage = 4;
    self.maxPages = 10;
  };

  self.listeners = function() {
    eventbus.on("ended", function(e) {
      self.persistCall(e.sender);
    });
  };

  self.setStats = function(call) {
    stats.setAllAvg(call.stats);
  };

  self.persistPage = function(page) {
    var key = (Constants.HISTORY_PAGE_PREFIX + page.number);
    var value = page.callsAsString();
    localStorage[key] = value;
  };

  self.persistCall = function(rtcSession) {
    if (!self.enableCallHistory) {
      return;
    }
    // Get latest cookie
    var pages = self.pages();
    var page = null;
    if (pages.length > 0) {
      page = pages[0];
    } else {
      page = new Page(0, "");
    }

    if (page.calls.length >= self.callsPerPage) {
      if (page.number + 1 >= self.maxPages) {
        // remove oldest call and reorder calls to each page
        for (var i = 0; i < pages.length; i++) {
          var lastPageCall = pages[i].calls.pop();
          if (i + 1 < pages.length) {
            pages[i + 1].calls.unshift(lastPageCall);
          }
          self.persistPage(pages[i]);
        }
      } else {
        page = new Page(page.number + 1, "");
      }
    }

    // cookie vars
    var call = createCall(rtcSession);
    page.calls.unshift(call);
    self.persistPage(page);
    self.updateContent();
  };

  return self;

}
},{"../../js/config.js":312,"../constants":315,"webrtc-core":322}],317:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(HistoryView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

var Utils = require('webrtc-core').utils;
var HistoryRow = require('./historyrow');
// var Factory = require('webrtc-core').factory;
var Constants = require('webrtc-core').constants;

function HistoryView(sound, history, statsView, callcontrol) {
  var self = {};

  self.model = history;

  self.rows = [];

  var updateContent = function(calls) {
    self.content.html("");
    self.rows = [];
    calls.forEach(function(call, i){
      var row = HistoryRow.create([call, history, self, i]);
      self.rows.push(row);
      row.view.appendTo(self.content);
    });
  };

  self.elements = ['content', 'forward', 'back', 'detailsClose', 'clear', 'callLink', 'close', 'statsHolder'];

  self.init = function() {
    statsView.view.appendTo(self.statsHolder);
  };

  self.listeners = function(databinder) {
    databinder.onModelPropChange('isForwardEnabled', function(value){
      self.forward.toggle(value);
    });
    databinder.onModelPropChange('isBackEnabled', function(value){
      self.back.toggle(value);
    });
    databinder.onModelPropChange('calls', function(calls){
      updateContent(calls);
    });
    self.forward.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.forward();
    });

    self.back.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.back();
    });

    self.close.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.hide();
    });

    self.detailsClose.bind('click', function(e) {
      e.preventDefault();
      history.deselectCall();
    });

    self.callLink.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      var destination = self.callLink.attr("data-destination");
      callcontrol.call(destination);
      history.hide();
      history.deselectCall();
    });

    self.clear.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.clear();
    });
  };

  return self;

}
},{"../../js/styles":313,"../../js/templates":314,"./historyrow":318,"webrtc-core":322}],318:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(HistoryRowView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function HistoryRowView(call, history, historyView, index) {
  var self = {};

  self.elements = ['destination', 'direction', 'date', 'length'];

  self.init = function() {
    self.view.attr('id', 'call_'+index);
    self.destination.text(call.destinationWithoutSip())
    self.direction.append("<i class='icon-arrow-" + call.direction + "-thick'></i>");
    self.date.text(Utils.formatDateTime(call.startDate()));
    self.length.text(call.length);
  };

  self.listeners = function(databinder) {
    self.view.on('click', function(e){
      e.preventDefault();
      history.setStats(call);
      historyView.callLink.attr("data-destination", call.destinationWithoutSip());
      historyView.callLink.text("Call " + call.destinationWithoutSip());
      history.selectCall(index);
    });
  };

  return self;

}
},{"../../js/styles":313,"../../js/templates":314,"webrtc-core":322}],319:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],320:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],321:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],322:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":321,"./bdsft":323,"./constants":326,"./cookieconfig":327,"./cookieprop":328,"./dateformat":331,"./debug":332,"./element":333,"./eventbus":334,"./factory":335,"./icon":336,"./loader":337,"./popup":338,"./prop":339,"./urlconfig":341,"./utils":342,"./visibleprop":343,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],323:[function(require,module,exports){
module.exports=require(24)
},{"./app":322,"./binding":324,"./classesbinding":325,"./databinder":330,"./stylesmanager":340,"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":367}],324:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":323,"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],325:[function(require,module,exports){
module.exports=require(26)
},{"./binding":324,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],326:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],327:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":323,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":367,"jquery.cookie":366}],328:[function(require,module,exports){
module.exports=require(29)
},{"./constants":326,"./prop":339,"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":367,"jquery.cookie":366}],329:[function(require,module,exports){
module.exports=require(30)
},{"./constants":326,"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":348}],330:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":351}],331:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],332:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":319,"./bdsft":323,"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":344,"stacktrace-js":369}],333:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],334:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":323,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":351}],335:[function(require,module,exports){
module.exports=require(36)
},{"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":367}],336:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],337:[function(require,module,exports){
module.exports=require(38)
},{"../":322,"./constants":326,"./factory":335,"./stylesmanager":340,"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":347}],338:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":367}],339:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":368}],340:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":320,"./constants":326,"./css":329,"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],341:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":319,"./bdsft":323,"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],342:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":321,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":367}],343:[function(require,module,exports){
module.exports=require(44)
},{"./constants":326,"./prop":339,"./utils":342,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],344:[function(require,module,exports){
module.exports=require(45)
},{"./debug":345,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],345:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":346}],346:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],347:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],348:[function(require,module,exports){
module.exports=require(49)
},{"./filters":349,"./utils":350,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],349:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],350:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],351:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":352,"es5-ext/object/valid-callable":361}],352:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":353,"es5-ext/object/is-callable":356,"es5-ext/object/normalize-options":360,"es5-ext/string/#/contains":363}],353:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":354,"./shim":355,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],354:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],355:[function(require,module,exports){
module.exports=require(56)
},{"../keys":357,"../valid-value":362,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],356:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],357:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":358,"./shim":359,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],358:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],359:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],360:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],361:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],362:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],363:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":364,"./shim":365,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],364:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],365:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],366:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":367}],367:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],368:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],369:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],370:[function(require,module,exports){
module.exports = {view: require('./lib/views/incomingcall'), model: require('./lib/models/incomingcall')};
},{"./lib/models/incomingcall":373,"./lib/views/incomingcall":374}],371:[function(require,module,exports){
module.exports = {"incomingcall":".bdsft-webrtc .callPopup{padding:0;background:#292929;border:1px solid #3c3c3c;box-shadow:none;border-radius:0;min-width:170px}.bdsft-webrtc .callPopup button{margin:10px;display:none}.bdsft-webrtc .callPopup span{color:#999;font-size:22px}.bdsft-webrtc .callPopup .col{display:inline-block;vertical-align:top}.bdsft-webrtc .callPopup .displayName,.bdsft-webrtc .callPopup .user{display:block;margin-left:10px;margin-bottom:18px}.bdsft-webrtc .callPopup .incomingCallTitle{display:block;padding:8px;font-size:18px;font-weight:bold;background:#3c3c3c;margin-bottom:18px;color:#e4e4e4}.bdsft-webrtc .callPopup .reject{background:#f00}.bdsft-webrtc .callPopup #rejectContainer{text-align:right}.bdsft-webrtc .callPopup.started .holdAndAccept,.bdsft-webrtc .callPopup.started .dropAndAccept,.bdsft-webrtc .callPopup:not(.started) .accept,.bdsft-webrtc .callPopup .reject{display:block}.bdsft-webrtc .callPopup.incomingcall-shown{transition:all 1s linear;opacity:1;z-index:100}.bdsft-webrtc .callPopup:not(.incomingcall-shown),.bdsft-webrtc .callPopup.failed{transition:all 1s linear;opacity:0;z-index:-1;transition:none}"}
},{}],372:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // incomingcall.jade compiled template
    templatizer["incomingcall"] = function tmpl_incomingcall() {
        return '<div class="bdsft-webrtc"><div class="callPopup fadeable popup classes centered"><span class="incomingCallTitle">Incoming Call</span><span class="displayName"></span><span class="user"></span><div><div class="col"><button type="button" class="accept button">Accept</button><button type="button" class="holdAndAccept button">Hold And Answer</button><button type="button" class="dropAndAccept button">Drop And Answer</button></div><div id="rejectContainer" class="col"><button type="button" class="reject button">Reject</button></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],373:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(IncomingCall)

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function IncomingCall(eventbus, sound, sipstack) {
  var self = {};

  self.props = ['displayName', 'user', 'classes', 'visible'];

  self.bindings = {
    'classes': {
        incomingcall: 'visible',
        sipstack: ['callState', 'failed']
    }
  }

  var incomingSession;

  var handle = function(){
    self.hide();
    sound.pause();
  };

  self.accept = function() {
    handle();
    sipstack.answer(incomingSession)
  };

  self.dropAndAccept = function() {
    handle();
    sipstack.terminateSession();
    sipstack.answer(incomingSession);
  };

  self.holdAndAccept = function() {
    handle();
    sipstack.holdAndAccept(incomingSession);
  };

  self.reject = function() {
    handle();
    sipstack.terminateSession(incomingSession);
  };

  self.listeners = function() {
    eventbus.on("incomingCall", function(evt) {
      incomingSession = evt.data.session
      var from = evt.data && evt.data.request && evt.data.request.from || {};
      self.displayName = from.display_name || '';
      self.user = from.uri && from.uri.user || '';
      self.show();
      sound.playRingtone();
    });
  };

  return self;
}
},{"webrtc-core":253}],374:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(IncomingCallView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function IncomingCallView(incomingcall) {
  var self = {};

  self.model = incomingcall;
  
  self.elements = ['displayName', 'user', 'accept', 'reject', 'holdAndAccept', 'dropAndAccept'];

  self.listeners = function() {
    self.accept.on('click', function(e) {
      e.preventDefault();
      incomingcall.accept();
    });
    self.reject.on('click', function(e) {
      e.preventDefault();
      incomingcall.reject();
    });
    self.holdAndAccept.on('click', function(e) {
      e.preventDefault();
      incomingcall.holdAndAccept();
    });
    self.dropAndAccept.on('click', function(e) {
      e.preventDefault();
      incomingcall.dropAndAccept();
    });
  };

  return self;
}
},{"../../js/styles":371,"../../js/templates":372,"webrtc-core":253}],375:[function(require,module,exports){
module.exports = {view: require('./lib/views/messages'), model: require('./lib/models/messages')};
},{"./lib/models/messages":380,"./lib/views/messages":381}],376:[function(require,module,exports){
module.exports = {
	enableMessages: true,
    messageIncomingCall: "Incoming Call",
    messageProgress: "Ringing",
    messageStarted: "Call Started",
    messageHold: "Call placed on hold",
    messageResume: "Call removed from hold",
    messageEnded: "Call Ended",
    messageCall: "Performing NAT Tests",
    messageFailed: "Call Failed : {0}",
    messageConnected: "Connected",
    messageConnectionFailed: "Connection failed",
    messageUnregistered: "Unregistered",
    messageRegistered: "Registration successful",
    messageRegistrationNotFound: "Registration : Not Found",
    messageRegistrationWrongPassword: "Registration : Wrong Password",
    messageGetUserMedia: "Unable to Access Camera and/or Microphone",
    messageRegistering: "Registering...",
    messageUnregistering: "Unregistering...",
    messageConnecting: "Connecting to WRS..."
};
},{}],377:[function(require,module,exports){
module.exports = {"messages":".bdsft-webrtc .messages{position:absolute;font-family:arial;text-align:left;width:auto;font-size:12px;bottom:auto;top:10px;left:10px}.bdsft-webrtc .messages.audioOnly{left:10px!important;top:48px!important;font-weight:bold;font-size:14px}.bdsft-webrtc .messages .msg{display:none}.bdsft-webrtc .messages:not(.connecting).registering.enableMessages .messageRegistering,.bdsft-webrtc .messages:not(.connecting).unregistering.enableMessages .messageUnregistering,.bdsft-webrtc .messages.connecting.enableMessages .messageConnecting,.bdsft-webrtc .messages.failed.enableMessages .messageFailed,.bdsft-webrtc .messages:not(.registering)._403.enableMessages .messageRegistrationWrongPassword,.bdsft-webrtc .messages:not(.registering)._404.enableMessages .messageRegistrationNotFound,.bdsft-webrtc .messages.userMediaFailed.enableMessages .messageGetUserMedia{display:block}.bdsft-webrtc .messages.hasMessageAlert.enableMessages .messageAlert,.bdsft-webrtc .messages.hasMessageNormal.enableMessages .messageNormal,.bdsft-webrtc .messages.hasMessageWarning.enableMessages .messageWarning,.bdsft-webrtc .messages.hasMessageSuccess.enableMessages .messageSuccess,.bdsft-webrtc .messages:not(.registered):not(.connecting):not(.registering):not(.unregistering):not(._403):not(._404).enableMessages .messageUnregistered,.bdsft-webrtc .messages:not(.connecting):not(.registering).registered.enableMessages .messageRegistered,.bdsft-webrtc .messages:not(.connecting):not(.connected).enableMessages .messageConnectionFailed,.bdsft-webrtc .messages:not(.connecting).connected.enableMessages .messageConnected{opacity:0;height:0;display:block;animation:flickerAnimation 3s;-webkit-animation:flickerAnimation 3s;-moz-animation:flickerAnimation 3s;-o-animation:flickerAnimation 3s}.bdsft-webrtc .messages .normal{color:<%= infoMessageColor %>}.bdsft-webrtc .messages .success{color:<%= successMessageColor %>}.bdsft-webrtc .messages .warning{color:<%= warningMessageColor %>}.bdsft-webrtc .messages .alert{color:<%= alertMessageColor %>}"}
},{}],378:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // messages.jade compiled template
    templatizer["messages"] = function tmpl_messages() {
        return '<div class="bdsft-webrtc"><div class="messages classes"><div class="messageGetUserMedia alert msg"></div><div class="messageConnectionFailed alert msg"></div><div class="messageRegistrationNotFound alert msg"></div><div class="messageRegistrationWrongPassword alert msg"></div><div class="messageFailed alert msg"></div><div class="messageAlert alert msg"></div><div class="messageWarning warning msg"></div><div class="messageSuccess success msg"></div><div class="messageConnected success msg"></div><div class="messageRegistered success msg"></div><div class="messageUnregistered success msg"></div><div class="messageNormal normal msg"></div><div class="messageConnecting normal msg"></div><div class="messageRegistering normal msg"></div><div class="messageUnregistering normal msg"></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],379:[function(require,module,exports){
var C = {
  STYLES: {
    infoMessageColor: '#999999',
    successMessageColor: '#00FF00',
    warningMessageColor: '#FFFF00',
    alertMessageColor: '#FF0000'
  }
};

module.exports = C;
},{}],380:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Messages, {
  config: require('../../js/config.js')
})

var utils = require('webrtc-core').utils;

function Messages(eventbus, urlconfig, sipstack) {
  var self = {};

  self.props = ['messageAlert', 'messageWarning', 'messageSuccess', 'messageNormal', 'hasMessageAlert', 'hasMessageWarning', 'hasMessageSuccess', 'hasMessageNormal', 'classes'];

  self.updateMessageFailed = function(cause){
    self.messageFailed = require('../../js/config.js').messageFailed.replace('{0}', cause);
  };

  self.updateHasMessage = function(value, name){
    self[utils.camelize('has '+name)] = !!value;
  };

  self.bindings = {
    classes: {
        sipstack: ['registering', 'unregistering', 'connected', 'connecting', 'registered', 'registrationStatus', 'failed', 'userMediaFailed'],
        urlconfig: 'view',
        messages: ['hasMessageAlert', 'hasMessageWarning', 'hasMessageSuccess', 'hasMessageNormal', 'enableMessages']
    },
    enableMessages: {
      urlconfig: 'enableMessages'
    },
    messageFailed: {
      sipstack: 'failedCause'
    },
    hasMessage: {
      messages: ['messageAlert', 'messageWarning', 'messageSuccess', 'messageNormal']
    }
  }

  var showMessage = function(level, text){
    self['message'+level] = ((self['message'+level] || '') +  ' ' + text).trim();
  }
  self.alert = function(text){
    showMessage('Alert', text);
  };
  self.normal = function(text){
    showMessage('Normal', text);
  };
  self.success = function(text){
    showMessage('Success', text);
  };
  self.warning = function(text){
    showMessage('Warning', text);
  };

  self.getRemoteUser = function(rtcSession) {
    return rtcSession && rtcSession.remote_identity && rtcSession.remote_identity.uri && (rtcSession.remote_identity.uri.user || rtcSession.remote_identity.uri.host);
  };

  self.showErrorPopup = function(error) {
    window.alert(error);
  };

  self.listeners = function(databinder, sipstackDatabinder) {
    sipstackDatabinder.onModelPropChange("failedCause", function(cause) {
      if (cause === "User Denied Media Access") {
        self.showErrorPopup("WebRTC was not able to access your microphone/camera!");
      }
    });
    eventbus.on("ended", function(e) {
      self.normal(self.messageEnded.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("resumed", function(e) {
      self.success(self.messageResume.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("started", function(e) {
      if (e.data && !e.data.isReconnect) {
        self.success(self.messageStarted.replace('{0}', self.getRemoteUser(e.sender)));
      }
    });
    eventbus.on("held", function(e) {
      self.success(self.messageHold.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("progress", function(e) {
      self.normal(self.messageProgress.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("calling", function(e) {
      self.normal(self.messageCall.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("incomingCall", function(e) {
      self.success(self.messageIncomingCall.replace('{0}', self.getRemoteUser(e.sender)));
    });

  };

  return self;
}
},{"../../js/config.js":376,"webrtc-core":385}],381:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(MessagesView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  constants: require('../constants')
})

var utils = require('webrtc-core').utils;

function MessagesView(messages) {
  var self = {};

  self.model = messages;
  
  self.elements = ['messageAlert', 'messageSuccess', 'messageWarning', 'messageNormal', 'messageRegistering', 'messageRegistered', 'messageUnregistered', 
  'messageConnectionFailed', 'messageConnected', 'messageConnecting', 'messageUnregistering', 'messageRegistrationNotFound', 
  'messageRegistrationWrongPassword', 'messageFailed', 'messageGetUserMedia'];

  self.listeners = function(){
  	var onAnimationEnd = function(e){
  		$(e.target).text('');
  		$(e.target).trigger('change');
  	};
  	self.messageAlert.on('webkitAnimationEnd', onAnimationEnd);
  	self.messageSuccess.on('webkitAnimationEnd', onAnimationEnd);
  	self.messageWarning.on('webkitAnimationEnd', onAnimationEnd);
  	self.messageNormal.on('webkitAnimationEnd', onAnimationEnd);
  };
  return self;
}
},{"../../js/styles":377,"../../js/templates":378,"../constants":379,"webrtc-core":385}],382:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],383:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],384:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],385:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":384,"./bdsft":386,"./constants":389,"./cookieconfig":390,"./cookieprop":391,"./dateformat":394,"./debug":395,"./element":396,"./eventbus":397,"./factory":398,"./icon":399,"./loader":400,"./popup":401,"./prop":402,"./urlconfig":404,"./utils":405,"./visibleprop":406,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],386:[function(require,module,exports){
module.exports=require(24)
},{"./app":385,"./binding":387,"./classesbinding":388,"./databinder":393,"./stylesmanager":403,"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":430}],387:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":386,"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],388:[function(require,module,exports){
module.exports=require(26)
},{"./binding":387,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],389:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],390:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":386,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":430,"jquery.cookie":429}],391:[function(require,module,exports){
module.exports=require(29)
},{"./constants":389,"./prop":402,"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":430,"jquery.cookie":429}],392:[function(require,module,exports){
module.exports=require(30)
},{"./constants":389,"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":411}],393:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":414}],394:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],395:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":382,"./bdsft":386,"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":407,"stacktrace-js":432}],396:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],397:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":386,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":414}],398:[function(require,module,exports){
module.exports=require(36)
},{"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":430}],399:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],400:[function(require,module,exports){
module.exports=require(38)
},{"../":385,"./constants":389,"./factory":398,"./stylesmanager":403,"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":410}],401:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":430}],402:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":431}],403:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":383,"./constants":389,"./css":392,"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],404:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":382,"./bdsft":386,"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],405:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":384,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":430}],406:[function(require,module,exports){
module.exports=require(44)
},{"./constants":389,"./prop":402,"./utils":405,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],407:[function(require,module,exports){
module.exports=require(45)
},{"./debug":408,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],408:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":409}],409:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],410:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],411:[function(require,module,exports){
module.exports=require(49)
},{"./filters":412,"./utils":413,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],412:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],413:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],414:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":415,"es5-ext/object/valid-callable":424}],415:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":416,"es5-ext/object/is-callable":419,"es5-ext/object/normalize-options":423,"es5-ext/string/#/contains":426}],416:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":417,"./shim":418,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],417:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],418:[function(require,module,exports){
module.exports=require(56)
},{"../keys":420,"../valid-value":425,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],419:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],420:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":421,"./shim":422,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],421:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],422:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],423:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],424:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],425:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],426:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":427,"./shim":428,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],427:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],428:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],429:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":430}],430:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],431:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],432:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],433:[function(require,module,exports){
module.exports = {view: require('./lib/views/settings'), model: require('./lib/models/settings')};
},{"./lib/models/settings":438,"./lib/views/settings":439}],434:[function(require,module,exports){
module.exports = {
    enableSettings: false
};
},{}],435:[function(require,module,exports){
module.exports = {"settings":".bdsft-webrtc .settingsPopup{padding:2px;position:absolute;line-height:28px;border:1px solid #3c3c3c;background:#292929;border-radius:0;box-shadow:none;bottom:40px;right:0;top:auto;left:auto;width:280px!important;font-size:14px;height:250px;overflow:hidden}.bdsft-webrtc .settingsPopup span{color:#999;font-size:20px;font-size:14px;line-height:28px;width:110px}.bdsft-webrtc .settingsPopup [type=\"checkbox\"]{width:18;height:18;vertical-align:middle}.bdsft-webrtc .settingsPopup .short{width:36px}.bdsft-webrtc .settingsPopup input{background:#333;border:1px solid #414141;color:#eee;padding:1px 1px 1px 5px;line-height:22px;font-size:13px;margin-left:14px;border-radius:0;width:auto}.bdsft-webrtc .settingsPopup select{margin-left:14px}.bdsft-webrtc .settingsPopup input,.bdsft-webrtc .settingsPopup select{width:140px}.bdsft-webrtc .settingsPopup .tabs span{margin-right:5px;color:#fff}.bdsft-webrtc .settingsPopup .btn{display:none;background:#04aff0;color:#fff;padding:5px 10px;text-decoration:none;border-radius:20px;margin-left:9px;margin-top:15px;font-weight:700;text-align:center}.bdsft-webrtc .settingsPopup .btn:hover{background:#017ead}.bdsft-webrtc .settingsPopup .resolutionSubType{display:none}.bdsft-webrtc .settingsPopup .tabs{width:250px;padding-left:0}.bdsft-webrtc .settingsPopup .tabs li{list-style:none;display:inline}.bdsft-webrtc .settingsPopup .tabs a{padding:5px 10px;display:inline-block;color:#fff;text-decoration:none}.bdsft-webrtc .settingsPopup .tabs a.active{color:#fff}.bdsft-webrtc .settingsPopup .tabs ~div p,.bdsft-webrtc .settingsPopup .tabs ~div h3{margin-bottom:15px;color:#999;font-size:14px}.bdsft-webrtc .settingsPopup .tabs ~ div{padding:10px;margin-bottom:10px}.bdsft-webrtc .settingsPopup.audioOnly{bottom:auto}.bdsft-webrtc .settingsPopup.standard .displayResolutionStandard,.bdsft-webrtc .settingsPopup.standard .encodingResolutionStandard,.bdsft-webrtc .settingsPopup.widescreen .displayResolutionWidescreen,.bdsft-webrtc .settingsPopup.widescreen .encodingResolutionWidescreen{display:inline-block}.bdsft-webrtc .settingsPopup #tab2{display:none}.bdsft-webrtc .settingsPopup.hd .resolutionRow{display:none}.bdsft-webrtc .settingsPopup .authentication-hidden{transition:all 1s linear;opacity:1;z-index:20}.bdsft-webrtc .settingsPopup.enableSettings.settings-shown{transition:all 1s linear;opacity:1;z-index:100}.bdsft-webrtc .settingsPopup.enableSettings:not(.settings-shown){transition:all 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .settingsPopup .tabs a.active{background:<%= settingsTabActiveColor %>}.bdsft-webrtc .settingsPopup .tabs a{background:<%= settingsTabInactiveColor %>}"}
},{}],436:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // authentication.jade compiled template
    templatizer["authentication"] = function tmpl_authentication() {
        return '<div class="bdsft-webrtc"><div class="authenticationView fadeable classes"><div class="useridRow row"><span class="cell">User ID</span><input type="text" value="" class="userid cell"/></div><div class="authenticationUseridRow row"><span class="cell">Auth User ID</span><input type="text" value="" class="authenticationUserid authUserid cell"/></div><div class="passwordRow row"><span class="cell">Password</span><input type="password" value="" class="password cell"/></div><div class="row"><div class="alert"></div></div><div class="row"><span class="cell"><a href="" title="Sign In" class="btn signIn">Sign In</a><a href="" title="Sign Out" class="btn signOut">Sign Out</a></span></div></div></div>';
    };

    // settings.jade compiled template
    templatizer["settings"] = function tmpl_settings() {
        return '<div class="bdsft-webrtc"><div class="settingsPopup table collapse fixed fadeable popup classes"><div class="row"><ul class="tabs"><li><a href="#tab1" class="configure"><span class="icon-cog"></span>Configure</a></li><li><a href="#tab2" class="layout"><span class="icon-th"></span>Layout</a></li></ul><div id="tab1"><div class="enableAutoAnswerRow row"><span class="cell">Auto Answer</span><input type="checkbox" class="enableAutoAnswer cell"/></div><div class="bandwidthRow row"><span class="cell">Bandwidth</span><span class="cell"><input type="text" maxlength="4" value="" placeholder="low" class="bandwidthLow short"/><input type="text" maxlength="4" value="" placeholder="medium" class="bandwidthMed short"/><input type="text" maxlength="4" value="" placeholder="high" class="bandwidthHigh short"/></span></div><div class="displayNameRow row"><span class="cell">Display Name</span><input type="text" value="" class="displayName cell"/></div><div class="authenticationRow"></div></div><div id="tab2"><div class="enableSelfViewRow row"><span class="cell">Enable Self View</span><input type="checkbox" class="enableSelfView cell"/></div><div class="hdRow row"><span class="cell">Use HD</span><input type="checkbox" class="hd cell"/></div><div class="resolutionRow"><div class="row"><span class="resolutionTypeRow cell">Mode</span><select class="resolutionType cell"><option value="standard">standard</option><option value="widescreen">widescreen</option></select></div><div class="row"><span class="displayResolutionRow cell">Resolution</span><span class="cell"><select class="displayResolutionStandard resolutionSubType"></select><select class="displayResolutionWidescreen resolutionSubType"></select></span></div><div class="row"><span class="encodingResolutionRow cell">Encoding</span><span class="cell"><select class="encodingResolutionStandard resolutionSubType"></select><select class="encodingResolutionWidescreen resolutionSubType"></select></span></div></div></div></div></div></div>';
    };

    // settingscontrol.jade compiled template
    templatizer["settingscontrol"] = function tmpl_settingscontrol() {
        return '<div class="bdsft-webrtc"><div class="cell cell-settings"><div class="settings icon fadeable"><a href="" title="Settings" class="icon-settings"></a></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],437:[function(require,module,exports){
function reverse(array){
  var copy = Array.prototype.slice.call(array);  //local copy of the colors array
  copy.reverse();
  return copy;
}

var Constants = require('webrtc-core').constants;
var C = {};
module.exports = C;

C.STYLES = {
	settingsTabActiveColor: '#04aff0',
	settingsTabInactiveColor: '#494949'
};
C.STANDARD_RESOLUTIONS = {
  '960 x 720': Constants.R_960x720,
  '640 x 480': Constants.R_640x480,
  '320 x 240': Constants.R_320x240
};
C.standard = [Constants.R_960x720,Constants.R_640x480,Constants.R_320x240];
C.standardreverse = reverse(C.standard);

C.WIDESCREEN_RESOLUTIONS  = {
  // '1920 x 1080': Constants.R_1920x1080,
  '1280 x 720': Constants.R_1280x720,
  '640 x 360': Constants.R_640x360,
  '320 x 180': Constants.R_320x180
};
C.widescreen = [Constants.R_1280x720,Constants.R_640x360,Constants.R_320x180];
C.widescreenreverse = reverse(C.widescreen);

},{"webrtc-core":443}],438:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Settings, {
  config: require('../../js/config.js')
});

var Constants = require('../constants');
var coreConstants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function Settings(debug, cookieconfig, urlconfig, sipstack, authentication, video) {
  var self = {};

  var getResolution = function(resolution, resolutionType){
    var standards = Constants.standardreverse;
    var widescreens = Constants.widescreenreverse;

    var index = 1;

    if(standards.indexOf(resolution) !== -1) {
      index = standards.indexOf(resolution);
    } else if(widescreens.indexOf(resolution) !== -1){
      index = widescreens.indexOf(resolution);
    } else if(resolution) {
      debug.error(resolution+' not found in standards or widescreen');
      return;
    }

    if(resolutionType === 'standard') {
      return index >= standards.length ? standards[standards.length-1] : standards[index];
    } else {
      return widescreens[index];
    }
  };

  self.updateResolutions = function(resolutionType){
    if(resolutionType) {
      self.displayResolution = getResolution(self.displayResolution, resolutionType);
      self.encodingResolution = getResolution(self.encodingResolution, resolutionType);
    }
  };

  self.updateResolutionType = function(value){
    if(!value) {
      self.resolutionType = undefined;
    } else if (Utils.containsKey(Constants.STANDARD_RESOLUTIONS, value)) {
      self.resolutionType = coreConstants.STANDARD;
    } else if (Utils.containsKey(Constants.WIDESCREEN_RESOLUTIONS, value)) {
      self.resolutionType = coreConstants.WIDESCREEN;
    } else {
      throw Error('no resolution type for ' + value);
    }
  };

  self.updateDisplayResolutionStandard = function(value){
    if(Utils.containsKey(Constants.STANDARD_RESOLUTIONS, value)) {
      self.displayResolutionStandard = value;
    }
  };
  self.updateDisplayResolutionWidescreen = function(value){
    if(Utils.containsKey(Constants.WIDESCREEN_RESOLUTIONS, value)) {
      self.displayResolutionWidescreen = value;
    }
  };
  self.updateEncodingResolutionStandard = function(value){
    if(Utils.containsKey(Constants.STANDARD_RESOLUTIONS, value)) {
      self.encodingResolutionStandard = value;
    }
  };
  self.updateEncodingResolutionWidescreen = function(value){
    if(Utils.containsKey(Constants.WIDESCREEN_RESOLUTIONS, value)) {
      self.encodingResolutionWidescreen = value;
    }
  };

  self.props = ['classes', 'visible', 'displayName', 'displayResolutionStandard', 'displayResolutionWidescreen',
    'encodingResolutionStandard', 'encodingResolutionWidescreen', 'resolutionType', 'displayResolution', 'encodingResolution', 'enableSelfView',
    'hd', 'bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'enableAutoAnswer'];

  self.bindings = {
    classes: {
      settings: ['visible', 'enableSettings', 'hd', 'resolutionType'],
      sipstack: 'registered',
      urlconfig: 'view'
    },
    enableSettings: {
      urlconfig: 'enableSettings'
    },
    displayName: {
      cookieconfig: 'displayName',
      urlconfig: 'displayName'
    },
    resolutions: {
      settings: 'resolutionType'
    },
    resolutionType: {
      settings: ['displayResolution', 'displayResolutionStandard', 'displayResolutionWidescreen', 
      'encodingResolution', 'encodingResolutionStandard', 'encodingResolutionWidescreen']
    },
    displayResolution: {
      settings: ['displayResolutionStandard', 'displayResolutionWidescreen']
    },
    displayResolutionStandard: {
      settings: 'displayResolution'
    },
    displayResolutionWidescreen: {
      settings: 'displayResolution'
    },
    encodingResolution: {
      settings: ['encodingResolutionStandard', 'encodingResolutionWidescreen']
    },
    encodingResolutionStandard: {
      settings: 'encodingResolution'
    },
    encodingResolutionWidescreen: {
      settings: 'encodingResolution'
    }
  }

  self.listeners = function(databinder, cookieconfigDatabinder, videoDatabinder, sipstackDatabinder) {
    sipstackDatabinder.onModelPropChange(['bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'enableAutoAnswer', 'encodingResolution'], function(value, name) {
      self[name] = value;
    });
    videoDatabinder.onModelPropChange(['displayResolution', 'enableSelfView'], function(value, name) {
      self[name] = value;
    });
    cookieconfigDatabinder.onModelPropChange(['bandwidthLow', 'bandwidthMed', 'bandwidthHigh',
      'displayResolution', 'encodingResolution', 'displayName', 'enableSelfView', 'hd', 'size', 'enableAutoAnswer'
    ], function(value, name) {
      self[name] = value;
    });
    databinder.onViewElChangeListener(['bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'displayResolution', 'encodingResolution', 
      'displayName', 'enableSelfView', 'hd', 'enableAutoAnswer'
    ], function(value, name) {
      cookieconfig[name] = value;
    });
    databinder.onModelPropChangeListener(['bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'displayResolution', 'encodingResolution', 
      'displayName', 'enableSelfView', 'hd', 'enableAutoAnswer'
    ], function(value, name) {
      cookieconfig[name] = value;
    });
  };

  return self;
}
},{"../../js/config.js":434,"../constants":437,"webrtc-core":443}],439:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(SettingsView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  constants: require('../constants')
});

var WebRTC_C = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;
var Constants = require('../constants');

function SettingsView(options, debug, sound, settings, authenticationView) {
  var self = {};

  self.model = settings;

  var updateRowVisibility = function() {
    self.enableAutoAnswerRow.toggleClass('hidden', options.hasOwnProperty("enableAutoAnswer"));
    self.enableSelfViewRow.toggleClass('hidden', options.hasOwnProperty("enableSelfView"));
    self.hdRow.toggleClass('hidden', options.hasOwnProperty("hd"));
    self.resolutionRow.toggleClass('hidden', options.hasOwnProperty("displayResolution") && options.hasOwnProperty("encodingResolution"));
    self.displayResolutionRow.toggleClass('hidden', options.hasOwnProperty("displayResolution"));
    self.encodingResolutionRow.toggleClass('hidden', options.hasOwnProperty("encodingResolution"));
    self.resolutionTypeRow.toggleClass('hidden', options.hasOwnProperty("displayResolution") || options.hasOwnProperty("encodingResolution"));
    // hide bandwidth rows because it's too technical to offer in view
    self.bandwidthLow.toggleClass('hidden', options.hasOwnProperty("bandwidthLow"));
    self.bandwidthMed.toggleClass('hidden', options.hasOwnProperty("bandwidthMed"));
    self.bandwidthHigh.toggleClass('hidden', options.hasOwnProperty("bandwidthHigh"));
    self.bandwidthRow.toggleClass('hidden', true);
    self.displayNameRow.toggleClass('hidden', options.hasOwnProperty("displayName"));
  };

  self.elements = ['displayName', 'resolutionType', 'displayResolutionWidescreen', 'displayResolutionStandard', 'encodingResolutionWidescreen',
    'encodingResolutionStandard', 'bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'displayNameRow', 'enableSelfViewRow',
    'hdRow', 'enableAutoAnswerRow', 'resolutionTypeRow', 'displayResolutionRow', 'encodingResolutionRow', 'resolutionRow', 'bandwidthRow',
    'enableSelfView', 'hd', 'enableAutoAnswer', 'tabs', 'authenticationRow'
  ];

  self.init = function(options) {
    Utils.addSelectOptions(Constants.STANDARD_RESOLUTIONS, self.displayResolutionStandard, settings.displayResolutionStandard);
    Utils.addSelectOptions(Constants.STANDARD_RESOLUTIONS, self.encodingResolutionStandard, settings.encodingResolutionStandard);
    Utils.addSelectOptions(Constants.WIDESCREEN_RESOLUTIONS, self.displayResolutionWidescreen, settings.displayResolutionWidescreen);
    Utils.addSelectOptions(Constants.WIDESCREEN_RESOLUTIONS, self.encodingResolutionWidescreen, settings.encodingResolutionWidescreen);
    authenticationView.view.appendTo(self.authenticationRow);
    updateRowVisibility();
  };

  self.listeners = function() {
    self.tabs.each(function() {
      var active, activeTabSel, links = Utils.getElement(this).find('a');
      active = Utils.getElement(links.filter('[href="' + location.hash + '"]')[0] || links[0]);
      active.addClass('active');
      activeTabSel = active[0].hash;
      links.not(active).each(function() {
        Utils.getElement(this.hash).hide();
      });
      Utils.getElement(this).on('click', 'a', function(e) {
        e.preventDefault();
        active.removeClass('active');
        Utils.getElement(activeTabSel).hide();
        active = Utils.getElement(this);
        activeTabSel = this.hash;
        active.addClass('active');
        Utils.getElement(activeTabSel).show();
      });
    });
  };

  return self;
}
},{"../../js/styles":435,"../../js/templates":436,"../constants":437,"webrtc-core":443}],440:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],441:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],442:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],443:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":442,"./bdsft":444,"./constants":447,"./cookieconfig":448,"./cookieprop":449,"./dateformat":452,"./debug":453,"./element":454,"./eventbus":455,"./factory":456,"./icon":457,"./loader":458,"./popup":459,"./prop":460,"./urlconfig":462,"./utils":463,"./visibleprop":464,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],444:[function(require,module,exports){
module.exports=require(24)
},{"./app":443,"./binding":445,"./classesbinding":446,"./databinder":451,"./stylesmanager":461,"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":488}],445:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":444,"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],446:[function(require,module,exports){
module.exports=require(26)
},{"./binding":445,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],447:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],448:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":444,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":488,"jquery.cookie":487}],449:[function(require,module,exports){
module.exports=require(29)
},{"./constants":447,"./prop":460,"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":488,"jquery.cookie":487}],450:[function(require,module,exports){
module.exports=require(30)
},{"./constants":447,"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":469}],451:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":472}],452:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],453:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":440,"./bdsft":444,"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":465,"stacktrace-js":490}],454:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],455:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":444,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":472}],456:[function(require,module,exports){
module.exports=require(36)
},{"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":488}],457:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],458:[function(require,module,exports){
module.exports=require(38)
},{"../":443,"./constants":447,"./factory":456,"./stylesmanager":461,"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":468}],459:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":488}],460:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":489}],461:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":441,"./constants":447,"./css":450,"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],462:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":440,"./bdsft":444,"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],463:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":442,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":488}],464:[function(require,module,exports){
module.exports=require(44)
},{"./constants":447,"./prop":460,"./utils":463,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],465:[function(require,module,exports){
module.exports=require(45)
},{"./debug":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],466:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":467}],467:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],468:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],469:[function(require,module,exports){
module.exports=require(49)
},{"./filters":470,"./utils":471,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],470:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],471:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],472:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":473,"es5-ext/object/valid-callable":482}],473:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":474,"es5-ext/object/is-callable":477,"es5-ext/object/normalize-options":481,"es5-ext/string/#/contains":484}],474:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":475,"./shim":476,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],475:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],476:[function(require,module,exports){
module.exports=require(56)
},{"../keys":478,"../valid-value":483,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],477:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],478:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":479,"./shim":480,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],479:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],480:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],481:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],482:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],483:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],484:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":485,"./shim":486,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],485:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],486:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],487:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":488}],488:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],489:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],490:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],491:[function(require,module,exports){
module.exports = {model: require('./lib/models/sipstack'), exsip: require('exsip')};
},{"./lib/models/sipstack":493,"exsip":505}],492:[function(require,module,exports){
module.exports = {
	enabled: true,
    enableConnectLocalMedia: true,
    enableIms: false,
    enableAutoAnswer: false,
    enableDatachannel: false,
    endCallURL: false,
	encodingResolution: '640x480',
    websocketsServers: [{'ws_uri':'wss://webrtc-gw.broadsoftlabs.com:8443', 'weight':0}],
    stunServer: 'stun.broadsoftlabs.com',
	stunPort: 3478,
	domainFrom: 'broadsoftlabs.com',
    bandwidthLow: 128,
    bandwidthMed: 512,
    bandwidthHigh: 2048,
    pAssertedIdentity: '<sip:webguest@broadsoftlabs.com>',
    disableICE: true,
    audioOnly: false,
    offerToReceiveVideo: true,
    networkUserId: false,
    debug: false,
    dtmfDuration: 500,
    dtmfInterToneGap: 100
}

},{}],493:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(SIPStack, {
  config: require('../../js/config')
});

var ExSIP = require('exsip');
var Constants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function SIPStack(eventbus, debug, urlconfig, cookieconfig) {
  var self = {};

  self.ua = null;
  self.activeSession = null;
  self.sessions = [];

  self.updateUaConfig = function(){
    self.ua && self.ua.loadConfig(self.getExSIPConfig());
  };

  self.updateRtcMediaHandlerOptions = function() {
    self.ua && self.ua.setRtcMediaHandlerOptions(self.getRtcMediaHandlerOptions());
  };

  self.updateMediaConstraints = function() {
    self.mediaConstraints = {
        audio: true,
        video: getVideoConstraints()
      };
  };

  self.updateUserMedia = function(value, name, userMediaCallback, failureCallback) {
    if (!self.ua) {
      return;
    }

    self.userMediaFailed = false;
    if (self.enabled && (self.enableConnectLocalMedia || self.activeSession)) {
      // Connect to local stream
      var options = self.getExSIPOptions();
      self.ua.getUserMedia(options, function(localStream) {
        eventbus.userMediaUpdated(localStream);
        if (self.activeSession) {
          debug.log("changing active session ...");
          self.activeSession.changeSession({
            localMedia: localStream,
            createOfferConstraints: options.createOfferConstraints
          }, function() {
            debug.log('change session succeeded');
          }, function() {
            debug.log('change session failed');
          });
        }

        if (userMediaCallback) {
          userMediaCallback(localStream);
        }
      }, function(e) {
        self.userMediaFailed = true;
        if (failureCallback) {
          failureCallback(e);
        }
      }, true);
    }
  };

  self.updateBandwidth = function(value, name){
    value = parseInt(value, 10);
    self[name] = value;
  };

  self.bindings = {
    mediaConstraints: {
      sipstack: ['audioOnly', 'encodingResolution', 'hd']
    },
    uaConfig: {
      sipstack: ['networkUserId', 'enableIms', 'domainFrom', 'debug', 'enableDatachannel', 'pAssertedIdentity', 'mediaConstraints'],
      cookieconfig: ['userid', 'authenticationUserid', 'password', 'displayName']
    },
    rtcMediaHandlerOptions: {
      sipstack: ['bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'encodingResolution']
    },
    userMedia: {
      sipstack: ['audioOnly', 'encodingResolution', 'enableConnectLocalMedia', 'offerToReceiveVideo']
    },
    bandwidth: {
      cookieconfig: ['bandwidthLow', 'bandwidthMed', 'bandwidthHigh']
    },
    hd: {
      cookieconfig: 'hd',
      urlconfig: 'hd'
    },
    encodingResolution: {
      cookieconfig: 'encodingResolution'
    },
    enableAutoAnswer: {
      cookieconfig: 'enableAutoAnswer',
      urlconfig: 'enableAutoAnswer'
    },
    networkUserId: {
      urlconfig: 'networkUserId'
    },
    enableIms: {
      urlconfig: 'enableIms'
    },
    enableConnectLocalMedia: {
      urlconfig: 'enableConnectLocalMedia'
    },
    audioOnly: {
      urlconfig: ['audioOnly', 'audioOnlyView']
    }
  };

  self.props = ['callState', 'registered', 'hd', 'connected', 'registrationStatus', 'connecting', 'registering', 'unregistering', 'failed', 'failedCause',
  'userMediaFailed', 'mediaConstraints'];

  var checkEndCallURL = function() {
    if (self.endCallURL && self.enabled) {
      window.location = self.endCallURL;
    }
  };

  var getBandwidth = function() {
    var height = self.encodingResolutionHeight();
    if (height <= 240) {
      return self.bandwidthLow;
    } else if (height <= 480) {
      return self.bandwidthMed;
    } else if (height <= 1080) {
      return self.bandwidthHigh;
    } else {
      debug.log('getBandwidth : no encoding height matches : ', height);
    }
  };

  var getResolutionConstraints = function() {
    var width = self.encodingResolutionWidth();
    var height = self.encodingResolutionHeight();
    if (width && height) {
      if (height <= 480) {
        return {
          mandatory: {
            maxWidth: width,
            maxHeight: height
          }
        };
      } else {
        return {
          mandatory: {
            minWidth: width,
            minHeight: height
          }
        };
      }
    } else {
      return false;
    }
  };

  var getVideoConstraints = function() {
    if (self.audioOnly) {
      return false;
    } else {
      var constraints = getResolutionConstraints();
      return constraints ? constraints : true;
    }
  };

  var setActiveSession = function(session) {
    debug.log("setting active session to " + session.id);
    self.activeSession = session;
  };

  var updateCallState = function() {
    if (self.sessions.length > 0) {
      if (self.sessions.length === 1 && !self.sessions[0].isStarted()) {
        self.callState = Constants.STATE_CALLING;
      } else {
        if (self.activeSession && self.activeSession.isHeld()) {
          self.callState = [Constants.STATE_STARTED, Constants.STATE_HELD];
        } else {
          self.callState = Constants.STATE_STARTED;
        }
      }
    } else {
      if (self.ua && self.ua.isConnected && self.ua.isConnected()) {
        self.callState = Constants.STATE_CONNECTED;
      } else {
        self.callState = Constants.STATE_DISCONNECTED;
      }
    }
  };

  self.endCall = function(options) {
    options = options || {};
    var rtcSession = options.rtcSession;
    if (rtcSession === 'all') {
      self.terminateSessions();
    } else if (rtcSession) {
      self.terminateSession(rtcSession);
    } else {
      self.terminateSession();
    }
    // stop localMedia to turn off light
    if(!self.enableConnectLocalMedia && self.ua && self.ua.localMedia) {
      self.ua.localMedia.stop();
    }
  };
  self.getLocalStreams = function() {
    return self.activeSession ? self.activeSession.getLocalStreams() : null;
  };
  self.getRemoteStreams = function() {
    return self.activeSession ? self.activeSession.getRemoteStreams() : null;
  };
  self.getSessionId = function() {
    return self.activeSession.id.replace(/\./g, '');
  };
  self.terminateSession = function(session) {
    session = session || self.activeSession;
    if (!session) {
      return;
    }
    var index = self.sessions.indexOf(session);
    if (index !== -1) {
      self.sessions.splice(index, index + 1);
    }
    if (session.status !== ExSIP.RTCSession.C.STATUS_TERMINATED) {
      session.terminate();
    }
    if (session === self.activeSession) {
      debug.log("clearing active session");
      self.activeSession = null;
    }
    updateCallState();
  };
  self.terminateSessions = function() {
    var allSessions = [];
    allSessions = allSessions.concat(self.sessions);
    for (var i = 0; i < allSessions.length; i++) {
      self.terminateSession(allSessions[i]);
    }
  };
  self.holdAndAccept = function(session) {
    var firstSession = self.activeSession;
    session.on('ended', function() {
      // eventbus.emit('message', {
      //   text: 'Resuming with ' + firstSession.remote_identity.uri.user,
      //   level: 'normal'
      // });
      debug.info("incoming call ended - unholding first call");
      firstSession.unhold(function() {
        debug.info("unhold first call successful");
      });
    });
    self.activeSession.hold(function() {
      debug.info("hold successful - answering incoming call");
      self.answer(session);
    });
  };
  self.answer = function(session) {
    session.answer(self.getExSIPOptions());
  };
  self.hold = function(successCallback, failureCallback) {
    if (self.activeSession) {
      self.activeSession.hold(function() {
        successCallback && successCallback();
      }, function(e) {
        failureCallback && failureCallback();
      });
    }
  };
  self.unhold = function(successCallback, failureCallback) {
    if (self.activeSession) {
      self.activeSession.unhold(function() {
        successCallback && successCallback();
      }, function(e) {
        failureCallback && failureCallback();
      });
    }
  };
  self.reconnectUserMedia = function(successCallback, failureCallback) {
    var onUserMediaUpdateSuccess = function(localMedia) {
      debug.log("reconnect user media successful");
      if (self.activeSession) {
        self.activeSession.changeSession({
          localMedia: localMedia
        }, function() {
          debug.log("session changed successfully");
          if (successCallback) {
            successCallback(localMedia);
          }
        }, failureCallback);
      } else if (successCallback) {
        successCallback(localMedia);
      }
    };
    self.updateUserMedia(null, null, onUserMediaUpdateSuccess, failureCallback);
  };
  self.call = function(destination) {
    var session = self.ua.call(destination, self.getExSIPOptions());
    eventbus.calling(destination, session);
  };
  self.sendDTMF = function(digit) {
    self.activeSession.sendDTMF(digit, self.getDTMFOptions());
  };
  self.isStarted = function() {
    return self.getCallState() === Constants.STATE_STARTED;
  };
  self.unregister = function() {
    self.unregistering = true;
    self.ua && self.ua.unregister();
    // eventbus.once('unregistered', function() {
    //   updateUA();
    // });
  };
  self.register = function() {
    self.registering = true;
    self.ua && self.ua.register();
    // updateUA(data);
  };
  self.sendData = function(data) {
    if (self.activeSession) {
      self.activeSession.sendData(data);
    }
  };
  self.transfer = function(transferTarget, isAttended) {
    if (isAttended) {
      self.ua.attendedTransfer(transferTarget, self.activeSession);
    } else {
      self.ua.transfer(transferTarget, self.activeSession);
    }
  };
  self.getCallState = function() {
    return self.callState;
  }

  // Incoming reinvite function
  self.incomingReInvite = function(e) {
    debug.log("auto accepting reInvite");
    e.data.session.acceptReInvite();
  };

  self.getExSIPOptions = function() {
    // Options Passed to ExSIP
    var options = {
      mediaConstraints: self.mediaConstraints,
      createOfferConstraints: {
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: self.offerToReceiveVideo
        }
      }
    };
    return options;
  };

  self.setAudioOnlyOfferAndRec = function(audioOnly) { 
    self.audioOnly = audioOnly;
    offerToReceiveVideo = !audioOnly;
    self.updateUserMedia();
  };

  self.setAudioOnly = function(audioOnly) { 
    self.audioOnly = audioOnly;
    offerToReceiveVideo = true;
    self.updateUserMedia();
  };

  self.encodingResolutionWidth = function() {
    return Utils.resolutionWidth(self.hd && Constants.R_1280x720 || self.encodingResolution);
  };

  self.encodingResolutionHeight = function() {
    return Utils.resolutionHeight(self.hd && Constants.R_1280x720 || self.encodingResolution);
  };

  self.getExSIPConfig = function(data) {
    data = data || {};
    var userid = data.userId || cookieconfig.userid || self.networkUserId || Utils.randomUserid();

    var sip_uri = encodeURI(userid);
    if ((sip_uri.indexOf("@") === -1)) {
      sip_uri = (sip_uri + "@" + self.domainFrom);
    }

    var config = {
      'uri': sip_uri,
      'authorization_user': data.authenticationUserId || cookieconfig.authenticationUserid || userid,
      'password': data.password || cookieconfig.password,
      'ws_servers': self.websocketsServers,
      'stun_servers': 'stun:' + self.stunServer + ':' + self.stunPort,
      'trace_sip': self.debug,
      'enable_ims': self.enableIms,
      'enable_datachannel': self.enableDatachannel
    };

    // Add Display Name if set
    if (cookieconfig.displayName) {
      config.display_name = cookieconfig.displayName;
    }

    // do registration if User ID or register is set
    var register = data.authenticationUserId || cookieconfig.authenticationUserid || data.userId || cookieconfig.userid;
    if (register) {
      config.register = true;
    } else {
       // only set PAI if user is not registered
      config.p_asserted_identity = self.pAssertedIdentity;
      config.register = false;
    }
    return config;
  };

  self.getRtcMediaHandlerOptions = function() {
    var options = {
      reuseLocalMedia: self.enableConnectLocalMedia,
      videoBandwidth: getBandwidth(),
      disableICE: self.disableICE,
      RTCConstraints: {
        'optional': [],
        'mandatory': {}
      }
    };
    return options;
  };

  self.getDTMFOptions = function() {
    return {
      duration: self.dtmfDuration,
      interToneGap: self.dtmfInterToneGap
    };
  };

  self.createUA = function(config) {
    return new ExSIP.UA(config);
  };

  self.listeners = function(databinder) {
    databinder.onModelPropChange(['websocketsServers'], function(){
      self.ua && updateUA();
    });
    window.onbeforeunload = function(e) {
      self.endCall({
        rtcSession: 'all'
      });
      return null;
    };
    eventbus.on(["disconnected", "endCall", "ended"], function(e) {
      checkEndCallURL();
    });
    eventbus.on(["ended", "endCall"], function(e) {
      self.endCall({
        rtcSession: e.sender
      });
    });
    eventbus.on("resumed", function(e) {
      setActiveSession(e.sender);
    });
    eventbus.on("started", function(e) {
      setActiveSession(e.sender);
    });
  };

  self.init = function() {
    if(urlconfig.audioOnlyView) {
      self.offerToReceiveVideo = false;
    }

    updateUA();
  };

  var updateUA = function() {
    try {
      if (self.callState && (self.callState !== Constants.STATE_CONNECTED && self.callState !== Constants.STATE_DISCONNECTED)) {
        debug.warn('not able to restart UA - call state is ' + self.callState);
        return;
      }

      if (self.ua) {
        debug.log('stopping existing UA');
        self.ua.stop();
      }

      if (!self.enabled) {
        debug.warn('sipstack disabled');
        return;
      }
      self.connecting = true;
      var config = self.getExSIPConfig();
      self.registering = config.register;
      self.ua = self.createUA(config);

      self.updateRtcMediaHandlerOptions();

      // Start SIP Stack
      self.ua.start();

      // sipStack callbacks
      self.ua.on('connected', function(e) {
        self.connecting = false;
        updateCallState();
        self.connected = true;
        self.updateUserMedia();
      });
      self.ua.on('disconnected', function(e) {
        self.connecting = false;
        updateCallState();
        self.connected = false;
        self.endCall({
          rtcSession: 'all'
        });
      });
      self.ua.on('onReInvite', function(e) {
        debug.log("incoming onReInvite event");
        self.incomingReInvite(e);
      });
      self.ua.on('newRTCSession', function(e) {
        self.failed = undefined;
        self.failedCause = undefined;

        var session = e.data.session;
        self.sessions.push(session);
        updateCallState();

        // call event handlers
        session.on('progress', function(e) {
          eventbus.progress(e);
        });
        session.on('failed', function(e) {
          var data = e.data;
          data.sender = e.sender;
          self.failed = true;
          self.failedCause = data.cause;
          self.endCall({
            rtcSession: e.sender
          });
          eventbus.failed(e);
        });
        session.on('started', function(e) {
          updateCallState();
          eventbus.started(e);
        });
        session.on('resumed', function(e) {
          updateCallState();
          eventbus.resumed(e);
        });
        session.on('held', function(e) {
          updateCallState();
          eventbus.held(e);
        });
        session.on('ended', function(e) {
          updateCallState();
          eventbus.ended(e);
        });
        session.on('newDTMF', function(e) {
          eventbus.newDTMF(e);
        });
        session.on('dataSent', function(e) {
          eventbus.dataSent(e);
        });
        session.on('dataReceived', function(e) {
          eventbus.dataReceived(e);
        });
        session.on('iceconnected', function(e) {
          eventbus.iceconnected(e.sender, e.data);
        });
        session.on('icecompleted', function(e) {
          eventbus.icecompleted(e.sender, e.data);
        });
        session.on('iceclosed', function(e) {
          eventbus.iceclosed(e.sender, e.data);
        });

        // handle incoming call
        if (e.data.session.direction === "incoming") {
          if (!self.activeSession && self.enableAutoAnswer) {
            session.answer(self.getExSIPOptions());
            return;
          } else {
            eventbus.incomingCall(e);
          }
        }

        if (!self.activeSession) {
          setActiveSession(session);
        }
      });

      self.ua.on('registered', function() {
        self.registering = false;
        self.registered = true;
        self.registrationStatus = undefined;
      });
      self.ua.on('unregistered', function() {
        self.unregistering = false;
        self.registered = false;
        self.registrationStatus = undefined;
      });
      self.ua.on('registrationFailed', function(e) {
        self.unregistering = false;
        self.registering = false;
        self.registered = false;
        self.registrationStatus = e.data && e.data.response && e.data.response.status_code+"";
      });
    } catch (e) {
      console.error(e.stack);
      debug.error('could not init sip stack');
    }
  };

  return self;
}
},{"../../js/config":492,"exsip":505,"webrtc-core":531}],494:[function(require,module,exports){
var grammar = module.exports = {
  v: [{
      name: 'version',
      reg: /^(\d*)$/
  }],
  o: [{ //o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  //k: [{}], // outdated thing ignored
  t: [{ //t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: "%d %d"
  }],
  c: [{ //c=IN IP4 10.47.197.26
      name: 'connection',
      reg: /^IN IP(\d) (\S*)/,
      names: ['version', 'ip'],
      format: "IN IP%d %s"
  }],
  b: [{ //b=AS:4000
      push: 'bandwidth',
      reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
      names: ['type', 'limit'],
      format: "%s:%s"
  }],
  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
      // NB: special - pushes to session
      // TODO: rtp/fmtp should be filtered by the payloads found here?
      reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
      names: ['type', 'port', 'protocol', 'payloads'],
      format: "%s %d %s %s"
  }],
  a: [
    { //a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-]*)\/(\d*)(?:\s*\/(\S*))?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding) ?
          "rtpmap:%d %s/%s/%s":
          "rtpmap:%d %s/%s";
      }
    },
    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      push: 'fmtp',
      reg: /^fmtp:(\d*) (\S*)/,
      names: ['payload', 'config'],
      format: "fmtp:%d %s"
    },
    { //a=control:streamid=0
        name: 'control',
        reg: /^control:(.*)/,
        format: "control:%s"
    },
    { //a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null) ?
          "rtcp:%d %s IP%d %s":
          "rtcp:%d";
      }
    },
    { //a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: "rtcp-fb:%d trr-int %d"
    },
    { //a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null) ?
          "rtcp-fb:%s %s %s":
          "rtcp-fb:%s %s";
      }
    },
    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      //a=extmap:1/recvonly URI-gps-string
      push: 'ext',
      reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
      names: ['value', 'uri', 'config'], // value may include "/direction" suffix
      format: function (o) {
        return (o.config != null) ?
          "extmap:%s %s %s":
          "extmap:%s %s"
      }
    },
    {
      //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null) ?
          "crypto:%d %s %s %s":
          "crypto:%d %s %s";
      }
    },
    { //a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    { //a=mid:1
      name: 'mid',
      reg: /^mid:(\w*)/,
      format: "mid:%s"
    },
    { //a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*)/,
      format: "ptime:%d"
    },
    { //a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*)/,
      format: "maxptime:%d"
    },
    { //a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/,
      format: "%s"
    },
    { //a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: "fingerprint:%s %s"
    },
    {
      //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0
      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: generation (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'generation'],
      format: function (o) {
        var str = "candidate:%s %d %s %d %s %d typ %s";
        // NB: candidate has two optional chunks, so %void middle one if it's missing
        str += (o.raddr != null) ? " raddr %s rport %d" : "%v%v";
        if (o.generation != null) {
          str += " generation %d";
        }
        return str;
      }
    },
    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    { //a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
      names: ['id', 'attribute', 'value'],
      format: "ssrc:%d %s:%s"
    },
    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic: (\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: "msid-semantic: %s %s" // space after ":" is not accidental
    },
    { //a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: "group:%s %s"
    },
    { //a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    { // any a= that we don't understand is kepts verbatim on media.invalid
      push: 'invalid',
      names: ["value"]
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = "%s";
    }
  });
}); 

},{}],495:[function(require,module,exports){
var parser = require('./parser');
var writer = require('./writer');

exports.write = writer;
exports.parse = parser.parse;
exports.parseFmtpConfig = parser.parseFmtpConfig;
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;

},{"./parser":496,"./writer":497}],496:[function(require,module,exports){
var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = require('./grammar');
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split('\r\n').filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var fmtpReducer = function (acc, expr) {
  var s = expr.split('=');
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  }
  return acc;
};

exports.parseFmtpConfig = function (str) {
  return str.split(';').reduce(fmtpReducer, {});
};

exports.parsePayloads = function (str) {
  return str.split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

},{"./grammar":494}],497:[function(require,module,exports){
var grammar = require('./grammar');

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
      case '%%':
        return '%';
      case '%s':
        return String(arg);
      case '%d':
        return Number(arg);
      case '%v':
        return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // "v=0" must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = " "; // "s= " must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = "";
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};

},{"./grammar":494}],498:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],499:[function(require,module,exports){
module.exports={
  "name": "exsip",
  "title": "ExSIP",
  "description": "BroadSoft Javascript SIP library",
  "version": "2.0.0",
  "homepage": "http://www.broadsoft.com",
  "author": {
    "name": "BroadSoft, Inc."
  },
  "contributors": [
    {}
  ],
  "main": "src/ExSIP.js",
  "repository": {
    "type": "git",
    "url": ""
  },
  "keywords": [
    "sip",
    "websocket",
    "webrtc",
    "library"
  ],
  "dependencies": {
    "sdp-transform": "0.6.1",
    "ws": "0.4.32"
  },
  "devDependencies": {
    "nodeunit": "0.9.0",
    "grunt": "0.4.5",
    "grunt-contrib-jshint": "0.10.0",
    "grunt-contrib-concat": "0.5.0",
    "grunt-contrib-uglify": "0.6.0",
    "grunt-contrib-watch": "0.6.1",
    "grunt-contrib-symlink": "0.3.0",
    "grunt-browserify": "3.0.1",
    "grunt-jsdoc": "0.5.7",
    "grunt-notify": ">=0.2.6",
    "grunt-bumpx": "0.1.5",
    "pegjs": "0.7.0",
    "grunt-mocha-test": "0.12.7",
    "expect": "1.6.0",
    "mocha": "2.1.0"
  },
  "engines": {
    "node": ">=0.8"
  },
  "license": "MIT",
  "scripts": {
    "test": "grunt travis --verbose"
  },
  "readme": "<p align=\"center\"><a href=\"http://jssip.net\"><img src=\"http://jssip.net/images/jssip-banner-new.png\"/></a></p>\n\n[![Build Status](https://travis-ci.org/versatica/JsSIP.png?branch=new-design)](https://travis-ci.org/versatica/JsSIP)\n\n## Overview\n\n* Runs in the browser and Node.js.\n* SIP over [WebSocket](http://jssip.net/documentation/misc/sip_websocket/) (use real SIP in your web apps)\n* Audio/video calls ([WebRTC](http://jssip.net/documentation/misc/webrtc)), instant messaging and presence\n* Lightweight! (~140KB)\n* Easy to use and powerful user API\n* Works with OverSIP, Kamailio, Asterisk. Mobicents and repro (reSIProcate) servers ([more info](http://jssip.net/documentation/misc/interoperability))\n* Written by the authors of [RFC 7118 \"The WebSocket Protocol as a Transport for SIP\"](http://tools.ietf.org/html/rfc7118) and [OverSIP](http://oversip.net)\n\n\n## Getting Started\n\nThe following simple JavaScript code creates a JsSIP User Agent instance and makes a SIP call:\n\n```javascript\n// Create our JsSIP instance and run it:\n\nvar configuration = {\n  'ws_servers': 'ws://sip-ws.example.com',\n  'uri': 'sip:alice@example.com',\n  'password': 'superpassword'\n};\n\nvar coolPhone = new JsSIP.UA(configuration);\n\ncoolPhone.start();\n\n\n// Make an audio/video call:\n\n// HTML5 <video> elements in which local and remote video will be shown\nvar selfView =   document.getElementById('my-video');\nvar remoteView =  document.getElementById('peer-video');\n\n// Register callbacks to desired call events\nvar eventHandlers = {\n  'progress': function(e){\n    console.log('call is in progress');\n  },\n  'failed': function(e){\n    console.log('call failed with cause: '+ e.data.cause);\n  },\n  'ended': function(e){\n    console.log('call ended with cause: '+ e.data.cause);\n  },\n  'confirmed': function(e){\n    var rtcSession = e.sender;\n\n    console.log('call confirmed');\n\n    // Attach local stream to selfView\n    if (rtcSession.getLocalStreams().length > 0) {\n      selfView.src = window.URL.createObjectURL(rtcSession.getLocalStreams()[0]);\n    }\n\n    // Attach remote stream to remoteView\n    if (rtcSession.getRemoteStreams().length > 0) {\n      remoteView.src = window.URL.createObjectURL(rtcSession.getRemoteStreams()[0]);\n    }\n  }\n};\n\nvar options = {\n  'eventHandlers': eventHandlers,\n  'mediaConstraints': {'audio': true, 'video': true}\n};\n\n\ncoolPhone.call('sip:bob@example.com', options);\n```\n\nWant to see more? Check the full [Getting Started](http://jssip.net/documentation/0.3.x/getting_started/) section in the project website.\n\n\n## Online Demo\n\nCheck our **Tryit JsSIP** online demo:\n\n* [tryit.jssip.net](http://tryit.jssip.net)\n\n\n## Website and Documentation\n\n* [jssip.net](http://jssip.net/)\n\n\n## Download\n\n* As Node module: `$ npm install jssip`\n* As Bower module: `$ bower install jssip`\n* Manually: [jssip.net/download](http://jssip.net/download/)\n\n\n## Authors\n\n#### Jos Luis Milln\n\n* Main author. Core Designer and Developer.\n* <jmillan@aliax.net> (Github [@jmillan](https://github.com/jmillan))\n\n#### Iaki Baz Castillo\n\n* Core Designer and Developer.\n* <ibc@aliax.net> (Github [@ibc](https://github.com/ibc))\n\n#### Sal Ibarra Corretg\n\n* Core Designer.\n* <saghul@gmail.com> (Github [@saghul](https://github.com/saghul))\n\n\n## License\n\nJsSIP is released under the [MIT license](http://jssip.net/license).\n",
  "readmeFilename": "README.md",
  "_id": "exsip@2.0.0",
  "_shasum": "168aec3241007807f82988e9b98a5dc2591119f2",
  "_resolved": "git+https://github.com/BroadSoft-Xtended/Library-ExSIP#a7be10d373fccde1215b653c09e3c9833f5932d6",
  "_from": "exsip@git+https://github.com/BroadSoft-Xtended/Library-ExSIP#cjs"
}

},{}],500:[function(require,module,exports){
var pkg = require('../package.json');

var C = {
  USER_AGENT: 'BroadSoft WebRTC Client - ' +  pkg.version,

  // SIP scheme
  SIP:  'sip',
  SIPS: 'sips',

  // End and Failure causes
  causes: {
    // Generic error causes
    CONNECTION_ERROR:         'Connection Error',
    REQUEST_TIMEOUT:          'Request Timeout',
    SIP_FAILURE_CODE:         'SIP Failure Code',
    INTERNAL_ERROR:           'Internal Error',

    // SIP error causes
    BUSY:                     'Busy',
    REJECTED:                 'Rejected',
    REDIRECTED:               'Redirected',
    UNAVAILABLE:              'Unavailable',
    NOT_FOUND:                'Not Found',
    ADDRESS_INCOMPLETE:       'Address Incomplete',
    INCOMPATIBLE_SDP:         'Incompatible SDP',
    MISSING_SDP:              'Missing SDP',
    AUTHENTICATION_ERROR:     'Authentication Error',
    DIALOG_ERROR:             'Dialog Error',

    // Session error causes
    BYE:                      'Terminated',
    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
    WEBRTC_ERROR:             'WebRTC Error',
    CANCELED:                 'Canceled',
    NO_ANSWER:                'No Answer',
    EXPIRES:                  'Expires',
    NO_ACK:                   'No ACK',
    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
    RTP_TIMEOUT:              'RTP Timeout',
    NOT_ACCEPTABLE_ERROR:     'Not Acceptable'
  },

  SIP_ERROR_CAUSES: {
    REDIRECTED: [300,301,302,305,380],
    BUSY: [486,600],
    REJECTED: [403,603],
    NOT_FOUND: [404,604],
    UNAVAILABLE: [480,410,408,430],
    ADDRESS_INCOMPLETE: [484],
    INCOMPATIBLE_SDP: [488],
    AUTHENTICATION_ERROR:[401,407],
    NOT_ACCEPTABLE_ERROR:[606]
  },

  // SIP Methods
  ACK:        'ACK',
  BYE:        'BYE',
  CANCEL:     'CANCEL',
  INFO:       'INFO',
  INVITE:     'INVITE',
  REFER:      'REFER',
  MESSAGE:    'MESSAGE',
  NOTIFY:     'NOTIFY',
  OPTIONS:    'OPTIONS',
  REGISTER:   'REGISTER',
  UPDATE:     'UPDATE',
  SUBSCRIBE:  'SUBSCRIBE',

  // MODES
  SENDONLY:  'sendonly',
  RECVONLY:  'recvonly',
  SENDRECV:  'sendrecv',
  INACTIVE:  'inactive',

  /* SIP Response Reasons
   * DOC: http://www.iana.org/assignments/sip-parameters
   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
   */
  REASON_PHRASE: {
    100: 'Trying',
    180: 'Ringing',
    181: 'Call Is Being Forwarded',
    182: 'Queued',
    183: 'Session Progress',
    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
    200: 'OK',
    202: 'Accepted',  // RFC 3265
    204: 'No Notification',  //RFC 5839
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Moved Temporarily',
    305: 'Use Proxy',
    380: 'Alternative Service',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    410: 'Gone',
    412: 'Conditional Request Failed',  // RFC 3903
    413: 'Request Entity Too Large',
    414: 'Request-URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Unsupported URI Scheme',
    417: 'Unknown Resource-Priority',  // RFC 4412
    420: 'Bad Extension',
    421: 'Extension Required',
    422: 'Session Interval Too Small',  // RFC 4028
    423: 'Interval Too Brief',
    428: 'Use Identity Header',  // RFC 4474
    429: 'Provide Referrer Identity',  // RFC 3892
    430: 'Flow Failed',  // RFC 5626
    433: 'Anonymity Disallowed',  // RFC 5079
    436: 'Bad Identity-Info',  // RFC 4474
    437: 'Unsupported Certificate',  // RFC 4744
    438: 'Invalid Identity Header',  // RFC 4744
    439: 'First Hop Lacks Outbound Support',  // RFC 5626
    440: 'Max-Breadth Exceeded',  // RFC 5393
    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
    470: 'Consent Needed',  // RFC 5360
    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
    480: 'Temporarily Unavailable',
    481: 'Call/Transaction Does Not Exist',
    482: 'Loop Detected',
    483: 'Too Many Hops',
    484: 'Address Incomplete',
    485: 'Ambiguous',
    486: 'Busy Here',
    487: 'Request Terminated',
    488: 'Not Acceptable Here',
    489: 'Bad Event',  // RFC 3265
    491: 'Request Pending',
    493: 'Undecipherable',
    494: 'Security Agreement Required',  // RFC 3329
    500: 'ExSIP Internal Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Server Time-out',
    505: 'Version Not Supported',
    513: 'Message Too Large',
    580: 'Precondition Failure',  // RFC 3312
    600: 'Busy Everywhere',
    603: 'Decline',
    604: 'Does Not Exist Anywhere',
    606: 'Not Acceptable'
  },

  ALLOWED_METHODS: 'INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS',
  ACCEPTED_BODY_TYPES: 'application/sdp, application/dtmf-relay',
  MAX_FORWARDS: 69
};


module.exports = C;

},{"../package.json":499}],501:[function(require,module,exports){
module.exports = Dialog;


var C = {
  // Dialog states
  STATUS_EARLY:       1,
  STATUS_CONFIRMED:   2
};

/**
 * Expose C object.
 */
Dialog.C = C;


/**
 * Dependencies.
 */
var SIPMessage = require('./SIPMessage');
var ExSIP_C = require('./Constants');
var Transactions = require('./Transactions');
var Utils = require('./Utils');
var Dialog_RequestSender = require('./Dialog/RequestSender');


// RFC 3261 12.1
function Dialog(owner, message, type, state) {
  var contact;

  this.uac_pending_reply = false;
  this.uas_pending_reply = false;
  this.is_acknowledged = false;
  this.type = type;

  if(!message.hasHeader('contact')) {
    return {
      error: 'unable to create a Dialog without Contact header field'
    };
  }

  if(message instanceof SIPMessage.IncomingResponse) {
    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
  } else {
    // Create confirmed dialog if state is not defined
    state = state || C.STATUS_CONFIRMED;
  }

  contact = message.parseHeader('contact');

  // RFC 3261 12.1.1
  if(type === 'UAS') {
    this.id = {
      call_id: message.call_id,
      local_tag: message.to_tag,
      remote_tag: message.from_tag,
      toString: function() {
        return this.call_id + this.local_tag + this.remote_tag;
      }
    };
    this.state = state;
    this.remote_seqnum = message.cseq;
    this.local_uri = message.parseHeader('to').uri;
    this.remote_uri = message.parseHeader('from').uri;
    this.remote_target = contact.uri;
    this.route_set = message.getHeaders('record-route');
  }
  // RFC 3261 12.1.2
  else if(type === 'UAC') {
    this.id = {
      call_id: message.call_id,
      local_tag: message.from_tag,
      remote_tag: message.to_tag,
      toString: function() {
        return this.call_id + this.local_tag + this.remote_tag;
      }
    };
    this.state = state;
    this.local_seqnum = message.cseq;
    this.local_uri = message.parseHeader('from').uri;
    this.remote_uri = message.parseHeader('to').uri;
    this.remote_target = contact.uri;
    this.route_set = message.getHeaders('record-route').reverse();
  }

  this.logger = owner.ua.getLogger('ExSIP.dialog', this.id.toString());
  this.owner = owner;
  owner.ua.dialogs[this.id.toString()] = this;
  this.logger.debug('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
}


Dialog.prototype = {
  isUAS: function() {
    return this.type === 'UAS';
  },

  isUAC: function() {
    return this.type === 'UAC';
  },

  update: function(message, type) {
    this.state = C.STATUS_CONFIRMED;

    this.logger.debug('dialog '+ this.id.toString() +'  changed to CONFIRMED state');

    if(type === 'UAC') {
      // RFC 3261 13.2.2.4
      this.route_set = message.getHeaders('record-route').reverse();
    }
  },

  terminate: function() {
    this.logger.debug('dialog ' + this.id.toString() + ' deleted');
    delete this.owner.ua.dialogs[this.id.toString()];
  },

  // RFC 3261 12.2.1.1
  createRequest: function(method, extraHeaders, body) {
    var cseq, request;
    extraHeaders = extraHeaders && extraHeaders.slice() || [];

    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }

    cseq = (method === ExSIP_C.CANCEL || method === ExSIP_C.ACK) ? this.local_seqnum : this.local_seqnum += 1;

    request = new SIPMessage.OutgoingRequest(
      method,
      this.remote_target,
      this.owner.ua, {
        'cseq': cseq,
        'call_id': this.id.call_id,
        'from_uri': this.local_uri,
        'from_tag': this.id.local_tag,
        'to_uri': this.remote_uri,
        'to_tag': this.id.remote_tag,
        'route_set': this.route_set
      }, extraHeaders, body);

  this.logger.debug('createRequest : dialog.request_sender.request.extraHeaders : '+Utils.toString(request.extraHeaders));

    request.dialog = this;

    return request;
  },

  // RFC 3261 12.2.2
  checkInDialogRequest: function(request) {
    var self = this;

    // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
    if (request.method === ExSIP_C.INVITE || (request.method === ExSIP_C.UPDATE && request.body)) {
      if (this.uac_pending_reply === true) {
        request.reply(491);
      } else if (this.uas_pending_reply === true || (this.type === 'UAS' && !this.is_acknowledged)) {
        var retryAfter = (Math.random() * 10 | 0) + 1;
        request.reply(500, null, ['Retry-After:'+ retryAfter]);
        return false;
      } else {
        this.uas_pending_reply = true;
        request.server_transaction.on('stateChanged', function stateChanged(e){
          if (e.sender.state === Transactions.C.STATUS_ACCEPTED ||
              e.sender.state === Transactions.C.STATUS_COMPLETED ||
              e.sender.state === Transactions.C.STATUS_TERMINATED) {

            request.server_transaction.removeListener('stateChanged', stateChanged);
            self.uas_pending_reply = false;

            if (self.uac_pending_reply === false) {
              self.owner.onReadyToReinvite();
            }
          }
        });
      }

      // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
      if(request.hasHeader('contact')) {
        request.server_transaction.on('stateChanged', function(e){
          if (e.sender.state === Transactions.C.STATUS_ACCEPTED) {
            self.remote_target = request.parseHeader('contact').uri;
          }
        });
      }
    }
    else if (request.method === ExSIP_C.NOTIFY) {
      // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
      if(request.hasHeader('contact')) {
        request.server_transaction.on('stateChanged', function(e){
          if (e.sender.state === Transactions.C.STATUS_COMPLETED) {
            self.remote_target = request.parseHeader('contact').uri;
          }
        });
      }
    }
    else if (request.method === ExSIP_C.ACK) {
      this.is_acknowledged = true;
    }

    if(!this.remote_seqnum) {
      this.remote_seqnum = request.cseq;
    } else if(request.cseq < this.remote_seqnum) {
        //Do not try to reply to an ACK request.
        if (request.method !== ExSIP_C.ACK) {
          request.reply(500);
        }
        return false;
    } else if(request.cseq > this.remote_seqnum) {
      this.remote_seqnum = request.cseq;
    }

    return true;
  },

  createRequestSender: function(applicant, method, options) {
    options = options || {};

    var
      extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
      body = options.body || null,
      request = this.createRequest(method, extraHeaders, body),
      request_sender = new Dialog_RequestSender(this, applicant, request);
  this.logger.debug('dialog.request_sender.request.extraHeaders : '+Utils.toString(request.extraHeaders));

    return request_sender;  
  },

  sendRequest: function(applicant, method, options) {
      var request_sender = this.createRequestSender(applicant, method, options);
      request_sender.send();
  },

  receiveRequest: function(request) {
    //Check in-dialog request
    if(!this.checkInDialogRequest(request)) {
      return;
    }

    this.owner.receiveRequest(request);
  }
};

},{"./Constants":500,"./Dialog/RequestSender":502,"./SIPMessage":519,"./Transactions":521,"./Utils":525}],502:[function(require,module,exports){
module.exports = DialogRequestSender;

/**
 * Dependencies.
 */
var ExSIP_C = require('../Constants');
var Transactions = require('../Transactions');
var RTCSession = require('../RTCSession');
var RequestSender = require('../RequestSender');


function DialogRequestSender(dialog, applicant, request) {

  this.dialog = dialog;
  this.applicant = applicant;
  this.request = request;

  this.logger = dialog.owner.ua.getLogger('ExSIP.dialog.requestsender', dialog.id);

  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
  this.reattempt = false;
  this.reattemptTimer = null;
}


DialogRequestSender.prototype = {
  send: function(callbacks) {
    var
      self = this,
      request_sender = new RequestSender(this, this.dialog.owner.ua);

    request_sender.send(callbacks);

    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
    if (this.request.method === ExSIP_C.INVITE && request_sender.clientTransaction.state !== Transactions.C.STATUS_TERMINATED) {
      this.dialog.uac_pending_reply = true;
      request_sender.clientTransaction.on('stateChanged', function stateChanged(e) {
        if (e.sender.state === Transactions.C.STATUS_ACCEPTED ||
          e.sender.state === Transactions.C.STATUS_COMPLETED ||
          e.sender.state === Transactions.C.STATUS_TERMINATED) {

          request_sender.clientTransaction.removeListener('stateChanged', stateChanged);
          self.dialog.uac_pending_reply = false;

          if (self.dialog.uas_pending_reply === false) {
            self.dialog.owner.onReadyToReinvite();
          }
        }
      });
    }
  },

  onRequestTimeout: function() {
    this.logger.log('********* onRequestTimeout : ', this.applicant);
    this.applicant.onRequestTimeout();
  },

  onTransportError: function() {
    this.applicant.onTransportError();
  },

  // RFC3261 14.1
  getReattemptTimeout: function() {
    if(this.applicant.direction === 'outgoing') {
      return (Math.random() * (4 - 2.1) + 2.1).toFixed(2);
    } else {
      return (Math.random() * 2).toFixed(2);
    }
  },

  receiveResponse: function(response) {
    var self = this;

    this.logger.debug('receiveResponse : ' + response);

    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
    if (response.status_code === 408 || response.status_code === 481) {
      this.applicant.onDialogError(response);
    } else if (response.method === ExSIP_C.INVITE && response.status_code === 491) {
      if (this.reattempt) {
        this.applicant.receiveResponse(response);
      } else {
        this.request.cseq.value = this.dialog.local_seqnum += 1;
        this.reattemptTimer = setTimeout(
          function() {
            if (self.applicant.owner.status !== RTCSession.C.STATUS_TERMINATED) {
              self.reattempt = true;
              self.request_sender.send();
            }
          },
          this.getReattemptTimeout()
        );
      }
    } else {
      this.applicant.receiveResponse(response);
    }
  }
};
},{"../Constants":500,"../RTCSession":513,"../RequestSender":518,"../Transactions":521}],503:[function(require,module,exports){
module.exports = DigestAuthentication;


function DigestAuthentication(ua) {
  this.logger = ua.getLogger('ExSIP.digestauthentication');
  this.username = ua.configuration.authorization_user;
  this.password = ua.configuration.password;
  this.cnonce = null;
  this.nc = 0;
  this.ncHex = '00000000';
  this.response = null;
}


/**
 * Dependencies.
 */
var Utils = require('./Utils');


/**
* Performs Digest authentication given a SIP request and the challenge
* received in a response to that request.
* Returns true if credentials were successfully generated, false otherwise.
<<<<<<< HEAD
* 
* @param {ExSIP.OutgoingRequest} request
* @param {Object} challenge
=======
>>>>>>> ExSIP050
*/
DigestAuthentication.prototype.authenticate = function(request, challenge) {
  // Inspect and validate the challenge.

  this.algorithm = challenge.algorithm;
  this.realm = challenge.realm;
  this.nonce = challenge.nonce;
  this.opaque = challenge.opaque;
  this.stale = challenge.stale;

  if (this.algorithm) {
    if (this.algorithm !== 'MD5') {
      this.logger.warn('challenge with Digest algorithm different than "MD5", authentication aborted');
      return false;
    }
  } else {
    this.algorithm = 'MD5';
  }

  if (! this.realm) {
    this.logger.warn('challenge without Digest realm, authentication aborted');
    return false;
  }

  if (! this.nonce) {
    this.logger.warn('challenge without Digest nonce, authentication aborted');
    return false;
  }

  // 'qop' can contain a list of values (Array). Let's choose just one.
  if (challenge.qop) {
    if (challenge.qop.indexOf('auth') > -1) {
      this.qop = 'auth';
    } else if (challenge.qop.indexOf('auth-int') > -1) {
      this.qop = 'auth-int';
    } else {
      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
      this.logger.warn('challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
      return false;
    }
  } else {
    this.qop = null;
  }

  // Fill other attributes.

  this.method = request.method;
  this.uri = request.ruri;
  this.cnonce = Utils.createRandomToken(12);
  this.nc += 1;
  this.updateNcHex();

  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
  if (this.nc === 4294967296) {
    this.nc = 1;
    this.ncHex = '00000001';
  }

  // Calculate the Digest "response" value.
  this.calculateResponse();

  return true;
};


/**
* Generate Digest 'response' value.
*/
DigestAuthentication.prototype.calculateResponse = function() {
  var ha1, ha2;

  // HA1 = MD5(A1) = MD5(username:realm:password)
  ha1 = Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);

  if (this.qop === 'auth') {
    // HA2 = MD5(A2) = MD5(method:digestURI)
    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);

  } else if (this.qop === 'auth-int') {
    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
    ha2 = Utils.calculateMD5(this.method + ":" + this.uri + ":" + Utils.calculateMD5(this.body ? this.body : ""));
    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);

  } else if (this.qop === null) {
    // HA2 = MD5(A2) = MD5(method:digestURI)
    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
    // response = MD5(HA1:nonce:HA2)
    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
  }
};


/**
* Return the Proxy-Authorization or WWW-Authorization header value.
*/
DigestAuthentication.prototype.toString = function() {
  var auth_params = [];

  if (! this.response) {
    throw new Error('response field does not exist, cannot generate Authorization header');
  }

  auth_params.push('algorithm=' + this.algorithm);
  auth_params.push('username="' + this.username + '"');
  auth_params.push('realm="' + this.realm + '"');
  auth_params.push('nonce="' + this.nonce + '"');
  auth_params.push('uri="' + this.uri + '"');
  auth_params.push('response="' + this.response + '"');
  if (this.opaque) {
    auth_params.push('opaque="' + this.opaque + '"');
  }
  if (this.qop) {
    auth_params.push('qop=' + this.qop);
    auth_params.push('cnonce="' + this.cnonce + '"');
    auth_params.push('nc=' + this.ncHex);
  }

  return 'Digest ' + auth_params.join(', ');
};


/**
* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
*/
DigestAuthentication.prototype.updateNcHex = function() {
  var hex = Number(this.nc).toString(16);
  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
};
},{"./Utils":525}],504:[function(require,module,exports){
module.exports = EventEmitter;


function EventEmitter() {}


/**
 * Dependencies.
 */
var LoggerFactory = require('./LoggerFactory');


function Event(type, sender, data) {
  this.type = type;
  this.sender= sender;
  this.data = data;
}


var
  logger = new LoggerFactory().getLogger('ExSIP.eventemitter'),
  C = {
    MAX_LISTENERS: 50
  };


EventEmitter.prototype = {
  /**
   * Initialize events dictionaries.
   * -param {Array} events
   */
  initEvents: function(events) {
    var idx, length;

    if (!this.logger) {
      this.logger = logger;
    }

    this.maxListeners = C.MAX_LISTENERS;

    this.events = {};
    this.oneTimeListeners = {};

    length = events.length;
    for (idx = 0; idx < length; idx++) {
      this.events[events[idx]] = [];
      this.oneTimeListeners[events[idx]] = [];
    }
  },

  /**
   * Check whether an event exists or not.
   */
  checkEvent: function(event) {
    return !!this.events[event];
  },

  /**
   * Add a listener to the end of the listeners array for the specified event.
   */
  addListener: function(event, listener) {
    if (listener === undefined) {
      return;
    } else if (typeof listener !== 'function') {
      this.logger.error('listener must be a function');
      return;
    } else if (!this.checkEvent(event)) {
      this.logger.error('unable to add a listener to a nonexistent event ' + event);
      return;
    }

    if (this.events[event].length >= this.maxListeners) {
      this.logger.warn('max listeners exceeded for event ' + event);
    }

    this.events[event].push(listener);
  },

  on: function(event, listener) {
    this.addListener(event, listener);
  },

  /**
   * Add a one time listener for the specified event.
   * The listener is invoked only the next time the event is fired, then it is removed.
   */
  once: function(event, listener) {
    this.on(event, listener);
    this.oneTimeListeners[event].push(listener);
  },

  /**
   * Remove a listener from the listener array for the specified event.
   * Note that the order of the array elements will change after removing the listener
   */
  removeListener: function(event, listener) {
    var events, length,
      idx = 0;

    if (listener === undefined) {
      return;
    } else if (typeof listener !== 'function') {
      this.logger.error('listener must be a function');
      return;
    } else if (!this.checkEvent(event)) {
      this.logger.error('unable to remove a listener from a nonexistent event'+ event);
      return;
    }

    events = this.events[event];
    length = events.length;

    while (idx < length) {
      if (events[idx] === listener) {
        events.splice(idx,1);
      } else {
        idx ++;
      }
    }
  },

  /**
   * Remove all listeners from the listener array for the specified event.
   */
  removeAllListener: function(event) {
    if (!this.checkEvent(event)) {
      this.logger.error('unable to remove listeners from a nonexistent event'+ event);
      return;
    }

    this.events[event] = [];
    this.oneTimeListeners[event] = [];
  },

  /**
   * By default EventEmitter will print a warning
   * if more than C.MAX_LISTENERS listeners are added for a particular event.
   * This function allows that limit to be modified.
   */
  setMaxListeners: function(listeners) {
    if (typeof listeners !== 'number' || listeners < 0) {
      this.logger.error('listeners must be a positive number');
      return;
    }

    this.maxListeners = listeners;
  },

  /**
   * Get the listeners for a specific event.
   */
  listeners: function(event) {
    if (!this.checkEvent(event)) {
      this.logger.error('no event '+ event);
      return;
    }

    return this.events[event];
  },

  /**
   * Execute each of the listeners in order with the supplied arguments.
   */
  emit: function(event, sender, data) {
    var listeners, length, e, idx,
      self = this;

    if (!this.checkEvent(event)) {
      this.logger.error('unable to emit a nonexistent event'+ event);
      return;
    }

    this.logger.debug('emitting event '+ event);

    listeners = this.events[event];
    length = listeners.length;

    e = new Event(event, sender, data);

    listeners.map(function(listener) {
      return function() {
        listener.call(null, e);
      };
    }).forEach(function(callback) {
      try {
        callback();
      } catch(err) {
        self.logger.error(err.stack);
      }
    });

    // Remove one time listeners
    for (idx in this.oneTimeListeners[event]) {
      this.removeListener(event, this.oneTimeListeners[event][idx]);
    }

    this.oneTimeListeners[event] = [];
  }
};
},{"./LoggerFactory":509}],505:[function(require,module,exports){
var ExSIP = {
  C: require('./Constants'),
  Exceptions: require('./Exceptions'),
  Utils: require('./Utils'),
  UA: require('./UA'),
  URI: require('./URI'),
  NameAddrHeader: require('./NameAddrHeader'),
  Grammar: require('./Grammar'),
  WebRTC: require('./WebRTC'),
  RTCSession: require('./RTCSession')
};

module.exports = ExSIP;


var pkg = require('../package.json');


Object.defineProperties(ExSIP, {
  name: {
    get: function(){ return pkg.title; }
  },

  /**
   * Retrieve the version of ExSIP.
   * @memberof ExSIP
   * @method
   * @returns {String} Version in the form "X.Y.Z"
   * @example
   * // prints "1.0.0"
   * console.log(ExSIP.version)
   */
  version: {
    get: function(){ return pkg.version; }
  }
});

},{"../package.json":499,"./Constants":500,"./Exceptions":506,"./Grammar":507,"./NameAddrHeader":511,"./RTCSession":513,"./UA":523,"./URI":524,"./Utils":525,"./WebRTC":526}],506:[function(require,module,exports){
/**
 * @namespace Exceptions
 * @memberOf ExSIP
 */
var Exceptions = {
  /**
   * Exception thrown when a valid parameter is given to the ExSIP.UA constructor.
   * @class ConfigurationError
   * @memberOf ExSIP.Exceptions
   */
  ConfigurationError: (function(){
    var exception = function(parameter, value) {
      console.trace('----------------------ConfigurationError : '+parameter+', '+value);
      this.code = 1;
      this.name = 'CONFIGURATION_ERROR';
      this.parameter = parameter;
      this.value = value;
      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
    };
    exception.prototype = new Error();
    return exception;
  }()),

  InvalidStateError: (function(){
    var exception = function(status) {
      console.trace('----------------------InvalidStateError : '+status);
      this.code = 2;
      this.name = 'INVALID_STATE_ERROR';
      this.status = status;
      this.message = 'Invalid status: '+ status;
    };
    exception.prototype = new Error();
    return exception;
  }()),

  NotSupportedError: (function(){
    var exception = function(message) {
      console.trace('----------------------NotSupportedError : '+message);
      this.code = 3;
      this.name = 'NOT_SUPPORTED_ERROR';
      this.message = message;
    };
    exception.prototype = new Error();
    return exception;
  }()),

  NotReadyError: (function(){
    var exception = function(message) {
      console.trace('----------------------NotReadyError : '+message);
      this.code = 4;
      this.name = 'NOT_READY_ERROR';
      this.message = message;
    };
    exception.prototype = new Error();
    return exception;
  }())
};

module.exports = Exceptions;
},{}],507:[function(require,module,exports){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "CRLF": parse_CRLF,
        "DIGIT": parse_DIGIT,
        "ALPHA": parse_ALPHA,
        "HEXDIG": parse_HEXDIG,
        "WSP": parse_WSP,
        "OCTET": parse_OCTET,
        "DQUOTE": parse_DQUOTE,
        "SP": parse_SP,
        "HTAB": parse_HTAB,
        "alphanum": parse_alphanum,
        "reserved": parse_reserved,
        "unreserved": parse_unreserved,
        "mark": parse_mark,
        "escaped": parse_escaped,
        "LWS": parse_LWS,
        "SWS": parse_SWS,
        "HCOLON": parse_HCOLON,
        "TEXT_UTF8_TRIM": parse_TEXT_UTF8_TRIM,
        "TEXT_UTF8char": parse_TEXT_UTF8char,
        "UTF8_NONASCII": parse_UTF8_NONASCII,
        "UTF8_CONT": parse_UTF8_CONT,
        "LHEX": parse_LHEX,
        "token": parse_token,
        "token_nodot": parse_token_nodot,
        "separators": parse_separators,
        "word": parse_word,
        "STAR": parse_STAR,
        "SLASH": parse_SLASH,
        "EQUAL": parse_EQUAL,
        "LPAREN": parse_LPAREN,
        "RPAREN": parse_RPAREN,
        "RAQUOT": parse_RAQUOT,
        "LAQUOT": parse_LAQUOT,
        "COMMA": parse_COMMA,
        "SEMI": parse_SEMI,
        "COLON": parse_COLON,
        "LDQUOT": parse_LDQUOT,
        "RDQUOT": parse_RDQUOT,
        "comment": parse_comment,
        "ctext": parse_ctext,
        "quoted_string": parse_quoted_string,
        "quoted_string_clean": parse_quoted_string_clean,
        "qdtext": parse_qdtext,
        "quoted_pair": parse_quoted_pair,
        "SIP_URI_noparams": parse_SIP_URI_noparams,
        "SIP_URI": parse_SIP_URI,
        "uri_scheme": parse_uri_scheme,
        "userinfo": parse_userinfo,
        "user": parse_user,
        "user_unreserved": parse_user_unreserved,
        "password": parse_password,
        "hostport": parse_hostport,
        "host": parse_host,
        "hostname": parse_hostname,
        "domainlabel": parse_domainlabel,
        "toplabel": parse_toplabel,
        "IPv6reference": parse_IPv6reference,
        "IPv6address": parse_IPv6address,
        "h16": parse_h16,
        "ls32": parse_ls32,
        "IPv4address": parse_IPv4address,
        "dec_octet": parse_dec_octet,
        "port": parse_port,
        "uri_parameters": parse_uri_parameters,
        "uri_parameter": parse_uri_parameter,
        "transport_param": parse_transport_param,
        "user_param": parse_user_param,
        "method_param": parse_method_param,
        "ttl_param": parse_ttl_param,
        "maddr_param": parse_maddr_param,
        "lr_param": parse_lr_param,
        "other_param": parse_other_param,
        "pname": parse_pname,
        "pvalue": parse_pvalue,
        "paramchar": parse_paramchar,
        "param_unreserved": parse_param_unreserved,
        "headers": parse_headers,
        "header": parse_header,
        "hname": parse_hname,
        "hvalue": parse_hvalue,
        "hnv_unreserved": parse_hnv_unreserved,
        "Request_Response": parse_Request_Response,
        "Request_Line": parse_Request_Line,
        "Request_URI": parse_Request_URI,
        "absoluteURI": parse_absoluteURI,
        "hier_part": parse_hier_part,
        "net_path": parse_net_path,
        "abs_path": parse_abs_path,
        "opaque_part": parse_opaque_part,
        "uric": parse_uric,
        "uric_no_slash": parse_uric_no_slash,
        "path_segments": parse_path_segments,
        "segment": parse_segment,
        "param": parse_param,
        "pchar": parse_pchar,
        "scheme": parse_scheme,
        "authority": parse_authority,
        "srvr": parse_srvr,
        "reg_name": parse_reg_name,
        "query": parse_query,
        "SIP_Version": parse_SIP_Version,
        "INVITEm": parse_INVITEm,
        "ACKm": parse_ACKm,
        "OPTIONSm": parse_OPTIONSm,
        "BYEm": parse_BYEm,
        "CANCELm": parse_CANCELm,
        "REGISTERm": parse_REGISTERm,
        "SUBSCRIBEm": parse_SUBSCRIBEm,
        "NOTIFYm": parse_NOTIFYm,
        "Method": parse_Method,
        "Status_Line": parse_Status_Line,
        "Status_Code": parse_Status_Code,
        "extension_code": parse_extension_code,
        "Reason_Phrase": parse_Reason_Phrase,
        "Allow_Events": parse_Allow_Events,
        "Call_ID": parse_Call_ID,
        "Contact": parse_Contact,
        "contact_param": parse_contact_param,
        "name_addr": parse_name_addr,
        "display_name": parse_display_name,
        "contact_params": parse_contact_params,
        "c_p_q": parse_c_p_q,
        "c_p_expires": parse_c_p_expires,
        "delta_seconds": parse_delta_seconds,
        "qvalue": parse_qvalue,
        "generic_param": parse_generic_param,
        "gen_value": parse_gen_value,
        "Content_Disposition": parse_Content_Disposition,
        "disp_type": parse_disp_type,
        "disp_param": parse_disp_param,
        "handling_param": parse_handling_param,
        "Content_Encoding": parse_Content_Encoding,
        "Content_Length": parse_Content_Length,
        "Content_Type": parse_Content_Type,
        "media_type": parse_media_type,
        "m_type": parse_m_type,
        "discrete_type": parse_discrete_type,
        "composite_type": parse_composite_type,
        "extension_token": parse_extension_token,
        "x_token": parse_x_token,
        "m_subtype": parse_m_subtype,
        "m_parameter": parse_m_parameter,
        "m_value": parse_m_value,
        "CSeq": parse_CSeq,
        "CSeq_value": parse_CSeq_value,
        "Expires": parse_Expires,
        "Event": parse_Event,
        "event_type": parse_event_type,
        "From": parse_From,
        "from_param": parse_from_param,
        "tag_param": parse_tag_param,
        "Max_Forwards": parse_Max_Forwards,
        "Min_Expires": parse_Min_Expires,
        "Name_Addr_Header": parse_Name_Addr_Header,
        "Proxy_Authenticate": parse_Proxy_Authenticate,
        "challenge": parse_challenge,
        "other_challenge": parse_other_challenge,
        "auth_param": parse_auth_param,
        "digest_cln": parse_digest_cln,
        "realm": parse_realm,
        "realm_value": parse_realm_value,
        "domain": parse_domain,
        "URI": parse_URI,
        "nonce": parse_nonce,
        "nonce_value": parse_nonce_value,
        "opaque": parse_opaque,
        "stale": parse_stale,
        "algorithm": parse_algorithm,
        "qop_options": parse_qop_options,
        "qop_value": parse_qop_value,
        "Proxy_Require": parse_Proxy_Require,
        "Record_Route": parse_Record_Route,
        "rec_route": parse_rec_route,
        "Require": parse_Require,
        "Route": parse_Route,
        "route_param": parse_route_param,
        "Subscription_State": parse_Subscription_State,
        "substate_value": parse_substate_value,
        "subexp_params": parse_subexp_params,
        "event_reason_value": parse_event_reason_value,
        "Subject": parse_Subject,
        "Supported": parse_Supported,
        "To": parse_To,
        "to_param": parse_to_param,
        "Via": parse_Via,
        "via_parm": parse_via_parm,
        "via_params": parse_via_params,
        "via_ttl": parse_via_ttl,
        "via_maddr": parse_via_maddr,
        "via_received": parse_via_received,
        "via_branch": parse_via_branch,
        "response_port": parse_response_port,
        "sent_protocol": parse_sent_protocol,
        "protocol_name": parse_protocol_name,
        "transport": parse_transport,
        "sent_by": parse_sent_by,
        "via_host": parse_via_host,
        "via_port": parse_via_port,
        "ttl": parse_ttl,
        "WWW_Authenticate": parse_WWW_Authenticate,
        "extension_header": parse_extension_header,
        "header_value": parse_header_value,
        "message_body": parse_message_body,
        "stun_URI": parse_stun_URI,
        "stun_scheme": parse_stun_scheme,
        "stun_host_port": parse_stun_host_port,
        "stun_host": parse_stun_host,
        "reg_name": parse_reg_name,
        "stun_unreserved": parse_stun_unreserved,
        "sub_delims": parse_sub_delims,
        "turn_URI": parse_turn_URI,
        "turn_scheme": parse_turn_scheme,
        "turn_transport": parse_turn_transport,
        "uuid_URI": parse_uuid_URI,
        "uuid": parse_uuid,
        "hex4": parse_hex4,
        "hex8": parse_hex8,
        "hex12": parse_hex12
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "CRLF";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_CRLF() {
        var result0;
        
        if (input.substr(pos, 2) === "\r\n") {
          result0 = "\r\n";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\r\\n\"");
          }
        }
        return result0;
      }
      
      function parse_DIGIT() {
        var result0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        return result0;
      }
      
      function parse_ALPHA() {
        var result0;
        
        if (/^[a-zA-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z]");
          }
        }
        return result0;
      }
      
      function parse_HEXDIG() {
        var result0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        return result0;
      }
      
      function parse_WSP() {
        var result0;
        
        result0 = parse_SP();
        if (result0 === null) {
          result0 = parse_HTAB();
        }
        return result0;
      }
      
      function parse_OCTET() {
        var result0;
        
        if (/^[\0-\xFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\0-\\xFF]");
          }
        }
        return result0;
      }
      
      function parse_DQUOTE() {
        var result0;
        
        if (/^["]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\"]");
          }
        }
        return result0;
      }
      
      function parse_SP() {
        var result0;
        
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        return result0;
      }
      
      function parse_HTAB() {
        var result0;
        
        if (input.charCodeAt(pos) === 9) {
          result0 = "\t";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\t\"");
          }
        }
        return result0;
      }
      
      function parse_alphanum() {
        var result0;
        
        if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9]");
          }
        }
        return result0;
      }
      
      function parse_reserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 47) {
            result0 = "/";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 63) {
              result0 = "?";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 58) {
                result0 = ":";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 64) {
                  result0 = "@";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 38) {
                    result0 = "&";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"&\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 61) {
                      result0 = "=";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"=\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result0 = "+";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 36) {
                          result0 = "$";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"$\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 44) {
                            result0 = ",";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\",\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_unreserved() {
        var result0;
        
        result0 = parse_alphanum();
        if (result0 === null) {
          result0 = parse_mark();
        }
        return result0;
      }
      
      function parse_mark() {
        var result0;
        
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 95) {
            result0 = "_";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"_\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 46) {
              result0 = ".";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 33) {
                result0 = "!";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 126) {
                  result0 = "~";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"~\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result0 = "*";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 39) {
                      result0 = "'";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 40) {
                        result0 = "(";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"(\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 41) {
                          result0 = ")";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\")\"");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_escaped() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 37) {
          result0 = "%";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"%\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, escaped) {return escaped.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LWS() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        result0 = [];
        result1 = parse_WSP();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WSP();
        }
        if (result0 !== null) {
          result1 = parse_CRLF();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos2;
          }
        } else {
          result0 = null;
          pos = pos2;
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_WSP();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_WSP();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return " "; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SWS() {
        var result0;
        
        result0 = parse_LWS();
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_HCOLON() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_SP();
        if (result1 === null) {
          result1 = parse_HTAB();
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_SP();
          if (result1 === null) {
            result1 = parse_HTAB();
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ':'; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TEXT_UTF8_TRIM() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_TEXT_UTF8char();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_TEXT_UTF8char();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = [];
          result3 = parse_LWS();
          while (result3 !== null) {
            result2.push(result3);
            result3 = parse_LWS();
          }
          if (result2 !== null) {
            result3 = parse_TEXT_UTF8char();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = [];
            result3 = parse_LWS();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_LWS();
            }
            if (result2 !== null) {
              result3 = parse_TEXT_UTF8char();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TEXT_UTF8char() {
        var result0;
        
        if (/^[!-~]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[!-~]");
          }
        }
        if (result0 === null) {
          result0 = parse_UTF8_NONASCII();
        }
        return result0;
      }
      
      function parse_UTF8_NONASCII() {
        var result0;
        
        if (/^[\x80-\uFFFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\x80-\\uFFFF]");
          }
        }
        return result0;
      }
      
      function parse_UTF8_CONT() {
        var result0;
        
        if (/^[\x80-\xBF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\x80-\\xBF]");
          }
        }
        return result0;
      }
      
      function parse_LHEX() {
        var result0;
        
        result0 = parse_DIGIT();
        if (result0 === null) {
          if (/^[a-f]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[a-f]");
            }
          }
        }
        return result0;
      }
      
      function parse_token() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 46) {
              result1 = ".";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 33) {
                result1 = "!";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 37) {
                  result1 = "%";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"%\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result1 = "*";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 95) {
                      result1 = "_";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"_\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result1 = "+";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 96) {
                          result1 = "`";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"`\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            result1 = "'";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 126) {
                              result1 = "~";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"~\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 46) {
                  result1 = ".";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 33) {
                    result1 = "!";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 37) {
                      result1 = "%";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"%\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 42) {
                        result1 = "*";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result1 = "_";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 96) {
                              result1 = "`";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"`\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 39) {
                                result1 = "'";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"'\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 126) {
                                  result1 = "~";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"~\"");
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_token_nodot() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 33) {
              result1 = "!";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"!\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 37) {
                result1 = "%";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"%\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 42) {
                  result1 = "*";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"*\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 95) {
                    result1 = "_";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"_\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 43) {
                      result1 = "+";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 96) {
                        result1 = "`";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"`\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          result1 = "'";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"'\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 126) {
                            result1 = "~";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"~\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 33) {
                  result1 = "!";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"!\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 37) {
                    result1 = "%";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"%\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 42) {
                      result1 = "*";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 95) {
                        result1 = "_";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"_\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result1 = "+";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 96) {
                            result1 = "`";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"`\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 39) {
                              result1 = "'";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"'\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 126) {
                                result1 = "~";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"~\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_separators() {
        var result0;
        
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 41) {
            result0 = ")";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 60) {
              result0 = "<";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"<\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 62) {
                result0 = ">";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\">\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 64) {
                  result0 = "@";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 44) {
                    result0 = ",";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 59) {
                      result0 = ";";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result0 = ":";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 92) {
                          result0 = "\\";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\\\"");
                          }
                        }
                        if (result0 === null) {
                          result0 = parse_DQUOTE();
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 47) {
                              result0 = "/";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"/\"");
                              }
                            }
                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 91) {
                                result0 = "[";
                                pos++;
                              } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"[\"");
                                }
                              }
                              if (result0 === null) {
                                if (input.charCodeAt(pos) === 93) {
                                  result0 = "]";
                                  pos++;
                                } else {
                                  result0 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"]\"");
                                  }
                                }
                                if (result0 === null) {
                                  if (input.charCodeAt(pos) === 63) {
                                    result0 = "?";
                                    pos++;
                                  } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"?\"");
                                    }
                                  }
                                  if (result0 === null) {
                                    if (input.charCodeAt(pos) === 61) {
                                      result0 = "=";
                                      pos++;
                                    } else {
                                      result0 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"=\"");
                                      }
                                    }
                                    if (result0 === null) {
                                      if (input.charCodeAt(pos) === 123) {
                                        result0 = "{";
                                        pos++;
                                      } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"{\"");
                                        }
                                      }
                                      if (result0 === null) {
                                        if (input.charCodeAt(pos) === 125) {
                                          result0 = "}";
                                          pos++;
                                        } else {
                                          result0 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"}\"");
                                          }
                                        }
                                        if (result0 === null) {
                                          result0 = parse_SP();
                                          if (result0 === null) {
                                            result0 = parse_HTAB();
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_word() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 46) {
              result1 = ".";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 33) {
                result1 = "!";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 37) {
                  result1 = "%";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"%\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result1 = "*";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 95) {
                      result1 = "_";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"_\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result1 = "+";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 96) {
                          result1 = "`";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"`\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            result1 = "'";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 126) {
                              result1 = "~";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"~\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 40) {
                                result1 = "(";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"(\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 41) {
                                  result1 = ")";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\")\"");
                                  }
                                }
                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 60) {
                                    result1 = "<";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"<\"");
                                    }
                                  }
                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 62) {
                                      result1 = ">";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\">\"");
                                      }
                                    }
                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result1 = ":";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 92) {
                                          result1 = "\\";
                                          pos++;
                                        } else {
                                          result1 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"\\\\\"");
                                          }
                                        }
                                        if (result1 === null) {
                                          result1 = parse_DQUOTE();
                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 47) {
                                              result1 = "/";
                                              pos++;
                                            } else {
                                              result1 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"/\"");
                                              }
                                            }
                                            if (result1 === null) {
                                              if (input.charCodeAt(pos) === 91) {
                                                result1 = "[";
                                                pos++;
                                              } else {
                                                result1 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"[\"");
                                                }
                                              }
                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 93) {
                                                  result1 = "]";
                                                  pos++;
                                                } else {
                                                  result1 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"]\"");
                                                  }
                                                }
                                                if (result1 === null) {
                                                  if (input.charCodeAt(pos) === 63) {
                                                    result1 = "?";
                                                    pos++;
                                                  } else {
                                                    result1 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"?\"");
                                                    }
                                                  }
                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 123) {
                                                      result1 = "{";
                                                      pos++;
                                                    } else {
                                                      result1 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"{\"");
                                                      }
                                                    }
                                                    if (result1 === null) {
                                                      if (input.charCodeAt(pos) === 125) {
                                                        result1 = "}";
                                                        pos++;
                                                      } else {
                                                        result1 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"}\"");
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 46) {
                  result1 = ".";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 33) {
                    result1 = "!";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 37) {
                      result1 = "%";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"%\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 42) {
                        result1 = "*";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result1 = "_";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 96) {
                              result1 = "`";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"`\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 39) {
                                result1 = "'";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"'\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 126) {
                                  result1 = "~";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"~\"");
                                  }
                                }
                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 40) {
                                    result1 = "(";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"(\"");
                                    }
                                  }
                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 41) {
                                      result1 = ")";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\")\"");
                                      }
                                    }
                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 60) {
                                        result1 = "<";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"<\"");
                                        }
                                      }
                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 62) {
                                          result1 = ">";
                                          pos++;
                                        } else {
                                          result1 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\">\"");
                                          }
                                        }
                                        if (result1 === null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result1 = ":";
                                            pos++;
                                          } else {
                                            result1 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 92) {
                                              result1 = "\\";
                                              pos++;
                                            } else {
                                              result1 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"\\\\\"");
                                              }
                                            }
                                            if (result1 === null) {
                                              result1 = parse_DQUOTE();
                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 47) {
                                                  result1 = "/";
                                                  pos++;
                                                } else {
                                                  result1 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"/\"");
                                                  }
                                                }
                                                if (result1 === null) {
                                                  if (input.charCodeAt(pos) === 91) {
                                                    result1 = "[";
                                                    pos++;
                                                  } else {
                                                    result1 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"[\"");
                                                    }
                                                  }
                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 93) {
                                                      result1 = "]";
                                                      pos++;
                                                    } else {
                                                      result1 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"]\"");
                                                      }
                                                    }
                                                    if (result1 === null) {
                                                      if (input.charCodeAt(pos) === 63) {
                                                        result1 = "?";
                                                        pos++;
                                                      } else {
                                                        result1 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"?\"");
                                                        }
                                                      }
                                                      if (result1 === null) {
                                                        if (input.charCodeAt(pos) === 123) {
                                                          result1 = "{";
                                                          pos++;
                                                        } else {
                                                          result1 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed("\"{\"");
                                                          }
                                                        }
                                                        if (result1 === null) {
                                                          if (input.charCodeAt(pos) === 125) {
                                                            result1 = "}";
                                                            pos++;
                                                          } else {
                                                            result1 = null;
                                                            if (reportFailures === 0) {
                                                              matchFailed("\"}\"");
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_STAR() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 42) {
            result1 = "*";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"*\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "*"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SLASH() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 47) {
            result1 = "/";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "/"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_EQUAL() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LPAREN() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 40) {
            result1 = "(";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "("; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RPAREN() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 41) {
            result1 = ")";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ")"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RAQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 62) {
          result0 = ">";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\">\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_SWS();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ">"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LAQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 60) {
            result1 = "<";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"<\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "<"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_COMMA() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ","; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SEMI() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_COLON() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ":"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LDQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "\""; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RDQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DQUOTE();
        if (result0 !== null) {
          result1 = parse_SWS();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "\""; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comment() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_LPAREN();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ctext();
          if (result2 === null) {
            result2 = parse_quoted_pair();
            if (result2 === null) {
              result2 = parse_comment();
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ctext();
            if (result2 === null) {
              result2 = parse_quoted_pair();
              if (result2 === null) {
                result2 = parse_comment();
              }
            }
          }
          if (result1 !== null) {
            result2 = parse_RPAREN();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ctext() {
        var result0;
        
        if (/^[!-']/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[!-']");
          }
        }
        if (result0 === null) {
          if (/^[*-[]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[*-[]");
            }
          }
          if (result0 === null) {
            if (/^[\]-~]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[\\]-~]");
              }
            }
            if (result0 === null) {
              result0 = parse_UTF8_NONASCII();
              if (result0 === null) {
                result0 = parse_LWS();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_quoted_string() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_qdtext();
            if (result3 === null) {
              result3 = parse_quoted_pair();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_qdtext();
              if (result3 === null) {
                result3 = parse_quoted_pair();
              }
            }
            if (result2 !== null) {
              result3 = parse_DQUOTE();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_quoted_string_clean() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_qdtext();
            if (result3 === null) {
              result3 = parse_quoted_pair();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_qdtext();
              if (result3 === null) {
                result3 = parse_quoted_pair();
              }
            }
            if (result2 !== null) {
              result3 = parse_DQUOTE();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                return input.substring(pos-1, offset+1); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qdtext() {
        var result0;
        
        result0 = parse_LWS();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 33) {
            result0 = "!";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"!\"");
            }
          }
          if (result0 === null) {
            if (/^[#-[]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[#-[]");
              }
            }
            if (result0 === null) {
              if (/^[\]-~]/.test(input.charAt(pos))) {
                result0 = input.charAt(pos);
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\]-~]");
                }
              }
              if (result0 === null) {
                result0 = parse_UTF8_NONASCII();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_quoted_pair() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          if (/^[\0-\t]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[\\0-\\t]");
            }
          }
          if (result1 === null) {
            if (/^[\x0B-\f]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[\\x0B-\\f]");
              }
            }
            if (result1 === null) {
              if (/^[\x0E-]/.test(input.charAt(pos))) {
                result1 = input.charAt(pos);
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\x0E-]");
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SIP_URI_noparams() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_uri_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_userinfo();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_hostport();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            try {
                                data.uri = new URI(data.scheme, data.user, data.host, data.port);
                                delete data.scheme;
                                delete data.user;
                                delete data.host;
                                delete data.host_type;
                                delete data.port;
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SIP_URI() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_uri_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_userinfo();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_hostport();
              if (result3 !== null) {
                result4 = parse_uri_parameters();
                if (result4 !== null) {
                  result5 = parse_headers();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            var header;
                            try {
                                data.uri = new URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);
                                delete data.scheme;
                                delete data.user;
                                delete data.host;
                                delete data.host_type;
                                delete data.port;
                                delete data.uri_params;
        
                                if (startRule === 'SIP_URI') { data = data.uri;}
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uri_scheme() {
        var result0;
        var pos0;
        
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"sip\"");
          }
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 4).toLowerCase() === "sips") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"sips\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {
                              data.scheme = uri_scheme.toLowerCase(); })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_userinfo() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_user();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_password();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 64) {
              result2 = "@";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"@\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.user = decodeURIComponent(input.substring(pos-1, offset));})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_user() {
        var result0, result1;
        
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            result1 = parse_user_unreserved();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                result1 = parse_user_unreserved();
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_user_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 38) {
          result0 = "&";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"&\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 61) {
            result0 = "=";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 43) {
              result0 = "+";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"+\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 36) {
                result0 = "$";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"$\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 44) {
                  result0 = ",";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 59) {
                    result0 = ";";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\";\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 63) {
                      result0 = "?";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"?\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 47) {
                        result0 = "/";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"/\"");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_password() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 38) {
              result1 = "&";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 61) {
                result1 = "=";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 43) {
                  result1 = "+";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 36) {
                    result1 = "$";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"$\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 44) {
                      result1 = ",";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\",\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 38) {
                result1 = "&";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 61) {
                  result1 = "=";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result1 = "+";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result1 = "$";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 44) {
                        result1 = ",";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\",\"");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.password = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hostport() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_host();
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_hostname();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host = input.substring(pos, offset).toLowerCase();
                            return data.host; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hostname() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        pos2 = pos;
        result1 = parse_domainlabel();
        if (result1 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result2 = ".";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result2 !== null) {
            result1 = [result1, result2];
          } else {
            result1 = null;
            pos = pos2;
          }
        } else {
          result1 = null;
          pos = pos2;
        }
        while (result1 !== null) {
          result0.push(result1);
          pos2 = pos;
          result1 = parse_domainlabel();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
        }
        if (result0 !== null) {
          result1 = parse_toplabel();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.host_type = 'domain';
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_domainlabel() {
        var result0, result1;
        
        if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_\\-]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z0-9_\\-]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_toplabel() {
        var result0, result1;
        
        if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_\\-]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z0-9_\\-]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_IPv6reference() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_IPv6address();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 93) {
              result2 = "]";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host_type = 'IPv6';
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_IPv6address() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_h16();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_h16();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result3 = ":";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_h16();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result5 = ":";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_h16();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result7 = ":";
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result7 !== null) {
                        result8 = parse_h16();
                        if (result8 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result9 = ":";
                            pos++;
                          } else {
                            result9 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result9 !== null) {
                            result10 = parse_h16();
                            if (result10 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result11 = ":";
                                pos++;
                              } else {
                                result11 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result11 !== null) {
                                result12 = parse_ls32();
                                if (result12 !== null) {
                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          pos1 = pos;
          if (input.substr(pos, 2) === "::") {
            result0 = "::";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"::\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_h16();
            if (result1 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result2 = ":";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result2 !== null) {
                result3 = parse_h16();
                if (result3 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result4 = ":";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result4 !== null) {
                    result5 = parse_h16();
                    if (result5 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result6 = ":";
                        pos++;
                      } else {
                        result6 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result6 !== null) {
                        result7 = parse_h16();
                        if (result7 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result8 = ":";
                            pos++;
                          } else {
                            result8 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result8 !== null) {
                            result9 = parse_h16();
                            if (result9 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result10 = ":";
                                pos++;
                              } else {
                                result10 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result10 !== null) {
                                result11 = parse_ls32();
                                if (result11 !== null) {
                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 === null) {
            pos1 = pos;
            if (input.substr(pos, 2) === "::") {
              result0 = "::";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"::\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_h16();
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 58) {
                  result2 = ":";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result2 !== null) {
                  result3 = parse_h16();
                  if (result3 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result4 = ":";
                      pos++;
                    } else {
                      result4 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result4 !== null) {
                      result5 = parse_h16();
                      if (result5 !== null) {
                        if (input.charCodeAt(pos) === 58) {
                          result6 = ":";
                          pos++;
                        } else {
                          result6 = null;
                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }
                        if (result6 !== null) {
                          result7 = parse_h16();
                          if (result7 !== null) {
                            if (input.charCodeAt(pos) === 58) {
                              result8 = ":";
                              pos++;
                            } else {
                              result8 = null;
                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }
                            if (result8 !== null) {
                              result9 = parse_ls32();
                              if (result9 !== null) {
                                result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              if (input.substr(pos, 2) === "::") {
                result0 = "::";
                pos += 2;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"::\"");
                }
              }
              if (result0 !== null) {
                result1 = parse_h16();
                if (result1 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result2 = ":";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result2 !== null) {
                    result3 = parse_h16();
                    if (result3 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result4 = ":";
                        pos++;
                      } else {
                        result4 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result4 !== null) {
                        result5 = parse_h16();
                        if (result5 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result6 = ":";
                            pos++;
                          } else {
                            result6 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result6 !== null) {
                            result7 = parse_ls32();
                            if (result7 !== null) {
                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 === null) {
                pos1 = pos;
                if (input.substr(pos, 2) === "::") {
                  result0 = "::";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"::\"");
                  }
                }
                if (result0 !== null) {
                  result1 = parse_h16();
                  if (result1 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result2 = ":";
                      pos++;
                    } else {
                      result2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result2 !== null) {
                      result3 = parse_h16();
                      if (result3 !== null) {
                        if (input.charCodeAt(pos) === 58) {
                          result4 = ":";
                          pos++;
                        } else {
                          result4 = null;
                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }
                        if (result4 !== null) {
                          result5 = parse_ls32();
                          if (result5 !== null) {
                            result0 = [result0, result1, result2, result3, result4, result5];
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 === null) {
                  pos1 = pos;
                  if (input.substr(pos, 2) === "::") {
                    result0 = "::";
                    pos += 2;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"::\"");
                    }
                  }
                  if (result0 !== null) {
                    result1 = parse_h16();
                    if (result1 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result2 = ":";
                        pos++;
                      } else {
                        result2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result2 !== null) {
                        result3 = parse_ls32();
                        if (result3 !== null) {
                          result0 = [result0, result1, result2, result3];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                  if (result0 === null) {
                    pos1 = pos;
                    if (input.substr(pos, 2) === "::") {
                      result0 = "::";
                      pos += 2;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"::\"");
                      }
                    }
                    if (result0 !== null) {
                      result1 = parse_ls32();
                      if (result1 !== null) {
                        result0 = [result0, result1];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                    if (result0 === null) {
                      pos1 = pos;
                      if (input.substr(pos, 2) === "::") {
                        result0 = "::";
                        pos += 2;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"::\"");
                        }
                      }
                      if (result0 !== null) {
                        result1 = parse_h16();
                        if (result1 !== null) {
                          result0 = [result0, result1];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                      if (result0 === null) {
                        pos1 = pos;
                        result0 = parse_h16();
                        if (result0 !== null) {
                          if (input.substr(pos, 2) === "::") {
                            result1 = "::";
                            pos += 2;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"::\"");
                            }
                          }
                          if (result1 !== null) {
                            result2 = parse_h16();
                            if (result2 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result3 = ":";
                                pos++;
                              } else {
                                result3 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result3 !== null) {
                                result4 = parse_h16();
                                if (result4 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result5 = ":";
                                    pos++;
                                  } else {
                                    result5 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result5 !== null) {
                                    result6 = parse_h16();
                                    if (result6 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result7 = ":";
                                        pos++;
                                      } else {
                                        result7 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result7 !== null) {
                                        result8 = parse_h16();
                                        if (result8 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result9 = ":";
                                            pos++;
                                          } else {
                                            result9 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result9 !== null) {
                                            result10 = parse_ls32();
                                            if (result10 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                        if (result0 === null) {
                          pos1 = pos;
                          result0 = parse_h16();
                          if (result0 !== null) {
                            pos2 = pos;
                            if (input.charCodeAt(pos) === 58) {
                              result1 = ":";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }
                            if (result1 !== null) {
                              result2 = parse_h16();
                              if (result2 !== null) {
                                result1 = [result1, result2];
                              } else {
                                result1 = null;
                                pos = pos2;
                              }
                            } else {
                              result1 = null;
                              pos = pos2;
                            }
                            result1 = result1 !== null ? result1 : "";
                            if (result1 !== null) {
                              if (input.substr(pos, 2) === "::") {
                                result2 = "::";
                                pos += 2;
                              } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"::\"");
                                }
                              }
                              if (result2 !== null) {
                                result3 = parse_h16();
                                if (result3 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result4 = ":";
                                    pos++;
                                  } else {
                                    result4 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result4 !== null) {
                                    result5 = parse_h16();
                                    if (result5 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result6 = ":";
                                        pos++;
                                      } else {
                                        result6 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result6 !== null) {
                                        result7 = parse_h16();
                                        if (result7 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result8 = ":";
                                            pos++;
                                          } else {
                                            result8 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result8 !== null) {
                                            result9 = parse_ls32();
                                            if (result9 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                          if (result0 === null) {
                            pos1 = pos;
                            result0 = parse_h16();
                            if (result0 !== null) {
                              pos2 = pos;
                              if (input.charCodeAt(pos) === 58) {
                                result1 = ":";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result1 !== null) {
                                result2 = parse_h16();
                                if (result2 !== null) {
                                  result1 = [result1, result2];
                                } else {
                                  result1 = null;
                                  pos = pos2;
                                }
                              } else {
                                result1 = null;
                                pos = pos2;
                              }
                              result1 = result1 !== null ? result1 : "";
                              if (result1 !== null) {
                                pos2 = pos;
                                if (input.charCodeAt(pos) === 58) {
                                  result2 = ":";
                                  pos++;
                                } else {
                                  result2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }
                                if (result2 !== null) {
                                  result3 = parse_h16();
                                  if (result3 !== null) {
                                    result2 = [result2, result3];
                                  } else {
                                    result2 = null;
                                    pos = pos2;
                                  }
                                } else {
                                  result2 = null;
                                  pos = pos2;
                                }
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                  if (input.substr(pos, 2) === "::") {
                                    result3 = "::";
                                    pos += 2;
                                  } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"::\"");
                                    }
                                  }
                                  if (result3 !== null) {
                                    result4 = parse_h16();
                                    if (result4 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result5 = ":";
                                        pos++;
                                      } else {
                                        result5 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result5 !== null) {
                                        result6 = parse_h16();
                                        if (result6 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result7 = ":";
                                            pos++;
                                          } else {
                                            result7 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result7 !== null) {
                                            result8 = parse_ls32();
                                            if (result8 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                            if (result0 === null) {
                              pos1 = pos;
                              result0 = parse_h16();
                              if (result0 !== null) {
                                pos2 = pos;
                                if (input.charCodeAt(pos) === 58) {
                                  result1 = ":";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }
                                if (result1 !== null) {
                                  result2 = parse_h16();
                                  if (result2 !== null) {
                                    result1 = [result1, result2];
                                  } else {
                                    result1 = null;
                                    pos = pos2;
                                  }
                                } else {
                                  result1 = null;
                                  pos = pos2;
                                }
                                result1 = result1 !== null ? result1 : "";
                                if (result1 !== null) {
                                  pos2 = pos;
                                  if (input.charCodeAt(pos) === 58) {
                                    result2 = ":";
                                    pos++;
                                  } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result2 !== null) {
                                    result3 = parse_h16();
                                    if (result3 !== null) {
                                      result2 = [result2, result3];
                                    } else {
                                      result2 = null;
                                      pos = pos2;
                                    }
                                  } else {
                                    result2 = null;
                                    pos = pos2;
                                  }
                                  result2 = result2 !== null ? result2 : "";
                                  if (result2 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result3 = ":";
                                      pos++;
                                    } else {
                                      result3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result3 !== null) {
                                      result4 = parse_h16();
                                      if (result4 !== null) {
                                        result3 = [result3, result4];
                                      } else {
                                        result3 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result3 = null;
                                      pos = pos2;
                                    }
                                    result3 = result3 !== null ? result3 : "";
                                    if (result3 !== null) {
                                      if (input.substr(pos, 2) === "::") {
                                        result4 = "::";
                                        pos += 2;
                                      } else {
                                        result4 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"::\"");
                                        }
                                      }
                                      if (result4 !== null) {
                                        result5 = parse_h16();
                                        if (result5 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result6 = ":";
                                            pos++;
                                          } else {
                                            result6 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result6 !== null) {
                                            result7 = parse_ls32();
                                            if (result7 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                              if (result0 === null) {
                                pos1 = pos;
                                result0 = parse_h16();
                                if (result0 !== null) {
                                  pos2 = pos;
                                  if (input.charCodeAt(pos) === 58) {
                                    result1 = ":";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result1 !== null) {
                                    result2 = parse_h16();
                                    if (result2 !== null) {
                                      result1 = [result1, result2];
                                    } else {
                                      result1 = null;
                                      pos = pos2;
                                    }
                                  } else {
                                    result1 = null;
                                    pos = pos2;
                                  }
                                  result1 = result1 !== null ? result1 : "";
                                  if (result1 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result2 = ":";
                                      pos++;
                                    } else {
                                      result2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result2 !== null) {
                                      result3 = parse_h16();
                                      if (result3 !== null) {
                                        result2 = [result2, result3];
                                      } else {
                                        result2 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result2 = null;
                                      pos = pos2;
                                    }
                                    result2 = result2 !== null ? result2 : "";
                                    if (result2 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result3 = ":";
                                        pos++;
                                      } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result3 !== null) {
                                        result4 = parse_h16();
                                        if (result4 !== null) {
                                          result3 = [result3, result4];
                                        } else {
                                          result3 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result3 = null;
                                        pos = pos2;
                                      }
                                      result3 = result3 !== null ? result3 : "";
                                      if (result3 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result4 = ":";
                                          pos++;
                                        } else {
                                          result4 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result4 !== null) {
                                          result5 = parse_h16();
                                          if (result5 !== null) {
                                            result4 = [result4, result5];
                                          } else {
                                            result4 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result4 = null;
                                          pos = pos2;
                                        }
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                          if (input.substr(pos, 2) === "::") {
                                            result5 = "::";
                                            pos += 2;
                                          } else {
                                            result5 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"::\"");
                                            }
                                          }
                                          if (result5 !== null) {
                                            result6 = parse_ls32();
                                            if (result6 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                                if (result0 === null) {
                                  pos1 = pos;
                                  result0 = parse_h16();
                                  if (result0 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result1 = ":";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result1 !== null) {
                                      result2 = parse_h16();
                                      if (result2 !== null) {
                                        result1 = [result1, result2];
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result1 = null;
                                      pos = pos2;
                                    }
                                    result1 = result1 !== null ? result1 : "";
                                    if (result1 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result2 = ":";
                                        pos++;
                                      } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result2 !== null) {
                                        result3 = parse_h16();
                                        if (result3 !== null) {
                                          result2 = [result2, result3];
                                        } else {
                                          result2 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result2 = null;
                                        pos = pos2;
                                      }
                                      result2 = result2 !== null ? result2 : "";
                                      if (result2 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result3 = ":";
                                          pos++;
                                        } else {
                                          result3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result3 !== null) {
                                          result4 = parse_h16();
                                          if (result4 !== null) {
                                            result3 = [result3, result4];
                                          } else {
                                            result3 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result3 = null;
                                          pos = pos2;
                                        }
                                        result3 = result3 !== null ? result3 : "";
                                        if (result3 !== null) {
                                          pos2 = pos;
                                          if (input.charCodeAt(pos) === 58) {
                                            result4 = ":";
                                            pos++;
                                          } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result4 !== null) {
                                            result5 = parse_h16();
                                            if (result5 !== null) {
                                              result4 = [result4, result5];
                                            } else {
                                              result4 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result4 = null;
                                            pos = pos2;
                                          }
                                          result4 = result4 !== null ? result4 : "";
                                          if (result4 !== null) {
                                            pos2 = pos;
                                            if (input.charCodeAt(pos) === 58) {
                                              result5 = ":";
                                              pos++;
                                            } else {
                                              result5 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }
                                            if (result5 !== null) {
                                              result6 = parse_h16();
                                              if (result6 !== null) {
                                                result5 = [result5, result6];
                                              } else {
                                                result5 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result5 = null;
                                              pos = pos2;
                                            }
                                            result5 = result5 !== null ? result5 : "";
                                            if (result5 !== null) {
                                              if (input.substr(pos, 2) === "::") {
                                                result6 = "::";
                                                pos += 2;
                                              } else {
                                                result6 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"::\"");
                                                }
                                              }
                                              if (result6 !== null) {
                                                result7 = parse_h16();
                                                if (result7 !== null) {
                                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                  if (result0 === null) {
                                    pos1 = pos;
                                    result0 = parse_h16();
                                    if (result0 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result1 = ":";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result1 !== null) {
                                        result2 = parse_h16();
                                        if (result2 !== null) {
                                          result1 = [result1, result2];
                                        } else {
                                          result1 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }
                                      result1 = result1 !== null ? result1 : "";
                                      if (result1 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result2 = ":";
                                          pos++;
                                        } else {
                                          result2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result2 !== null) {
                                          result3 = parse_h16();
                                          if (result3 !== null) {
                                            result2 = [result2, result3];
                                          } else {
                                            result2 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result2 = null;
                                          pos = pos2;
                                        }
                                        result2 = result2 !== null ? result2 : "";
                                        if (result2 !== null) {
                                          pos2 = pos;
                                          if (input.charCodeAt(pos) === 58) {
                                            result3 = ":";
                                            pos++;
                                          } else {
                                            result3 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result3 !== null) {
                                            result4 = parse_h16();
                                            if (result4 !== null) {
                                              result3 = [result3, result4];
                                            } else {
                                              result3 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result3 = null;
                                            pos = pos2;
                                          }
                                          result3 = result3 !== null ? result3 : "";
                                          if (result3 !== null) {
                                            pos2 = pos;
                                            if (input.charCodeAt(pos) === 58) {
                                              result4 = ":";
                                              pos++;
                                            } else {
                                              result4 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }
                                            if (result4 !== null) {
                                              result5 = parse_h16();
                                              if (result5 !== null) {
                                                result4 = [result4, result5];
                                              } else {
                                                result4 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result4 = null;
                                              pos = pos2;
                                            }
                                            result4 = result4 !== null ? result4 : "";
                                            if (result4 !== null) {
                                              pos2 = pos;
                                              if (input.charCodeAt(pos) === 58) {
                                                result5 = ":";
                                                pos++;
                                              } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }
                                              if (result5 !== null) {
                                                result6 = parse_h16();
                                                if (result6 !== null) {
                                                  result5 = [result5, result6];
                                                } else {
                                                  result5 = null;
                                                  pos = pos2;
                                                }
                                              } else {
                                                result5 = null;
                                                pos = pos2;
                                              }
                                              result5 = result5 !== null ? result5 : "";
                                              if (result5 !== null) {
                                                pos2 = pos;
                                                if (input.charCodeAt(pos) === 58) {
                                                  result6 = ":";
                                                  pos++;
                                                } else {
                                                  result6 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\":\"");
                                                  }
                                                }
                                                if (result6 !== null) {
                                                  result7 = parse_h16();
                                                  if (result7 !== null) {
                                                    result6 = [result6, result7];
                                                  } else {
                                                    result6 = null;
                                                    pos = pos2;
                                                  }
                                                } else {
                                                  result6 = null;
                                                  pos = pos2;
                                                }
                                                result6 = result6 !== null ? result6 : "";
                                                if (result6 !== null) {
                                                  if (input.substr(pos, 2) === "::") {
                                                    result7 = "::";
                                                    pos += 2;
                                                  } else {
                                                    result7 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"::\"");
                                                    }
                                                  }
                                                  if (result7 !== null) {
                                                    result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.host_type = 'IPv6';
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_h16() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_HEXDIG();
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_HEXDIG();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ls32() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_h16();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_h16();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_IPv4address();
        }
        return result0;
      }
      
      function parse_IPv4address() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_dec_octet();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_dec_octet();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 46) {
                result3 = ".";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_dec_octet();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 46) {
                    result5 = ".";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_dec_octet();
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host_type = 'IPv4';
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_dec_octet() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "25") {
          result0 = "25";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"25\"");
          }
        }
        if (result0 !== null) {
          if (/^[0-5]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[0-5]");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 50) {
            result0 = "2";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"2\"");
            }
          }
          if (result0 !== null) {
            if (/^[0-4]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-4]");
              }
            }
            if (result1 !== null) {
              result2 = parse_DIGIT();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.charCodeAt(pos) === 49) {
              result0 = "1";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"1\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_DIGIT();
              if (result1 !== null) {
                result2 = parse_DIGIT();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (/^[1-9]/.test(input.charAt(pos))) {
                result0 = input.charAt(pos);
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result0 !== null) {
                result1 = parse_DIGIT();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
              if (result0 === null) {
                result0 = parse_DIGIT();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_port() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, port) {
                            port = parseInt(port.join(''));
                            data.port = port;
                            return port; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uri_parameters() {
        var result0, result1, result2;
        var pos0;
        
        result0 = [];
        pos0 = pos;
        if (input.charCodeAt(pos) === 59) {
          result1 = ";";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result1 !== null) {
          result2 = parse_uri_parameter();
          if (result2 !== null) {
            result1 = [result1, result2];
          } else {
            result1 = null;
            pos = pos0;
          }
        } else {
          result1 = null;
          pos = pos0;
        }
        while (result1 !== null) {
          result0.push(result1);
          pos0 = pos;
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_uri_parameter();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos0;
            }
          } else {
            result1 = null;
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_uri_parameter() {
        var result0;
        
        result0 = parse_transport_param();
        if (result0 === null) {
          result0 = parse_user_param();
          if (result0 === null) {
            result0 = parse_method_param();
            if (result0 === null) {
              result0 = parse_ttl_param();
              if (result0 === null) {
                result0 = parse_maddr_param();
                if (result0 === null) {
                  result0 = parse_lr_param();
                  if (result0 === null) {
                    result0 = parse_other_param();
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_transport_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 10).toLowerCase() === "transport=") {
          result0 = input.substr(pos, 10);
          pos += 10;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"transport=\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 3).toLowerCase() === "udp") {
            result1 = input.substr(pos, 3);
            pos += 3;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"udp\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tcp") {
              result1 = input.substr(pos, 3);
              pos += 3;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"tcp\"");
              }
            }
            if (result1 === null) {
              if (input.substr(pos, 4).toLowerCase() === "sctp") {
                result1 = input.substr(pos, 4);
                pos += 4;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"sctp\"");
                }
              }
              if (result1 === null) {
                if (input.substr(pos, 3).toLowerCase() === "tls") {
                  result1 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"tls\"");
                  }
                }
                if (result1 === null) {
                  result1 = parse_token();
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, transport) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['transport'] = transport.toLowerCase(); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_user_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "user=") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"user=\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 5).toLowerCase() === "phone") {
            result1 = input.substr(pos, 5);
            pos += 5;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"phone\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 2).toLowerCase() === "ip") {
              result1 = input.substr(pos, 2);
              pos += 2;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"ip\"");
              }
            }
            if (result1 === null) {
              result1 = parse_token();
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, user) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['user'] = user.toLowerCase(); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_method_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 7).toLowerCase() === "method=") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"method=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_Method();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, method) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['method'] = method; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ttl_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 4).toLowerCase() === "ttl=") {
          result0 = input.substr(pos, 4);
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ttl=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_ttl();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ttl) {
                              if(!data.params) data.params={};
                              data.params['ttl'] = ttl; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_maddr_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "maddr=") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"maddr=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_host();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, maddr) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['maddr'] = maddr; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_lr_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2).toLowerCase() === "lr") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"lr\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['lr'] = undefined; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_other_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_pname();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_pvalue();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, param, value) {
                              if(!data.uri_params) data.uri_params = {};
                              if (typeof value === 'undefined'){
                                value = undefined;
                              }
                              else {
                                value = value[1];
                              }
                              data.uri_params[param.toLowerCase()] = value && value.toLowerCase();})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_pname() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_paramchar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_paramchar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, pname) {return pname.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_pvalue() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_paramchar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_paramchar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, pvalue) {return pvalue.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_paramchar() {
        var result0;
        
        result0 = parse_param_unreserved();
        if (result0 === null) {
          result0 = parse_unreserved();
          if (result0 === null) {
            result0 = parse_escaped();
          }
        }
        return result0;
      }
      
      function parse_param_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 47) {
              result0 = "/";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 58) {
                result0 = ":";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 38) {
                  result0 = "&";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"&\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result0 = "+";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result0 = "$";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_headers() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 63) {
          result0 = "?";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_header();
          if (result1 !== null) {
            result2 = [];
            pos1 = pos;
            if (input.charCodeAt(pos) === 38) {
              result3 = "&";
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result3 !== null) {
              result4 = parse_header();
              if (result4 !== null) {
                result3 = [result3, result4];
              } else {
                result3 = null;
                pos = pos1;
              }
            } else {
              result3 = null;
              pos = pos1;
            }
            while (result3 !== null) {
              result2.push(result3);
              pos1 = pos;
              if (input.charCodeAt(pos) === 38) {
                result3 = "&";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_header();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_header() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_hname();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hvalue();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, hname, hvalue) {
                              hname = hname.join('').toLowerCase();
                              hvalue = hvalue.join('');
                              if(!data.uri_headers) data.uri_headers = {};
                              if (!data.uri_headers[hname]) {
                                data.uri_headers[hname] = [hvalue];
                              } else {
                                data.uri_headers[hname].push(hvalue);
                              }})(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hname() {
        var result0, result1;
        
        result1 = parse_hnv_unreserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_hnv_unreserved();
            if (result1 === null) {
              result1 = parse_unreserved();
              if (result1 === null) {
                result1 = parse_escaped();
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_hvalue() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_hnv_unreserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_hnv_unreserved();
          if (result1 === null) {
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
            }
          }
        }
        return result0;
      }
      
      function parse_hnv_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 47) {
              result0 = "/";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 63) {
                result0 = "?";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 58) {
                  result0 = ":";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result0 = "+";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result0 = "$";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Request_Response() {
        var result0;
        
        result0 = parse_Status_Line();
        if (result0 === null) {
          result0 = parse_Request_Line();
        }
        return result0;
      }
      
      function parse_Request_Line() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Method();
        if (result0 !== null) {
          result1 = parse_SP();
          if (result1 !== null) {
            result2 = parse_Request_URI();
            if (result2 !== null) {
              result3 = parse_SP();
              if (result3 !== null) {
                result4 = parse_SIP_Version();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Request_URI() {
        var result0;
        
        result0 = parse_SIP_URI();
        if (result0 === null) {
          result0 = parse_absoluteURI();
        }
        return result0;
      }
      
      function parse_absoluteURI() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hier_part();
            if (result2 === null) {
              result2 = parse_opaque_part();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hier_part() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_net_path();
        if (result0 === null) {
          result0 = parse_abs_path();
        }
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 63) {
            result1 = "?";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"?\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_query();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_net_path() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_authority();
          if (result1 !== null) {
            result2 = parse_abs_path();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_abs_path() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_path_segments();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_opaque_part() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_uric_no_slash();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_uric();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_uric();
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uric() {
        var result0;
        
        result0 = parse_reserved();
        if (result0 === null) {
          result0 = parse_unreserved();
          if (result0 === null) {
            result0 = parse_escaped();
          }
        }
        return result0;
      }
      
      function parse_uric_no_slash() {
        var result0;
        
        result0 = parse_unreserved();
        if (result0 === null) {
          result0 = parse_escaped();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 59) {
              result0 = ";";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 63) {
                result0 = "?";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 58) {
                  result0 = ":";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 64) {
                    result0 = "@";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"@\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 38) {
                      result0 = "&";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"&\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 61) {
                        result0 = "=";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"=\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result0 = "+";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 36) {
                            result0 = "$";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"$\"");
                            }
                          }
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 44) {
                              result0 = ",";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\",\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_path_segments() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_segment();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 47) {
            result2 = "/";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_segment();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 47) {
              result2 = "/";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_segment();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_segment() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_pchar();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_pchar();
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 59) {
            result2 = ";";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 59) {
              result2 = ";";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_param() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_pchar();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_pchar();
        }
        return result0;
      }
      
      function parse_pchar() {
        var result0;
        
        result0 = parse_unreserved();
        if (result0 === null) {
          result0 = parse_escaped();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 58) {
              result0 = ":";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 64) {
                result0 = "@";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"@\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 38) {
                  result0 = "&";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"&\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 61) {
                    result0 = "=";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 43) {
                      result0 = "+";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 36) {
                        result0 = "$";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"$\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 44) {
                          result0 = ",";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_scheme() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ALPHA();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ALPHA();
          if (result2 === null) {
            result2 = parse_DIGIT();
            if (result2 === null) {
              if (input.charCodeAt(pos) === 43) {
                result2 = "+";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"+\"");
                }
              }
              if (result2 === null) {
                if (input.charCodeAt(pos) === 45) {
                  result2 = "-";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 46) {
                    result2 = ".";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                }
              }
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ALPHA();
            if (result2 === null) {
              result2 = parse_DIGIT();
              if (result2 === null) {
                if (input.charCodeAt(pos) === 43) {
                  result2 = "+";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 45) {
                    result2 = "-";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }
                  if (result2 === null) {
                    if (input.charCodeAt(pos) === 46) {
                      result2 = ".";
                      pos++;
                    } else {
                      result2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.scheme= input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_authority() {
        var result0;
        
        result0 = parse_srvr();
        if (result0 === null) {
          result0 = parse_reg_name();
        }
        return result0;
      }
      
      function parse_srvr() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_userinfo();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 64) {
            result1 = "@";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_hostport();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_reg_name() {
        var result0, result1;
        
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 36) {
              result1 = "$";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"$\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 44) {
                result1 = ",";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 59) {
                  result1 = ";";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\";\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 64) {
                      result1 = "@";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"@\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 38) {
                        result1 = "&";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"&\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 61) {
                          result1 = "=";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"=\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                if (input.charCodeAt(pos) === 36) {
                  result1 = "$";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"$\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 44) {
                    result1 = ",";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 59) {
                      result1 = ";";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result1 = ":";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 64) {
                          result1 = "@";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"@\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 38) {
                            result1 = "&";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"&\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 61) {
                              result1 = "=";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"=\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 43) {
                                result1 = "+";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"+\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_query() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_uric();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_uric();
        }
        return result0;
      }
      
      function parse_SIP_Version() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SIP\"");
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 47) {
            result1 = "/";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result1 !== null) {
            result3 = parse_DIGIT();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_DIGIT();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 46) {
                result3 = ".";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result3 !== null) {
                result5 = parse_DIGIT();
                if (result5 !== null) {
                  result4 = [];
                  while (result5 !== null) {
                    result4.push(result5);
                    result5 = parse_DIGIT();
                  }
                } else {
                  result4 = null;
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.sip_version = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_INVITEm() {
        var result0;
        
        if (input.substr(pos, 6) === "INVITE") {
          result0 = "INVITE";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"INVITE\"");
          }
        }
        return result0;
      }
      
      function parse_ACKm() {
        var result0;
        
        if (input.substr(pos, 3) === "ACK") {
          result0 = "ACK";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ACK\"");
          }
        }
        return result0;
      }
      
      function parse_OPTIONSm() {
        var result0;
        
        if (input.substr(pos, 7) === "OPTIONS") {
          result0 = "OPTIONS";
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"OPTIONS\"");
          }
        }
        return result0;
      }
      
      function parse_BYEm() {
        var result0;
        
        if (input.substr(pos, 3) === "BYE") {
          result0 = "BYE";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"BYE\"");
          }
        }
        return result0;
      }
      
      function parse_CANCELm() {
        var result0;
        
        if (input.substr(pos, 6) === "CANCEL") {
          result0 = "CANCEL";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"CANCEL\"");
          }
        }
        return result0;
      }
      
      function parse_REGISTERm() {
        var result0;
        
        if (input.substr(pos, 8) === "REGISTER") {
          result0 = "REGISTER";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"REGISTER\"");
          }
        }
        return result0;
      }
      
      function parse_SUBSCRIBEm() {
        var result0;
        
        if (input.substr(pos, 9) === "SUBSCRIBE") {
          result0 = "SUBSCRIBE";
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SUBSCRIBE\"");
          }
        }
        return result0;
      }
      
      function parse_NOTIFYm() {
        var result0;
        
        if (input.substr(pos, 6) === "NOTIFY") {
          result0 = "NOTIFY";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"NOTIFY\"");
          }
        }
        return result0;
      }
      
      function parse_Method() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_INVITEm();
        if (result0 === null) {
          result0 = parse_ACKm();
          if (result0 === null) {
            result0 = parse_OPTIONSm();
            if (result0 === null) {
              result0 = parse_BYEm();
              if (result0 === null) {
                result0 = parse_CANCELm();
                if (result0 === null) {
                  result0 = parse_REGISTERm();
                  if (result0 === null) {
                    result0 = parse_SUBSCRIBEm();
                    if (result0 === null) {
                      result0 = parse_NOTIFYm();
                      if (result0 === null) {
                        result0 = parse_token();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.method = input.substring(pos, offset);
                            return data.method; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Status_Line() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_SIP_Version();
        if (result0 !== null) {
          result1 = parse_SP();
          if (result1 !== null) {
            result2 = parse_Status_Code();
            if (result2 !== null) {
              result3 = parse_SP();
              if (result3 !== null) {
                result4 = parse_Reason_Phrase();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Status_Code() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_extension_code();
        if (result0 !== null) {
          result0 = (function(offset, status_code) {
                          data.status_code = parseInt(status_code.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_extension_code() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_DIGIT();
        if (result0 !== null) {
          result1 = parse_DIGIT();
          if (result1 !== null) {
            result2 = parse_DIGIT();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Reason_Phrase() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_reserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              result1 = parse_UTF8_NONASCII();
              if (result1 === null) {
                result1 = parse_UTF8_CONT();
                if (result1 === null) {
                  result1 = parse_SP();
                  if (result1 === null) {
                    result1 = parse_HTAB();
                  }
                }
              }
            }
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_reserved();
          if (result1 === null) {
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                result1 = parse_UTF8_NONASCII();
                if (result1 === null) {
                  result1 = parse_UTF8_CONT();
                  if (result1 === null) {
                    result1 = parse_SP();
                    if (result1 === null) {
                      result1 = parse_HTAB();
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.reason_phrase = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Allow_Events() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_event_type();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_event_type();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_event_type();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Call_ID() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_word();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 64) {
            result1 = "@";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_word();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                      data = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Contact() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        result0 = parse_STAR();
        if (result0 === null) {
          pos1 = pos;
          result0 = parse_contact_param();
          if (result0 !== null) {
            result1 = [];
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_contact_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            while (result2 !== null) {
              result1.push(result2);
              pos2 = pos;
              result2 = parse_COMMA();
              if (result2 !== null) {
                result3 = parse_contact_param();
                if (result3 !== null) {
                  result2 = [result2, result3];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                var idx, length;
                                length = data.multi_header.length;
                                for (idx = 0; idx < length; idx++) {
                                  if (data.multi_header[idx].parsed === null) {
                                    data = null;
                                    break;
                                  }
                                }
                                if (data !== null) {
                                  data = data.multi_header;
                                } else {
                                  data = -1;
                                }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_contact_param() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_contact_params();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_contact_params();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                var header;
                                if(!data.multi_header) data.multi_header = [];
                                try {
                                  header = new NameAddrHeader(data.uri, data.display_name, data.params);
                                  delete data.uri;
                                  delete data.display_name;
                                  delete data.params;
                                } catch(e) {
                                  header = null;
                                }
                                data.multi_header.push( { 'possition': pos,
                                                          'offset': offset,
                                                          'parsed': header
                                                        });})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_name_addr() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_display_name();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_LAQUOT();
          if (result1 !== null) {
            result2 = parse_SIP_URI();
            if (result2 !== null) {
              result3 = parse_RAQUOT();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_display_name() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_LWS();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_LWS();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          result0 = parse_quoted_string();
        }
        if (result0 !== null) {
          result0 = (function(offset, display_name) {
                                display_name = input.substring(pos, offset).trim();
                                if (display_name[0] === '\"') {
                                  display_name = display_name.substring(1, display_name.length-1);
                                }
                                data.display_name = display_name; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_contact_params() {
        var result0;
        
        result0 = parse_c_p_q();
        if (result0 === null) {
          result0 = parse_c_p_expires();
          if (result0 === null) {
            result0 = parse_generic_param();
          }
        }
        return result0;
      }
      
      function parse_c_p_q() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 1).toLowerCase() === "q") {
          result0 = input.substr(pos, 1);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"q\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_qvalue();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, q) {
                                if(!data.params) data.params = {};
                                data.params['q'] = q; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_c_p_expires() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 7).toLowerCase() === "expires") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"expires\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_delta_seconds();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, expires) {
                                if(!data.params) data.params = {};
                                data.params['expires'] = expires; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_delta_seconds() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, delta_seconds) {
                                return parseInt(delta_seconds.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qvalue() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result1 = [result1, result2, result3, result4];
                } else {
                  result1 = null;
                  pos = pos2;
                }
              } else {
                result1 = null;
                pos = pos2;
              }
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                return parseFloat(input.substring(pos, offset)); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_generic_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          pos2 = pos;
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_gen_value();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, param, value) {
                                if(!data.params) data.params = {};
                                if (typeof value === 'undefined'){
                                  value = undefined;
                                }
                                else {
                                  value = value[1];
                                }
                                data.params[param.toLowerCase()] = value;})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_gen_value() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_host();
          if (result0 === null) {
            result0 = parse_quoted_string();
          }
        }
        return result0;
      }
      
      function parse_Content_Disposition() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_disp_type();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_disp_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_disp_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_disp_type() {
        var result0;
        
        if (input.substr(pos, 6).toLowerCase() === "render") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"render\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7).toLowerCase() === "session") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"session\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 4).toLowerCase() === "icon") {
              result0 = input.substr(pos, 4);
              pos += 4;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"icon\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5).toLowerCase() === "alert") {
                result0 = input.substr(pos, 5);
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"alert\"");
                }
              }
              if (result0 === null) {
                result0 = parse_token();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_disp_param() {
        var result0;
        
        result0 = parse_handling_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_handling_param() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 8).toLowerCase() === "handling") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"handling\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            if (input.substr(pos, 8).toLowerCase() === "optional") {
              result2 = input.substr(pos, 8);
              pos += 8;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"optional\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8).toLowerCase() === "required") {
                result2 = input.substr(pos, 8);
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"required\"");
                }
              }
              if (result2 === null) {
                result2 = parse_token();
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Encoding() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Length() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, length) {
                                data = parseInt(length.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Type() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_media_type();
        if (result0 !== null) {
          result0 = (function(offset) {
                                data = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_media_type() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_m_type();
        if (result0 !== null) {
          result1 = parse_SLASH();
          if (result1 !== null) {
            result2 = parse_m_subtype();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_SEMI();
              if (result4 !== null) {
                result5 = parse_m_parameter();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_SEMI();
                if (result4 !== null) {
                  result5 = parse_m_parameter();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_type() {
        var result0;
        
        result0 = parse_discrete_type();
        if (result0 === null) {
          result0 = parse_composite_type();
        }
        return result0;
      }
      
      function parse_discrete_type() {
        var result0;
        
        if (input.substr(pos, 4).toLowerCase() === "text") {
          result0 = input.substr(pos, 4);
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"text\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 5).toLowerCase() === "image") {
            result0 = input.substr(pos, 5);
            pos += 5;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"image\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 5).toLowerCase() === "audio") {
              result0 = input.substr(pos, 5);
              pos += 5;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"audio\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5).toLowerCase() === "video") {
                result0 = input.substr(pos, 5);
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"video\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 11).toLowerCase() === "application") {
                  result0 = input.substr(pos, 11);
                  pos += 11;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"application\"");
                  }
                }
                if (result0 === null) {
                  result0 = parse_extension_token();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_composite_type() {
        var result0;
        
        if (input.substr(pos, 7).toLowerCase() === "message") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"message\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 9).toLowerCase() === "multipart") {
            result0 = input.substr(pos, 9);
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"multipart\"");
            }
          }
          if (result0 === null) {
            result0 = parse_extension_token();
          }
        }
        return result0;
      }
      
      function parse_extension_token() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_x_token();
        }
        return result0;
      }
      
      function parse_x_token() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2).toLowerCase() === "x-") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"x-\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_token();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_subtype() {
        var result0;
        
        result0 = parse_extension_token();
        if (result0 === null) {
          result0 = parse_token();
        }
        return result0;
      }
      
      function parse_m_parameter() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_m_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_value() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_quoted_string();
        }
        return result0;
      }
      
      function parse_CSeq() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_CSeq_value();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_Method();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_CSeq_value() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, cseq_value) {
                          data.value=parseInt(cseq_value.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Expires() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result0 = (function(offset, expires) {data = expires; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Event() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_event_type();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, event_type) {
                               data.event = event_type.join('').toLowerCase(); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_event_type() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token_nodot();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 46) {
            result2 = ".";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_token_nodot();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_token_nodot();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_From() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_from_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_from_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                        var tag = data.tag;
                        try {
                          data = new NameAddrHeader(data.uri, data.display_name, data.params);
                          if (tag) {data.setParam('tag',tag)}
                        } catch(e) {
                          data = -1;
                        }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_from_param() {
        var result0;
        
        result0 = parse_tag_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_tag_param() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "tag") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"tag\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, tag) {data.tag = tag; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Max_Forwards() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, forwards) {
                          data = parseInt(forwards.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Min_Expires() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result0 = (function(offset, min_expires) {data = min_expires; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Name_Addr_Header() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_display_name();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_display_name();
        }
        if (result0 !== null) {
          result1 = parse_LAQUOT();
          if (result1 !== null) {
            result2 = parse_SIP_URI();
            if (result2 !== null) {
              result3 = parse_RAQUOT();
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                result5 = parse_SEMI();
                if (result5 !== null) {
                  result6 = parse_generic_param();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  result5 = parse_SEMI();
                  if (result5 !== null) {
                    result6 = parse_generic_param();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              try {
                                data = new NameAddrHeader(data.uri, data.display_name, data.params);
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Proxy_Authenticate() {
        var result0;
        
        result0 = parse_challenge();
        return result0;
      }
      
      function parse_challenge() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "digest") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Digest\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_digest_cln();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_COMMA();
              if (result4 !== null) {
                result5 = parse_digest_cln();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_COMMA();
                if (result4 !== null) {
                  result5 = parse_digest_cln();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_other_challenge();
        }
        return result0;
      }
      
      function parse_other_challenge() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_auth_param();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_COMMA();
              if (result4 !== null) {
                result5 = parse_auth_param();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_COMMA();
                if (result4 !== null) {
                  result5 = parse_auth_param();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_auth_param() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 === null) {
              result2 = parse_quoted_string();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_digest_cln() {
        var result0;
        
        result0 = parse_realm();
        if (result0 === null) {
          result0 = parse_domain();
          if (result0 === null) {
            result0 = parse_nonce();
            if (result0 === null) {
              result0 = parse_opaque();
              if (result0 === null) {
                result0 = parse_stale();
                if (result0 === null) {
                  result0 = parse_algorithm();
                  if (result0 === null) {
                    result0 = parse_qop_options();
                    if (result0 === null) {
                      result0 = parse_auth_param();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_realm() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "realm") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"realm\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_realm_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_realm_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_quoted_string_clean();
        if (result0 !== null) {
          result0 = (function(offset, realm) { data.realm = realm; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_domain() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "domain") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"domain\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_LDQUOT();
            if (result2 !== null) {
              result3 = parse_URI();
              if (result3 !== null) {
                result4 = [];
                pos1 = pos;
                result6 = parse_SP();
                if (result6 !== null) {
                  result5 = [];
                  while (result6 !== null) {
                    result5.push(result6);
                    result6 = parse_SP();
                  }
                } else {
                  result5 = null;
                }
                if (result5 !== null) {
                  result6 = parse_URI();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos1;
                  }
                } else {
                  result5 = null;
                  pos = pos1;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos1 = pos;
                  result6 = parse_SP();
                  if (result6 !== null) {
                    result5 = [];
                    while (result6 !== null) {
                      result5.push(result6);
                      result6 = parse_SP();
                    }
                  } else {
                    result5 = null;
                  }
                  if (result5 !== null) {
                    result6 = parse_URI();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos1;
                    }
                  } else {
                    result5 = null;
                    pos = pos1;
                  }
                }
                if (result4 !== null) {
                  result5 = parse_RDQUOT();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_URI() {
        var result0;
        
        result0 = parse_absoluteURI();
        if (result0 === null) {
          result0 = parse_abs_path();
        }
        return result0;
      }
      
      function parse_nonce() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "nonce") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"nonce\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_nonce_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonce_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_quoted_string_clean();
        if (result0 !== null) {
          result0 = (function(offset, nonce) { data.nonce=nonce; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_opaque() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "opaque") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"opaque\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_quoted_string_clean();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, opaque) { data.opaque=opaque; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stale() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "stale") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"stale\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            pos1 = pos;
            if (input.substr(pos, 4).toLowerCase() === "true") {
              result2 = input.substr(pos, 4);
              pos += 4;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"true\"");
              }
            }
            if (result2 !== null) {
              result2 = (function(offset) { data.stale=true; })(pos1);
            }
            if (result2 === null) {
              pos = pos1;
            }
            if (result2 === null) {
              pos1 = pos;
              if (input.substr(pos, 5).toLowerCase() === "false") {
                result2 = input.substr(pos, 5);
                pos += 5;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"false\"");
                }
              }
              if (result2 !== null) {
                result2 = (function(offset) { data.stale=false; })(pos1);
              }
              if (result2 === null) {
                pos = pos1;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_algorithm() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 9).toLowerCase() === "algorithm") {
          result0 = input.substr(pos, 9);
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"algorithm\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            if (input.substr(pos, 3).toLowerCase() === "md5") {
              result2 = input.substr(pos, 3);
              pos += 3;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"MD5\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8).toLowerCase() === "md5-sess") {
                result2 = input.substr(pos, 8);
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"MD5-sess\"");
                }
              }
              if (result2 === null) {
                result2 = parse_token();
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, algorithm) {
                              data.algorithm=algorithm.toUpperCase(); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qop_options() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "qop") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"qop\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_LDQUOT();
            if (result2 !== null) {
              pos1 = pos;
              result3 = parse_qop_value();
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                if (input.charCodeAt(pos) === 44) {
                  result5 = ",";
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result5 !== null) {
                  result6 = parse_qop_value();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  if (input.charCodeAt(pos) === 44) {
                    result5 = ",";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_qop_value();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
              if (result3 !== null) {
                result4 = parse_RDQUOT();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qop_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 8).toLowerCase() === "auth-int") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"auth-int\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "auth") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"auth\"");
            }
          }
          if (result0 === null) {
            result0 = parse_token();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, qop_value) {
                                data.qop || (data.qop=[]);
                                data.qop.push(qop_value.toLowerCase()); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Proxy_Require() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Record_Route() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_rec_route();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_rec_route();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_rec_route();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          var idx, length;
                          length = data.multi_header.length;
                          for (idx = 0; idx < length; idx++) {
                            if (data.multi_header[idx].parsed === null) {
                              data = null;
                              break;
                            }
                          }
                          if (data !== null) {
                            data = data.multi_header;
                          } else {
                            data = -1;
                          }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rec_route() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_name_addr();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          var header;
                          if(!data.multi_header) data.multi_header = [];
                          try {
                            header = new NameAddrHeader(data.uri, data.display_name, data.params);
                            delete data.uri;
                            delete data.display_name;
                            delete data.params;
                          } catch(e) {
                            header = null;
                          }
                          data.multi_header.push( { 'possition': pos,
                                                    'offset': offset,
                                                    'parsed': header
                                                  });})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Require() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Route() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_route_param();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_route_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_route_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_route_param() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_name_addr();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Subscription_State() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_substate_value();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_subexp_params();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_subexp_params();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_substate_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "active") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"active\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7).toLowerCase() === "pending") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"pending\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 10).toLowerCase() === "terminated") {
              result0 = input.substr(pos, 10);
              pos += 10;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"terminated\"");
              }
            }
            if (result0 === null) {
              result0 = parse_token();
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                data.state = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_subexp_params() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "reason") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"reason\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_event_reason_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, reason) {
                                if (typeof reason !== 'undefined') data.reason = reason; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.substr(pos, 7).toLowerCase() === "expires") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"expires\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_EQUAL();
            if (result1 !== null) {
              result2 = parse_delta_seconds();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expires) {
                                  if (typeof expires !== 'undefined') data.expires = expires; })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.substr(pos, 11).toLowerCase() === "retry_after") {
              result0 = input.substr(pos, 11);
              pos += 11;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"retry_after\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_EQUAL();
              if (result1 !== null) {
                result2 = parse_delta_seconds();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, retry_after) {
                                    if (typeof retry_after !== 'undefined') data.retry_after = retry_after; })(pos0, result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_generic_param();
            }
          }
        }
        return result0;
      }
      
      function parse_event_reason_value() {
        var result0;
        
        if (input.substr(pos, 11).toLowerCase() === "deactivated") {
          result0 = input.substr(pos, 11);
          pos += 11;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"deactivated\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 9).toLowerCase() === "probation") {
            result0 = input.substr(pos, 9);
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"probation\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 8).toLowerCase() === "rejected") {
              result0 = input.substr(pos, 8);
              pos += 8;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"rejected\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 7).toLowerCase() === "timeout") {
                result0 = input.substr(pos, 7);
                pos += 7;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"timeout\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 6).toLowerCase() === "giveup") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"giveup\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 10).toLowerCase() === "noresource") {
                    result0 = input.substr(pos, 10);
                    pos += 10;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"noresource\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 9).toLowerCase() === "invariant") {
                      result0 = input.substr(pos, 9);
                      pos += 9;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"invariant\"");
                      }
                    }
                    if (result0 === null) {
                      result0 = parse_token();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Subject() {
        var result0;
        
        result0 = parse_TEXT_UTF8_TRIM();
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_Supported() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_To() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_to_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_to_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                      var tag = data.tag;
                      try {
                        data = new NameAddrHeader(data.uri, data.display_name, data.params);
                        if (tag) {data.setParam('tag',tag)}
                      } catch(e) {
                        data = -1;
                      }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_to_param() {
        var result0;
        
        result0 = parse_tag_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_Via() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_via_parm();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_via_parm();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_via_parm();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_parm() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_sent_protocol();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_sent_by();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_SEMI();
              if (result4 !== null) {
                result5 = parse_via_params();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_SEMI();
                if (result4 !== null) {
                  result5 = parse_via_params();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_params() {
        var result0;
        
        result0 = parse_via_ttl();
        if (result0 === null) {
          result0 = parse_via_maddr();
          if (result0 === null) {
            result0 = parse_via_received();
            if (result0 === null) {
              result0 = parse_via_branch();
              if (result0 === null) {
                result0 = parse_response_port();
                if (result0 === null) {
                  result0 = parse_generic_param();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_via_ttl() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "ttl") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ttl\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_ttl();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_ttl_value) {
                              data.ttl = via_ttl_value; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_maddr() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "maddr") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"maddr\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_host();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_maddr) {
                              data.maddr = via_maddr; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_received() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8).toLowerCase() === "received") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"received\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_IPv4address();
            if (result2 === null) {
              result2 = parse_IPv6address();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_received) {
                              data.received = via_received; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_branch() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "branch") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"branch\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_branch) {
                              data.branch = via_branch; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_response_port() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "rport") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"rport\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_DIGIT();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_DIGIT();
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              if(typeof response_port !== 'undefined')
                                data.rport = response_port.join(''); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sent_protocol() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_protocol_name();
        if (result0 !== null) {
          result1 = parse_SLASH();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result3 = parse_SLASH();
              if (result3 !== null) {
                result4 = parse_transport();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_protocol_name() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SIP\"");
          }
        }
        if (result0 === null) {
          result0 = parse_token();
        }
        if (result0 !== null) {
          result0 = (function(offset, via_protocol) {
                              data.protocol = via_protocol; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_transport() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "udp") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"UDP\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 3).toLowerCase() === "tcp") {
            result0 = input.substr(pos, 3);
            pos += 3;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"TCP\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tls") {
              result0 = input.substr(pos, 3);
              pos += 3;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"TLS\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 4).toLowerCase() === "sctp") {
                result0 = input.substr(pos, 4);
                pos += 4;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"SCTP\"");
                }
              }
              if (result0 === null) {
                result0 = parse_token();
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, via_transport) {
                              data.transport = via_transport; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sent_by() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_via_host();
        if (result0 !== null) {
          pos1 = pos;
          result1 = parse_COLON();
          if (result1 !== null) {
            result2 = parse_via_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_hostname();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              data.host = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_port() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_sent_by_port) {
                              data.port = parseInt(via_sent_by_port.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ttl() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ttl) {
                              return parseInt(ttl.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_WWW_Authenticate() {
        var result0;
        
        result0 = parse_challenge();
        return result0;
      }
      
      function parse_extension_header() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_HCOLON();
          if (result1 !== null) {
            result2 = parse_header_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_header_value() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_TEXT_UTF8char();
        if (result1 === null) {
          result1 = parse_UTF8_CONT();
          if (result1 === null) {
            result1 = parse_LWS();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_TEXT_UTF8char();
          if (result1 === null) {
            result1 = parse_UTF8_CONT();
            if (result1 === null) {
              result1 = parse_LWS();
            }
          }
        }
        return result0;
      }
      
      function parse_message_body() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_OCTET();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_OCTET();
        }
        return result0;
      }
      
      function parse_stun_URI() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_stun_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_stun_host_port();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_scheme() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "stuns") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"stuns\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "stun") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"stun\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, scheme) {
                              data.scheme = scheme; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_host_port() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_stun_host();
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_reg_name();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, host) {
                              data.host = host; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_reg_name() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_stun_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            result1 = parse_sub_delims();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_stun_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              result1 = parse_sub_delims();
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_unreserved() {
        var result0;
        
        result0 = parse_ALPHA();
        if (result0 === null) {
          result0 = parse_DIGIT();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 45) {
              result0 = "-";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"-\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 46) {
                result0 = ".";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result0 = "_";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 126) {
                    result0 = "~";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"~\"");
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_sub_delims() {
        var result0;
        
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 36) {
            result0 = "$";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"$\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 38) {
              result0 = "&";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 39) {
                result0 = "'";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 40) {
                  result0 = "(";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"(\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 41) {
                    result0 = ")";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 42) {
                      result0 = "*";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result0 = "+";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 44) {
                          result0 = ",";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 59) {
                            result0 = ";";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\";\"");
                            }
                          }
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 61) {
                              result0 = "=";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"=\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_turn_URI() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_turn_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_stun_host_port();
            if (result2 !== null) {
              pos1 = pos;
              if (input.substr(pos, 11) === "?transport=") {
                result3 = "?transport=";
                pos += 11;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?transport=\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_transport();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_turn_scheme() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "turns") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"turns\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "turn") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"turn\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, scheme) {
                              data.scheme = scheme; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_turn_transport() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_transport();
        if (result0 !== null) {
          if (input.substr(pos, 3).toLowerCase() === "udp") {
            result1 = input.substr(pos, 3);
            pos += 3;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"udp\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tcp") {
              result1 = input.substr(pos, 3);
              pos += 3;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"tcp\"");
              }
            }
            if (result1 === null) {
              result1 = [];
              result2 = parse_unreserved();
              while (result2 !== null) {
                result1.push(result2);
                result2 = parse_unreserved();
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              data.transport = transport; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uuid_URI() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5) === "uuid:") {
          result0 = "uuid:";
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"uuid:\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_uuid();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uuid() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_hex8();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hex4();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 45) {
                result3 = "-";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_hex4();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 45) {
                    result5 = "-";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_hex4();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 45) {
                        result7 = "-";
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }
                      if (result7 !== null) {
                        result8 = parse_hex12();
                        if (result8 !== null) {
                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, uuid) {
                          data = input.substring(pos+5, offset); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex4() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_HEXDIG();
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            if (result2 !== null) {
              result3 = parse_HEXDIG();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex8() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hex4();
        if (result0 !== null) {
          result1 = parse_hex4();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex12() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hex4();
        if (result0 !== null) {
          result1 = parse_hex4();
          if (result1 !== null) {
            result2 = parse_hex4();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var URI = require('./URI');
        var NameAddrHeader = require('./NameAddrHeader');
      
        var data = {};
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
        return -1;
      }
      
      return data;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();

},{"./NameAddrHeader":511,"./URI":524}],508:[function(require,module,exports){
module.exports = Logger;

function DateFmt(fstr) {
  this.formatString = fstr;

  var mthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  var dayNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  var zeroPad = function(number) {
    return ("0"+number).substr(-2,2);
  };

  var dateMarkers = {
    d:['getDate',function(v) { return zeroPad(v);}],
    m:['getMonth',function(v) { return zeroPad(v+1);}],
    n:['getMonth',function(v) { return mthNames[v]; }],
    w:['getDay',function(v) { return dayNames[v]; }],
    y:['getFullYear'],
    H:['getHours',function(v) { return zeroPad(v);}],
    M:['getMinutes',function(v) { return zeroPad(v);}],
    S:['getSeconds',function(v) { return zeroPad(v);}],
    i:['toISOString']
  };

  this.format = function(date) {
    var dateTxt = this.formatString.replace(/%(.)/g, function(m, p) {
      var dateMarker = dateMarkers[p];
      var method = dateMarker[0];
      var rv = date[method]();

      if ( dateMarker[1] !== null ) {
        rv = dateMarker[1](rv);
      }

      return rv;

    });

    return dateTxt;
  };

}


function Logger(logger, category, label) {
  this.logger = logger;
  this.category = category;
  this.label = label;
  this.fmt = new DateFmt("%m%d/%H%M%S");
}

Logger.prototype.debug = function(content) {
  this.logger.debug(this.category, this.label, content);
};

Logger.prototype.log = function(content) {
  this.logger.log(this.category, this.label, content);
};

Logger.prototype.warn = function(content) {
  this.logger.warn(this.category, this.label, content);
};

Logger.prototype.error = function(content) {
  this.logger.error(this.category, this.label, content);
};

Logger.prototype.formatMsg = function(msg) {
  return this.getTime()+' : '+msg;
};
Logger.prototype.getTime = function() {
  return this.getTimeFor(new Date());
};
Logger.prototype.getTimeFor = function(date) {
  return this.fmt.format(date);
};
},{}],509:[function(require,module,exports){
module.exports = LoggerFactory;


/**
 * Dependencies.
 */
var Logger = require('./Logger');


function LoggerFactory(configuration) {
  var logger,
    levels = { 'error': 0, 'warn': 1, 'log': 2, 'debug': 3 },
    level = configuration && configuration.trace_sip === true ? 3 : 1,
    builtinEnabled = true,
    connector = null;

    this.loggers = {};

    logger = this.getLogger('ExSIP.loggerfactory');


  Object.defineProperties(this, {
    builtinEnabled: {
      get: function(){ return builtinEnabled; },
      set: function(value){
        if (typeof value === 'boolean') {
          builtinEnabled = value;
        } else {
          logger.error('invalid "builtinEnabled" parameter value: '+ JSON.stringify(value));
        }
      }
    },

    level: {
      get: function() {return level; },
      set: function(value) {
        if (value >= 0 && value <=3) {
          level = value;
        } else if (value > 3) {
          level = 3;
        } else if (levels.hasOwnProperty(value)) {
          level = levels[value];
        } else {
          logger.error('invalid "level" parameter value: '+ JSON.stringify(value));
        }
      }
    },

    connector: {
      get: function() {return connector; },
      set: function(value){
        if(value === null || value === "" || value === undefined) {
          connector = null;
        } else if (typeof value === 'function') {
          connector = value;
        } else {
          logger.error('invalid "connector" parameter value: '+ JSON.stringify(value));
        }
      }
    }
  });
}


LoggerFactory.prototype.print = function(target, category, label, content) {
  var prefix = [];

  prefix.push(new Date());

  prefix.push(category);

  if (label) {
    prefix.push(label);
  }

  prefix.push('');

  if (typeof content === 'string') {
    target.call(console, prefix.join(' | ') + content);
  } else {
    target.call(console, content);
  }
};

LoggerFactory.prototype.debug = function(category, label, content) {
  if (this.level === 3) {
    if (this.builtinEnabled) {
      this.print(console.info, category, label, content);
    }

    if (this.connector) {
      this.connector('debug', category, label, content);
    }
  }
};

LoggerFactory.prototype.log = function(category, label, content) {
  if (this.level >= 2) {
    if (this.builtinEnabled) {
      this.print(console.log, category, label, content);
    }

    if (this.connector) {
      this.connector('log', category, label, content);
    }
  }
};

LoggerFactory.prototype.warn = function(category, label, content) {
  if (this.level >= 1) {
    if (this.builtinEnabled) {
      this.print(console.warn, category, label, content);
    }

    if (this.connector) {
      this.connector('warn', category, label, content);
    }
  }
};

LoggerFactory.prototype.error = function(category, label, content) {
  if (this.builtinEnabled) {
    this.print(console.error,category, label, content);
  }

  if (this.connector) {
    this.connector('error', category, label, content);
  }
};

LoggerFactory.prototype.getLogger = function(category, label) {
  var logger;

  if (label && this.level === 1) {
    return new Logger(this, category, label);
  } else if (this.loggers[category]) {
    return this.loggers[category];
  } else {
    logger = new Logger(this, category);
    this.loggers[category] = logger;
    return logger;
  }
};

},{"./Logger":508}],510:[function(require,module,exports){
module.exports = Message;

function Message(ua) {
  this.ua = ua;
  this.logger = ua.getLogger('ExSIP.message');

  // Custom message empty object for high level use
  this.data = {};
}


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var EventEmitter = require('./EventEmitter');
var SIPMessage = require('./SIPMessage');
var Utils = require('./Utils');
var RequestSender = require('./RequestSender');
var Transactions = require('./Transactions');
var Exceptions = require('./Exceptions');


Message.prototype = new EventEmitter();


Message.prototype.isDebug = function() {
  return this.ua.isDebug();
};

Message.prototype.send = function(target, body, options) {
  var request_sender, event, contentType, eventHandlers, extraHeaders,
    events = [
      'succeeded',
      'failed'
    ],
    originalTarget = target;

  if (target === undefined || body === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check target validity
  target = this.ua.normalizeTarget(target);
  if (!target) {
    throw new TypeError('Invalid target: '+ originalTarget);
  }

  this.initEvents(events);

  // Get call options
  options = options || {};
  extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [];
  eventHandlers = options.eventHandlers || {};
  contentType = options.contentType || 'text/plain';

  this.content_type = contentType;

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  this.closed = false;
  this.ua.applicants[this] = this;

  extraHeaders.push('Content-Type: '+ contentType);

  this.request = new SIPMessage.OutgoingRequest(ExSIP_C.MESSAGE, target, this.ua, null, extraHeaders);

  if(body) {
    this.request.body = body;
    this.content = body;
  } else {
    this.content = null;
  }

  request_sender = new RequestSender(this, this.ua);

  this.newMessage('local', this.request);

  request_sender.send();
};

Message.prototype.receiveResponse = function(response) {
  var cause;

  if(this.closed) {
    return;
  }
  switch(true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      // Ignore provisional responses.
      break;

    case /^2[0-9]{2}$/.test(response.status_code):
      delete this.ua.applicants[this];
      this.emit('succeeded', this, {
        originator: 'remote',
        response: response
      });
      break;

    default:
      delete this.ua.applicants[this];
      cause = Utils.sipErrorCause(response.status_code);
      this.emit('failed', this, {
        originator: 'remote',
        response: response,
        cause: cause
      });
      break;
  }
};


Message.prototype.onRequestTimeout = function() {
  if(this.closed) {
    return;
  }
  this.emit('failed', this, {
    originator: 'system',
    cause: ExSIP_C.causes.REQUEST_TIMEOUT
  });
};

Message.prototype.onTransportError = function() {
  if(this.closed) {
    return;
  }
  this.emit('failed', this, {
    originator: 'system',
    cause: ExSIP_C.causes.CONNECTION_ERROR
  });
};

Message.prototype.close = function() {
  this.closed = true;
  delete this.ua.applicants[this];
};

Message.prototype.init_incoming = function(request) {
  var transaction;

  this.request = request;
  this.content_type = request.getHeader('Content-Type');

  if (request.body) {
    this.content = request.body;
  } else {
    this.content = null;
  }

  this.newMessage('remote', request);

  transaction = this.ua.transactions.nist[request.via_branch];

  if (transaction && (transaction.state === Transactions.C.STATUS_TRYING || transaction.state === Transactions.C.STATUS_PROCEEDING)) {
    request.reply(200);
  }
};

/**
 * Accept the incoming Message
 * Only valid for incoming Messages
 */
Message.prototype.accept = function(options) {
  options = options || {};

  var
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    body = options.body;

  if (this.direction !== 'incoming') {
    throw new Exceptions.NotSupportedError('"accept" not supported for outgoing Message');
  }

  this.request.reply(200, null, extraHeaders, body);
};

/**
 * Reject the incoming Message
 * Only valid for incoming Messages
 */
Message.prototype.reject = function(options) {
  options = options || {};

  var
    status_code = options.status_code || 480,
    reason_phrase = options.reason_phrase,
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    body = options.body;

  if (this.direction !== 'incoming') {
    throw new Exceptions.NotSupportedError('"reject" not supported for outgoing Message');
  }

  if (status_code < 300 || status_code >= 700) {
    throw new TypeError('Invalid status_code: '+ status_code);
  }

  this.request.reply(status_code, reason_phrase, extraHeaders, body);
};

/**
 * Internal Callbacks
 */

Message.prototype.newMessage = function(originator, request) {
  var message = this,
    event_name = 'newMessage';

  if (originator === 'remote') {
    message.direction = 'incoming';
    message.local_identity = request.to;
    message.remote_identity = request.from;
  } else if (originator === 'local'){
    message.direction = 'outgoing';
    message.local_identity = request.from;
    message.remote_identity = request.to;
  }

  message.ua.emit(event_name, message.ua, {
    originator: originator,
    message: message,
    request: request
  });
};
},{"./Constants":500,"./EventEmitter":504,"./Exceptions":506,"./RequestSender":518,"./SIPMessage":519,"./Transactions":521,"./Utils":525}],511:[function(require,module,exports){
module.exports = NameAddrHeader;


/**
 * Dependencies.
 */
var URI = require('./URI');
var Grammar = require('./Grammar');


function NameAddrHeader(uri, display_name, parameters) {
  var param;

  // Checks
  if(!uri || !(uri instanceof URI)) {
    throw new TypeError('missing or invalid "uri" parameter');
  }

  // Initialize parameters
  this.uri = uri;
  this.parameters = {};

  for (param in parameters) {
    this.setParam(param, parameters[param]);
  }

  Object.defineProperties(this, {
    display_name: {
      get: function() { return display_name; },
      set: function(value) {
        display_name = (value === 0) ? '0' : value;
      }
    }
  });
}

NameAddrHeader.prototype = {
  setParam: function(key, value) {
    if (key) {
      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
    }
  },

  getParam: function(key) {
    if(key) {
      return this.parameters[key.toLowerCase()];
    }
  },

  hasParam: function(key) {
    if(key) {
      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
    }
  },

  deleteParam: function(parameter) {
    var value;
    parameter = parameter.toLowerCase();
    if (this.parameters.hasOwnProperty(parameter)) {
      value = this.parameters[parameter];
      delete this.parameters[parameter];
      return value;
    }
  },

  clearParams: function() {
    this.parameters = {};
  },

  clone: function() {
    return new NameAddrHeader(
      this.uri.clone(),
      this.display_name,
      JSON.parse(JSON.stringify(this.parameters)));
  },

  toString: function() {
    var body, parameter;

    body  = (this.display_name || this.display_name === 0) ? '"' + this.display_name + '" ' : '';
    body += '<' + this.uri.toString() + '>';

    for (parameter in this.parameters) {
      body += ';' + parameter;

      if (this.parameters[parameter] !== null) {
        body += '='+ this.parameters[parameter];
      }
    }

    return body;
  }
};


/**
  * Parse the given string and returns a NameAddrHeader instance or undefined if
  * it is an invalid NameAddrHeader.
  */
NameAddrHeader.parse = function(name_addr_header) {
  name_addr_header = Grammar.parse(name_addr_header,'Name_Addr_Header');

  if (name_addr_header !== -1) {
    return name_addr_header;
  } else {
    return undefined;
  }
};
},{"./Grammar":507,"./URI":524}],512:[function(require,module,exports){
var Parser = {};

module.exports = Parser;


/**
 * Dependencies.
 */
var sdp_transform = require('sdp-transform');
var Grammar = require('./Grammar');
var SIPMessage = require('./SIPMessage');


/**
 * Extract and parse every header of a SIP message.
 */
function getHeader(data, headerStart) {
  var
    // 'start' position of the header.
    start = headerStart,
    // 'end' position of the header.
    end = 0,
    // 'partial end' position of the header.
    partialEnd = 0;

  //End of message.
  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
    return -2;
  }

  while(end === 0) {
    // Partial End of Header.
    partialEnd = data.indexOf('\r\n', start);

    // 'indexOf' returns -1 if the value to be found never occurs.
    if (partialEnd === -1) {
      return partialEnd;
    }

    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
      // Not the end of the message. Continue from the next position.
      start = partialEnd + 2;
    } else {
      end = partialEnd;
    }
  }

  return end;
}

function parseHeader(message, data, headerStart, headerEnd) {
  var header, idx, length, parsed,
    hcolonIndex = data.indexOf(':', headerStart),
    headerName = data.substring(headerStart, hcolonIndex).trim(),
    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();

  // If header-field is well-known, parse it.
  switch(headerName.toLowerCase()) {
    case 'via':
    case 'v':
      message.addHeader('via', headerValue);
      if(message.getHeaders('via').length === 1) {
        parsed = message.parseHeader('Via');
        if(parsed) {
          message.via = parsed;
          message.via_branch = parsed.branch;
        }
      } else {
        parsed = 0;
      }
      break;
    case 'from':
    case 'f':
      message.setHeader('from', headerValue);
      parsed = message.parseHeader('from');
      if(parsed) {
        message.from = parsed;
        message.from_tag = parsed.getParam('tag');
      }
      break;
    case 'to':
    case 't':
      message.setHeader('to', headerValue);
      parsed = message.parseHeader('to');
      if(parsed) {
        message.to = parsed;
        message.to_tag = parsed.getParam('tag');
      }
      break;
    case 'record-route':
      parsed = Grammar.parse(headerValue, 'Record_Route');

      if (parsed === -1) {
        parsed = undefined;
      }

      length = parsed.length;
      for (idx = 0; idx < length; idx++) {
        header = parsed[idx];
        message.addHeader('record-route', headerValue.substring(header.possition, header.offset));
        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
      }
      break;
    case 'call-id':
    case 'i':
      message.setHeader('call-id', headerValue);
      parsed = message.parseHeader('call-id');
      if(parsed) {
        message.call_id = headerValue;
      }
      break;
    case 'contact':
    case 'm':
      parsed = Grammar.parse(headerValue, 'Contact');

      if (parsed === -1) {
        parsed = undefined;
      }

      length = parsed.length;
      for (idx = 0; idx < length; idx++) {
        header = parsed[idx];
        message.addHeader('contact', headerValue.substring(header.possition, header.offset));
        message.headers.Contact[message.getHeaders('contact').length - 1].parsed = header.parsed;
      }
      break;
    case 'content-length':
    case 'l':
      message.setHeader('content-length', headerValue);
      parsed = message.parseHeader('content-length');
      break;
    case 'content-type':
    case 'c':
      message.setHeader('content-type', headerValue);
      parsed = message.parseHeader('content-type');
      break;
    case 'cseq':
      message.setHeader('cseq', headerValue);
      parsed = message.parseHeader('cseq');
      if(parsed) {
        message.cseq = parsed.value;
      }
      if(message instanceof SIPMessage.IncomingResponse) {
        message.method = parsed.method;
      }
      break;
    case 'max-forwards':
      message.setHeader('max-forwards', headerValue);
      parsed = message.parseHeader('max-forwards');
      break;
    case 'www-authenticate':
      message.setHeader('www-authenticate', headerValue);
      parsed = message.parseHeader('www-authenticate');
      break;
    case 'proxy-authenticate':
      message.setHeader('proxy-authenticate', headerValue);
      parsed = message.parseHeader('proxy-authenticate');
      break;
    default:
      // Do not parse this header.
      message.setHeader(headerName, headerValue);
      parsed = 0;
  }

  if (parsed === undefined) {
    return {
      error: 'error parsing header "'+ headerName +'"'
    };
  } else {
    return true;
  }
}


/**
 * Parse SIP Message
 */
Parser.parseMessage = function(data, ua) {
  var message, firstLine, contentLength, bodyStart, parsed,
    headerStart = 0,
    headerEnd = data.indexOf('\r\n'),
    logger = ua.getLogger('ExSIP.parser');

  if(headerEnd === -1) {
    logger.warn('no CRLF found, not a SIP message, discarded');
    return;
  }

  // Parse first line. Check if it is a Request or a Reply.
  firstLine = data.substring(0, headerEnd);
  parsed = Grammar.parse(firstLine, 'Request_Response');

  if(parsed === -1) {
    logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
    return;
  } else if(!parsed.status_code) {
    message = new SIPMessage.IncomingRequest(ua);
    message.method = parsed.method;
    message.ruri = parsed.uri;
  } else {
    message = new SIPMessage.IncomingResponse(ua);
    message.status_code = parsed.status_code;
    message.reason_phrase = parsed.reason_phrase;
  }

  message.data = data;
  headerStart = headerEnd + 2;

  /* Loop over every line in data. Detect the end of each header and parse
  * it or simply add to the headers collection.
  */
  while(true) {
    headerEnd = getHeader(data, headerStart);

    // The SIP message has normally finished.
    if(headerEnd === -2) {
      bodyStart = headerStart + 2;
      break;
    }
    // data.indexOf returned -1 due to a malformed message.
    else if(headerEnd === -1) {
      parsed.error('malformed message');
      return;
    }

    parsed = parseHeader(message, data, headerStart, headerEnd);

    if(parsed !== true) {
      logger.error(parsed.error);
      return;
    }

    headerStart = headerEnd + 2;
  }

  /* RFC3261 18.3.
   * If there are additional bytes in the transport packet
   * beyond the end of the body, they MUST be discarded.
   */
  if(message.hasHeader('content-length')) {
    contentLength = message.getHeader('content-length');
    message.body = data.substr(bodyStart, contentLength);
  } else {
    message.body = data.substring(bodyStart);
  }

  return message;
};

/**
 * sdp-transform features.
 */
Parser.parseSDP = sdp_transform.parse;
Parser.writeSDP = sdp_transform.write;
Parser.parseFmtpConfig = sdp_transform.parseFmtpConfig;
Parser.parsePayloads = sdp_transform.parsePayloads;
Parser.parseRemoteCandidates = sdp_transform.parseRemoteCandidates;
},{"./Grammar":507,"./SIPMessage":519,"sdp-transform":495}],513:[function(require,module,exports){
module.exports = RTCSession;


var C = {
  // RTCSession states
  STATUS_NULL: 0,
  STATUS_INVITE_SENT: 1,
  STATUS_1XX_RECEIVED: 2,
  STATUS_INVITE_RECEIVED: 3,
  STATUS_WAITING_FOR_ANSWER: 4,
  STATUS_ANSWERED: 5,
  STATUS_WAITING_FOR_ACK: 6,
  STATUS_CANCELED: 7,
  STATUS_TERMINATED: 8,
  STATUS_CONFIRMED: 9,
  STATUS_REFER_SENT: 10,
  STATUS_BYE_SENT: 11
};

/**
 * Expose C object.
 */
RTCSession.C = C;

/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var EventEmitter = require('./EventEmitter');
var Exceptions = require('./Exceptions');
var Parser = require('./Parser');
var Utils = require('./Utils');
var Timers = require('./Timers');
var UA = require('./UA');
var WebRTC = require('./WebRTC');
var SIPMessage = require('./SIPMessage');
var Dialog = require('./Dialog');
var RequestSender = require('./RequestSender');
var RTCSession_RTCMediaHandler = require('./RTCSession/RTCMediaHandler');
var RTCSession_DTMF = require('./RTCSession/DTMF');


function RTCSession(ua) {
  var events = [
    'connecting',
    'progress',
    'failed',
    'accepted',
    'confirmed',
    'ended',
    'newDTMF',
    'hold',
    'held',
    'resumed',
    'unhold',
    'muted',
    'unmuted',
    'started',
    'onReInvite',
    'dataSent',
    'dataReceived',
    'iceconnected',
    'icecompleted',
    'iceclosed'
  ];

  this.ua = ua;
  this.setStatus(C.STATUS_NULL);
  this.dialog = null;
  this.earlyDialogs = {};
  this.rtcMediaHandler = null;
  this.receiveResponse = this.receiveInviteResponse;

  // RTCSession confirmation flag
  this.is_confirmed = false;

  // is late SDP being negotiated
  this.late_sdp = false;

  // Session Timers
  this.timers = {
    ackTimer: null,
    expiresTimer: null,
    invite2xxTimer: null,
    userNoAnswerTimer: null
  };

  // Custom session empty object for high level use
  this.data = {};
  this.dtmf = new RTCSession_DTMF(this);

  /**
   * User API
   */

  // Mute/Hold state
  this.isOnHold = false;
  this.audioMuted = false;
  this.videoMuted = false;
  this.local_hold = false;
  this.remote_hold = false;
  this.start_time = null;

  this.pending_actions = {
    actions: [],

    length: function() {
      return this.actions.length;
    },

    isPending: function(name) {
      var
        idx = 0,
        length = this.actions.length;

      for (idx; idx < length; idx++) {
        if (this.actions[idx].name === name) {
          return true;
        }
      }
      return false;
    },

    shift: function() {
      return this.actions.shift();
    },

    push: function(name) {
      this.actions.push({
        name: name
      });
    },

    pop: function(name) {
      var
        idx = 0,
        length = this.actions.length;

      for (idx; idx < length; idx++) {
        if (this.actions[idx].name === name) {
          this.actions.splice(idx, 1);
        }
      }
    }
  };

  // Custom session empty object for high level use
  this.data = {};

  this.initEvents(events);
}

RTCSession.prototype = new EventEmitter();

/**
 * Terminate the call.
 */
RTCSession.prototype.terminate = function(options) {
  options = options || {};

  var cancel_reason,
    status_code = options.status_code,
    reason_phrase = options.reason_phrase,
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    body = options.body;

  // Check Session Status
  if (this.status === C.STATUS_TERMINATED) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  this.logger.log('terminate with status : ' + this.status);

  switch (this.status) {
    // - UAC -
    case C.STATUS_NULL:
    case C.STATUS_INVITE_SENT:
    case C.STATUS_1XX_RECEIVED:
      this.logger.debug('canceling RTCSession');

      if (status_code && (status_code < 200 || status_code >= 700)) {
        throw new TypeError('Invalid status_code: ' + status_code);
      } else if (status_code) {
        reason_phrase = reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '';
        cancel_reason = 'SIP ;cause=' + status_code + ' ;text="' + reason_phrase + '"';
      }

      // Check Session Status
      if (this.status === C.STATUS_NULL) {
        this.isCanceled = true;
        this.cancelReason = cancel_reason;
      } else if (this.status === C.STATUS_INVITE_SENT) {
        if (this.received_100) {
          this.logger.debug('canceling after received 100 response');
          if (typeof(this.request.cancel) === 'undefined') {
            this.sendBye(options);
            this.ended('local', null, ExSIP_C.causes.BYE);
          } else {
            this.isCanceled = true;
            this.logger.log('terminate on 100 - setting isCanceled = true', this.ua);
            this.request.cancel(cancel_reason);
          }
        } else {
          this.isCanceled = true;
          this.cancelReason = cancel_reason;
        }
      } else if (this.status === C.STATUS_1XX_RECEIVED) {
        this.isCanceled = true;
        this.logger.log('terminate on 1xx - setting isCanceled = true');
        this.request.cancel(cancel_reason);
      }

      this.setStatus(C.STATUS_CANCELED);

      this.failed('local', null, ExSIP_C.causes.CANCELED);
      break;

      // - UAS -
    case C.STATUS_WAITING_FOR_ANSWER:
      this.logger.log('rejecting RTCSession with 486 Busy Here', this.ua);
      this.request.reply(486);
      this.failed('local', null, ExSIP_C.causes.REJECTED);
      break;
    case C.STATUS_ANSWERED:
      this.logger.debug('rejecting RTCSession');

      status_code = status_code || 480;

      if (status_code < 300 || status_code >= 700) {
        throw new TypeError('Invalid status_code: ' + status_code);
      }

      this.request.reply(status_code, reason_phrase, extraHeaders, body);
      this.failed('local', null, ExSIP_C.causes.REJECTED);
      break;

    case C.STATUS_WAITING_FOR_ACK:
    case C.STATUS_REFER_SENT:
    case C.STATUS_CONFIRMED:
      this.logger.debug('terminating RTCSession');

      // Send Bye
      this.sendBye(options);
      return;
      // reason_phrase = options.reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '';

      // if (status_code && (status_code < 200 || status_code >= 700)) {
      //   throw new TypeError('Invalid status_code: '+ status_code);
      // } else if (status_code) {
      //   extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text="' + reason_phrase + '"');
      // }

      // /* RFC 3261 section 15 (Terminating a session):
      //   *
      //   * "...the callee's UA MUST NOT send a BYE on a confirmed dialog
      //   * until it has received an ACK for its 2xx response or until the server
      //   * transaction times out."
      //   */
      // if (this.status === C.STATUS_WAITING_FOR_ACK &&
      //     this.direction === 'incoming' &&
      //     this.request.server_transaction.state !== Transactions.C.STATUS_TERMINATED) {

      //   // Save the dialog for later restoration
      //   dialog = this.dialog;

      //   // Send the BYE as soon as the ACK is received...
      //   this.receiveRequest = function(request) {
      //     if(request.method === ExSIP_C.ACK) {
      //       self.sendBye({
      //         extraHeaders: extraHeaders,
      //         body: body
      //       });
      //       // this.sendRequest(ExSIP_C.BYE, {
      //       //   extraHeaders: extraHeaders,
      //       //   body: body
      //       // });
      //       dialog.terminate();
      //     }
      //   };

      //   // .., or when the INVITE transaction times out
      //   this.request.server_transaction.on('stateChanged', function(e){
      //     if (e.sender.state === Transactions.C.STATUS_TERMINATED) {
      //       self.sendBye({
      //         extraHeaders: extraHeaders,
      //         body: body
      //       });
      //       // self.sendRequest(ExSIP_C.BYE, {
      //       //   extraHeaders: extraHeaders,
      //       //   body: body
      //       // });
      //       dialog.terminate();
      //     }
      //   });

      //   this.ended('local', null, cause);

      //   // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)
      //   this.dialog = dialog;

      //   // Restore the dialog into 'ua' so the ACK can reach 'this' session
      //   this.ua.dialogs[dialog.id.toString()] = dialog;

      // } else {
      //   self.sendBye({
      //     extraHeaders: extraHeaders,
      //     body: body
      //   });
      //   return;
      //   // this.sendRequest(ExSIP_C.BYE, {
      //   //   extraHeaders: extraHeaders,
      //   //   body: body
      //   // });

      //   // this.ended('local', null, cause);
      // }
  }

  this.close();
};

/**
 * Answer the call.
 */
RTCSession.prototype.answer = function(options) {
  options = options || {};

  var idx, length, sdp, remoteDescription,
    hasAudio = false,
    hasVideo = false,
    self = this,
    request = this.request,
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    mediaConstraints = options.mediaConstraints || {},
    mediaStream = options.mediaStream || null,

    // rtcMediaHandler.createAnswer or rtcMediaHandler.createOffer succeeded
    sdpCreationSucceeded = function(body) {
      var
      // run for reply success callback
        replySucceeded = function() {
          self.setStatus(C.STATUS_WAITING_FOR_ACK);

          self.setInvite2xxTimer(request, body);
          self.setACKTimer();
          self.accepted('local');
          self.started('local');
        },

        // run for reply failure callback
        replyFailed = function() {
          self.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
        };

      request.reply(200, null, extraHeaders,
        body,
        replySucceeded,
        replyFailed
      );
    },

    // rtcMediaHandler.createAnswer or rtcMediaHandler.createOffer failed
    sdpCreationFailed = function() {
      if (self.status === C.STATUS_TERMINATED) {
        return;
      }

      self.failed('system', null, ExSIP_C.causes.WEBRTC_ERROR);
    };

  this.data = options.data || {};

  // Check Session Direction and Status
  if (this.direction !== 'incoming') {
    throw new Exceptions.NotSupportedError('"answer" not supported for outgoing RTCSession');
  } else if (this.status !== C.STATUS_WAITING_FOR_ANSWER) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  this.setStatus(C.STATUS_ANSWERED);

  // An error on dialog creation will fire 'failed' event
  if (!this.createDialog(request, 'UAS')) {
    request.reply(500, 'Missing Contact header field');
    return;
  }

  clearTimeout(this.timers.userNoAnswerTimer);

  extraHeaders.unshift('Contact: ' + self.contact);

  // Determine incoming media from remote session description
  remoteDescription = this.rtcMediaHandler.peerConnection.remoteDescription || {};
  sdp = Parser.parseSDP(remoteDescription.sdp || '');

  // Make sure sdp is an array, not the case if there is only one media
  if (!(sdp.media instanceof Array)) {
    sdp.media = [sdp.media || []];
  }

  // Go through all medias in SDP to find offered capabilities to answer with
  idx = sdp.media.length;
  while (idx--) {
    if (sdp.media[idx].type === 'audio' &&
      (sdp.media[idx].direction === 'sendrecv' ||
        sdp.media[idx].direction === 'recvonly')) {
      hasAudio = true;
    }
    if (sdp.media[idx].type === 'video' &&
      (sdp.media[idx].direction === 'sendrecv' ||
        sdp.media[idx].direction === 'recvonly')) {
      hasVideo = true;
    }
  }

  // Remove audio from mediaStream if suggested by mediaConstraints
  if (mediaStream && mediaConstraints.audio === false) {
    length = mediaStream.getAudioTracks().length;
    for (idx = 0; idx < length; idx++) {
      mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);
    }
  }

  // Remove video from mediaStream if suggested by mediaConstraints
  if (mediaStream && mediaConstraints.video === false) {
    length = mediaStream.getVideoTracks().length;
    for (idx = 0; idx < length; idx++) {
      mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);
    }
  }

  // Set audio constraints based on incoming stream if not supplied
  if (mediaConstraints.audio === undefined) {
    mediaConstraints.audio = hasAudio;
  }

  // Set video constraints based on incoming stream if not supplied
  if (mediaConstraints.video === undefined) {
    mediaConstraints.video = hasVideo;
  }

  this.getUserMedia(mediaConstraints, sdpCreationSucceeded, sdpCreationFailed, {
    isAnswer: true,
    remoteSdp: request.body
  });
};

/**
 * Send a DTMF
 */
RTCSession.prototype.sendDTMF = function(tones, options) {
  var duration, interToneGap;

  options = options || {};
  duration = options.duration || null;
  interToneGap = options.interToneGap || null;

  if (tones === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check Session Status
  if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  // Convert to string
  if (typeof tones === 'number') {
    tones = tones.toString();
  }

  // Check tones
  if (!tones || typeof tones !== 'string' || !tones.match(/^[0-9A-D#*,]+$/i)) {
    throw new TypeError('Invalid tones: ' + tones);
  }

  // Check duration
  if (duration && !Utils.isDecimal(duration)) {
    throw new TypeError('Invalid tone duration: ' + duration);
  } else if (!duration) {
    duration = RTCSession_DTMF.C.DEFAULT_DURATION;
  } else if (duration < RTCSession_DTMF.C.MIN_DURATION) {
    this.logger.warn('"duration" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_DURATION + ' milliseconds');
    duration = RTCSession_DTMF.C.MIN_DURATION;
  } else if (duration > RTCSession_DTMF.C.MAX_DURATION) {
    this.logger.warn('"duration" value is greater than the maximum allowed, setting it to ' + RTCSession_DTMF.C.MAX_DURATION + ' milliseconds');
    duration = RTCSession_DTMF.C.MAX_DURATION;
  } else {
    duration = Math.abs(duration);
  }
  options.duration = duration;

  // Check interToneGap
  if (interToneGap && !Utils.isDecimal(interToneGap)) {
    throw new TypeError('Invalid interToneGap: ' + interToneGap);
  } else if (!interToneGap) {
    interToneGap = RTCSession_DTMF.C.DEFAULT_INTER_TONE_GAP;
  } else if (interToneGap < RTCSession_DTMF.C.MIN_INTER_TONE_GAP) {
    this.logger.warn('"interToneGap" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_INTER_TONE_GAP + ' milliseconds');
    interToneGap = RTCSession_DTMF.C.MIN_INTER_TONE_GAP;
  } else {
    interToneGap = Math.abs(interToneGap);
  }

  this.dtmf.send(tones, options);
};

/**
 * Accepts the reInvite.
 * @param {Object} [options]
 */
RTCSession.prototype.rejectReInvite = function(options) {
  options = options || {};

  this.logger.log('rejecting re-INVITE');

  this.request.reply(488);
};

/**
 * Accepts the reInvite.
 * @param {Object} [options]
 */
RTCSession.prototype.acceptReInvite = function(options) {
  options = options || {};

  var self = this,
    extraHeaders = options.extraHeaders || [];

  this.logger.log('accepting re-INVITE');

  var replySucceeded = function() {
    var timeout = Timers.T1;

    self.setStatus(C.STATUS_WAITING_FOR_ACK);

    /**
     * RFC3261 13.3.1.4
     * Response retransmissions cannot be accomplished by transaction layer
     *  since it is destroyed when receiving the first 2xx answer
     */
    self.timers.invite2xxTimer = setTimeout(function invite2xxRetransmission() {
        if (self.status !== C.STATUS_WAITING_FOR_ACK) {
          return;
        }

        self.request.reply(200, null, extraHeaders, self.rtcMediaHandler.peerConnection.localDescription.sdp);

        if (timeout < Timers.T2) {
          timeout = timeout * 2;
          if (timeout > Timers.T2) {
            timeout = Timers.T2;
          }
        }
        self.timers.invite2xxTimer = setTimeout(
          invite2xxRetransmission, timeout
        );
      },
      timeout
    );

    /**
     * RFC3261 14.2
     * If a UAS generates a 2xx response and never receives an ACK,
     *  it SHOULD generate a BYE to terminate the dialog.
     */
    self.timers.ackTimer = setTimeout(function() {
        if (self.status === C.STATUS_WAITING_FOR_ACK) {
          self.logger.log('no ACK received');
          //                window.clearTimeout(self.timers.invite2xxTimer);
          //                self.sendBye();
          //                self.ended('remote', null, ExSIP.C.causes.NO_ACK);
        }
      },
      Timers.TIMER_H
    );

    self.started('local', undefined, true);
  };

  var replyFailed = function() {
    self.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
  };

  //    var previousRemoteDescription = self.rtcMediaHandler.peerConnection.remoteDescription;
  var connectSuccess = function() {
    self.logger.debug('onMessage success');
    self.request.reply(200, null, extraHeaders,
      self.rtcMediaHandler.peerConnection.localDescription.getSdp({
        additionalSdp: self.rtcMediaHandler.peerConnection.remoteUnsupportedMedia
      }),
      replySucceeded,
      replyFailed
    );
  };

  var connectFailed = function(e) {
    self.logger.warn('invalid SDP');
    self.logger.warn(e);
    self.request.reply(488);
  };

  this.initialRemoteSdp = this.initialRemoteSdp || self.rtcMediaHandler.peerConnection.remoteDescription.sdp;
  var sdp = this.request.body;
  if (sdp.length === 0) {
    this.logger.debug('empty sdp');
  }
  this.reconnectRtcMediaHandler(connectSuccess, connectFailed, {
    isAnswer: true,
    remoteSdp: sdp,
    isReconnect: true
  });
};

RTCSession.prototype.reconnectRtcMediaHandler = function(connectSuccess, connectFailed, options) {
  var self = this;
  options = options || {};
  var localMedia = options.localMedia || this.rtcMediaHandler.localMedia || self.ua.localMedia;
  options.createOfferConstraints = options.createOfferConstraints || this.rtcMediaHandler.createOfferConstraints;
  this.rtcMediaHandler.close(!!options.localMedia);

  this.initRtcMediaHandler(options);
  this.rtcMediaHandler.localMedia = localMedia;
  this.rtcMediaHandler.createOfferConstraints = options.createOfferConstraints;
  this.connectRtcMediaHandler(localMedia, function() {
    self.started('local', undefined, true);
    connectSuccess();
  }, connectFailed, options);
};

// /**
//  * Send a generic in-dialog Request
//  */
// RTCSession.prototype.sendRequest = function(method, options, callbacks) {
//   var request = new RTCSession_Request(this, callbacks);

//   if(options.status) {
//     this.status = options.status;
//   }
//   request.body = options.sdp;

//   request.send(method, options);
// };

/**
 * Check if RTCSession is ready for a re-INVITE
 */
RTCSession.prototype.isReadyToReinvite = function() {
  // rtcMediaHandler is not ready
  if (!this.rtcMediaHandler.isReady()) {
    return;
  }

  // Another INVITE transaction is in progress
  if (this.dialog.uac_pending_reply === true || this.dialog.uas_pending_reply === true) {
    return false;
  } else {
    return true;
  }
};


/**
 * Mute
 */
RTCSession.prototype.mute = function(options) {
  options = options || {
    audio: true,
    video: false
  };

  var
    audioMuted = false,
    videoMuted = false;

  if (this.audioMuted === false && options.audio) {
    audioMuted = true;
    this.audioMuted = true;
    this.toogleMuteAudio(true);
  }

  if (this.videoMuted === false && options.video) {
    videoMuted = true;
    this.videoMuted = true;
    this.toogleMuteVideo(true);
  }

  if (audioMuted === true || videoMuted === true) {
    this.onmute({
      audio: audioMuted,
      video: videoMuted
    });
  }
};

/**
 * Unmute
 */
RTCSession.prototype.unmute = function(options) {
  options = options || {
    audio: true,
    video: true
  };

  var
    audioUnMuted = false,
    videoUnMuted = false;

  if (this.audioMuted === true && options.audio) {
    audioUnMuted = true;
    this.audioMuted = false;

    if (this.local_hold === false) {
      this.toogleMuteAudio(false);
    }
  }

  if (this.videoMuted === true && options.video) {
    videoUnMuted = true;
    this.videoMuted = false;

    if (this.local_hold === false) {
      this.toogleMuteVideo(false);
    }
  }

  if (audioUnMuted === true || videoUnMuted === true) {
    this.onunmute({
      audio: audioUnMuted,
      video: videoUnMuted
    });
  }
};

/**
 * isMuted
 */
RTCSession.prototype.isMuted = function() {
  return {
    audio: this.audioMuted,
    video: this.videoMuted
  };
};

/**
 * Hold
 */
// RTCSession.prototype.hold = function() {

//   if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
//     throw new Exceptions.InvalidStateError(this.status);
//   }

//   this.toogleMuteAudio(true);
//   this.toogleMuteVideo(true);

//   if (!this.isReadyToReinvite()) {
//     /* If there is a pending 'unhold' action, cancel it and don't queue this one
//      * Else, if there isn't any 'hold' action, add this one to the queue
//      * Else, if there is already a 'hold' action, skip
//      */
//     if (this.pending_actions.isPending('unhold')) {
//       this.pending_actions.pop('unhold');
//       return;
//     } else if (!this.pending_actions.isPending('hold')) {
//       this.pending_actions.push('hold');
//       return;
//     } else {
//       return;
//     }
//   } else {
//     if (this.local_hold === true) {
//       return;
//     }
//   }

//   this.onhold('local');

//   this.sendReinvite({
//     mangle: function(body) {
//       var idx, length;

//       body = Parser.parseSDP(body);

//       length = body.media.length;
//       for (idx = 0; idx < length; idx++) {
//         if (body.media[idx].direction === undefined) {
//           body.media[idx].direction = 'sendonly';
//         } else if (body.media[idx].direction === 'sendrecv') {
//           body.media[idx].direction = 'sendonly';
//         } else if (body.media[idx].direction === 'sendonly') {
//           body.media[idx].direction = 'inactive';
//         }
//       }

//       return Parser.writeSDP(body);
//     }
//   });
// };

// /**
//  * Unhold
//  */
// RTCSession.prototype.unhold = function() {

//   if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
//     throw new Exceptions.InvalidStateError(this.status);
//   }

//   if (!this.audioMuted) {
//     this.toogleMuteAudio(false);
//   }

//   if (!this.videoMuted) {
//     this.toogleMuteVideo(false);
//   }

//   if (!this.isReadyToReinvite()) {
//     /* If there is a pending 'hold' action, cancel it and don't queue this one
//      * Else, if there isn't any 'unhold' action, add this one to the queue
//      * Else, if there is already an 'unhold' action, skip
//      */
//     if (this.pending_actions.isPending('hold')) {
//       this.pending_actions.pop('hold');
//       return;
//     } else if (!this.pending_actions.isPending('unhold')) {
//       this.pending_actions.push('unhold');
//       return;
//     } else {
//       return;
//     }
//   } else {
//     if (this.local_hold === false) {
//       return;
//     }
//   }

//   this.onunhold('local');

//   this.sendReinvite();
// };


/**
 * Session Timers
 */


/**
 * RFC3261 13.3.1.4
 * Response retransmissions cannot be accomplished by transaction layer
 *  since it is destroyed when receiving the first 2xx answer
 */
RTCSession.prototype.setInvite2xxTimer = function(request, body) {
  var
    self = this,
    timeout = Timers.T1;

  this.timers.invite2xxTimer = setTimeout(function invite2xxRetransmission() {
    if (self.status !== C.STATUS_WAITING_FOR_ACK) {
      return;
    }

    request.reply(200, null, ['Contact: ' + self.contact], body);

    if (timeout < Timers.T2) {
      timeout = timeout * 2;
      if (timeout > Timers.T2) {
        timeout = Timers.T2;
      }
    }
    self.timers.invite2xxTimer = setTimeout(
      invite2xxRetransmission, timeout
    );
  }, timeout);
};


/**
 * RFC3261 14.2
 * If a UAS generates a 2xx response and never receives an ACK,
 *  it SHOULD generate a BYE to terminate the dialog.
 */
RTCSession.prototype.setACKTimer = function() {
  var self = this;

  this.timers.ackTimer = setTimeout(function() {
    if (self.status === C.STATUS_WAITING_FOR_ACK) {
      self.logger.debug('no ACK received, terminating the call');
      clearTimeout(self.timers.invite2xxTimer);
      self.sendBye();
      // self.sendRequest(ExSIP_C.BYE);
      self.ended('remote', null, ExSIP_C.causes.NO_ACK);
    }
  }, Timers.TIMER_H);
};


/**
 * RTCPeerconnection handlers
 */
// Modified to support Firefox 22
RTCSession.prototype.getLocalStreams = function() {
  try {
    if (this.rtcMediaHandler.peerConnection.localStreams) {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.localStreams || [];
    } else {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.getLocalStreams() || [];
    }
  } catch (ex) {
    return [];
  }
};

RTCSession.prototype.getRemoteStreams = function() {
  try {
    if (this.rtcMediaHandler.peerConnection.remoteStreams) {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.remoteStreams || [];
    } else {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.getRemoteStreams() || [];
    }
  } catch (ex) {
    return [];
  }
};

RTCSession.prototype.initRtcMediaHandler = function(options) {
  options = options || {};
  var constraints = options.RTCConstraints || this.ua.rtcConstraints() || {
    "optional": [{
      'DtlsSrtpKeyAgreement': 'true'
    }]
  };
  this.rtcMediaHandler = new RTCSession_RTCMediaHandler(this, {
    constraints: constraints,
    stun_servers: options.stun_servers,
    turn_servers: options.turn_servers
  });
};
/**
 * Session Management
 */

RTCSession.prototype.init_incoming = function(request) {
  var expires,
    self = this,
    contentType = request.getHeader('Content-Type'),

    waitForAnswer = function() {
      self.setStatus(C.STATUS_WAITING_FOR_ANSWER);

      // Set userNoAnswerTimer
      self.timers.userNoAnswerTimer = setTimeout(function() {
        request.reply(408);
        self.failed('local', null, ExSIP_C.causes.NO_ANSWER);
      }, self.ua.configuration.no_answer_timeout);

      /* Set expiresTimer
       * RFC3261 13.3.1
       */
      if (expires) {
        self.timers.expiresTimer = setTimeout(function() {
          if (self.status === C.STATUS_WAITING_FOR_ANSWER) {
            request.reply(487);
            self.failed('system', null, ExSIP_C.causes.EXPIRES);
          }
        }, expires);
      }

      // Fire 'newRTCSession' event.
      self.newRTCSession('remote', request);

      // Reply 180.
      request.reply(180, null, ['Contact: ' + self.contact]);

      // Fire 'progress' event.
      // TODO: Document that 'response' field in 'progress' event is null for
      // incoming calls.
      self.progress('local', null);
    };

  // Check body and content type
  if (request.body && (contentType !== 'application/sdp')) {
    request.reply(415);
    return;
  }

  // Session parameter initialization
  this.setStatus(C.STATUS_INVITE_RECEIVED);
  this.from_tag = request.from_tag;
  this.id = request.call_id + this.from_tag;
  this.request = request;
  this.contact = this.ua.contact.toString();

  this.logger = this.ua.getLogger('rtcsession', this.id);

  //Save the session into the ua sessions collection.
  this.ua.sessions[this.id] = this;

  //Get the Expires header value if exists
  if (request.hasHeader('expires')) {
    expires = request.getHeader('expires') * 1000;
  }

  /* Set the to_tag before
   * replying a response code that will create a dialog.
   */
  request.to_tag = Utils.newTag();

  // An error on dialog creation will fire 'failed' event
  if (!this.createDialog(request, 'UAS', true)) {
    request.reply(500, 'Missing Contact header field');
    return;
  }

  //Initialize Media Session
  this.initRtcMediaHandler();

  if (request.body) {
    this.rtcMediaHandler.onMessage(
      'offer',
      request.body,
      /*
       * onSuccess
       * SDP Offer is valid. Fire UA newRTCSession
       */
      waitForAnswer,
      /*
       * onFailure
       * Bad media description
       */
      function(e) {
        self.logger.warn('invalid SDP');
        self.logger.warn(e);
        request.reply(488);
      }
    );
  } else {
    this.late_sdp = true;
    waitForAnswer();
  }
};

RTCSession.prototype.connect = function(target, options) {
  var self = this;
  options = options || {};

  this.data = options.data || {};

  this.initRtcMediaHandler(options);

  this.connectLocalMedia(target, options, function() {
    self.sendInviteRequest(target, options);
  }, function() {

  });
};

RTCSession.prototype.close = function() {
  var idx;

  if (this.status === C.STATUS_TERMINATED) {
    return;
  }

  this.logger.debug('closing INVITE session ' + this.id);

  // 1st Step. Terminate media.
  if (this.rtcMediaHandler) {
    this.rtcMediaHandler.close();
  }

  // 2nd Step. Terminate signaling.

  // Clear session timers
  for (idx in this.timers) {
    clearTimeout(this.timers[idx]);
  }

  // Terminate dialogs

  // Terminate confirmed dialog
  if (this.dialog) {
    this.dialog.terminate();
    delete this.dialog;
  }

  // Terminate early dialogs
  for (idx in this.earlyDialogs) {
    this.earlyDialogs[idx].terminate();
    delete this.earlyDialogs[idx];
  }

  this.setStatus(C.STATUS_TERMINATED);

  delete this.ua.sessions[this.id];
};

/**
 * Dialog Management
 * @private
 */
RTCSession.prototype.createDialog = function(message, type, early) {
  var dialog, early_dialog,
    local_tag = (type === 'UAS') ? message.to_tag : message.from_tag,
    remote_tag = (type === 'UAS') ? message.from_tag : message.to_tag,
    id = message.call_id + local_tag + remote_tag;

  early_dialog = this.earlyDialogs[id];

  // Early Dialog
  if (early) {
    if (early_dialog) {
      return true;
    } else {
      early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);

      // Dialog has been successfully created.
      if (early_dialog.id) {
        this.earlyDialogs[id] = early_dialog;
        return true;
      }
      // Dialog not created due to an error.
      else {
        this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
        return false;
      }
    }
  }

  // Confirmed Dialog
  else {
    // In case the dialog is in _early_ state, update it
    if (early_dialog) {
      early_dialog.update(message, type);
      this.dialog = early_dialog;
      delete this.earlyDialogs[id];
      return true;
    }

    // Otherwise, create a _confirmed_ dialog
    dialog = new Dialog(this, message, type);

    if (dialog.id) {
      this.to_tag = message.to_tag;
      this.dialog = dialog;
      return true;
    }
    // Dialog not created due to an error
    else {
      this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
      return false;
    }
  }
};

RTCSession.prototype.connectRtcMediaHandler = function(stream, creationSucceeded, creationFailed, options) {
  this.rtcMediaHandler.connect(stream, creationSucceeded, creationFailed, options);
  this.dtmf.enableDtmfSender(stream, this.rtcMediaHandler.peerConnection);
};

RTCSession.prototype.sendData = function(data) {
  this.rtcMediaHandler.sendData(data);
};

/**
 * Get User Media
 * @private
 */
RTCSession.prototype.getUserMedia = function(constraints, creationSucceeded, creationFailed, options) {
  var self = this;

  var userMediaSucceeded = function(stream) {
    self.ua.localMedia = stream;
    self.connectRtcMediaHandler(stream, creationSucceeded, creationFailed, options);
    //      self.reconnectRtcMediaHandler(creationSucceeded, creationFailed, {localMedia: stream});
  };

  var userMediaFailed = function() {
    if (self.status === C.STATUS_TERMINATED) {
      return;
    }
    self.failed('local', null, ExSIP_C.causes.USER_DENIED_MEDIA_ACCESS);
  };


  if (this.ua.reuseLocalMedia() && this.ua.localMedia) {
    this.rtcMediaHandler.localMedia = this.ua.localMedia;
    userMediaSucceeded(this.ua.localMedia);
  } else {
    this.rtcMediaHandler.getUserMedia(
      userMediaSucceeded,
      userMediaFailed,
      constraints
    );
  }
};

RTCSession.prototype.sendInviteRequest = function(target, options, inviteSuccessCallback, inviteFailureCallback) {
  options = options || {};
  options.status = C.STATUS_INVITE_SENT;
  options.sdp = this.rtcMediaHandler.peerConnection.localDescription.sdp;
  options.target = target;
  this.sendRequest(ExSIP_C.INVITE, options, {
    success: inviteSuccessCallback,
    failure: inviteFailureCallback
  });
};
/**
 * Initial Request Sender
 * @private
 */
RTCSession.prototype.createOutgoingRequestSender = function(target, method, options) {
  options = options || {};

  var event, requestParams, iceServers,
    originalTarget = target,
    eventHandlers = options.eventHandlers || {},
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    stun_servers = options.stun_servers || null,
    turn_servers = options.turn_servers || null;


  if (stun_servers) {
    iceServers = UA.configuration_check.optional.stun_servers(stun_servers);
    if (!iceServers) {
      throw new TypeError('Invalid stun_servers: ' + stun_servers);
    } else {
      stun_servers = iceServers;
    }
  }

  if (turn_servers) {
    iceServers = UA.configuration_check.optional.turn_servers(turn_servers);
    if (!iceServers) {
      throw new TypeError('Invalid turn_servers: ' + turn_servers);
    } else {
      turn_servers = iceServers;
    }
  }

  if (target === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check WebRTC support
  if (!WebRTC.isSupported) {
    throw new Exceptions.NotSupportedError('WebRTC not supported');
  }

  // Check target validity
  target = this.ua.normalizeTarget(target);
  if (!target) {
    throw new TypeError('Invalid target: ' + originalTarget);
  }

  // Check Session Status
  if (this.status !== C.STATUS_NULL) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  // Session parameter initialization
  this.from_tag = Utils.newTag();

  // Set anonymous property
  this.anonymous = options.anonymous || false;

  // OutgoingSession specific parameters
  this.isCanceled = false;

  requestParams = {
    from_tag: this.from_tag
  };

  this.contact = this.ua.contact.toString({
    anonymous: this.anonymous,
    outbound: true
  });

  if (this.anonymous) {
    requestParams.from_display_name = 'Anonymous';
    requestParams.from_uri = 'sip:anonymous@anonymous.invalid';

    extraHeaders.push('P-Preferred-Identity: ' + this.ua.configuration.uri.toString());
    extraHeaders.push('Privacy: id');
  }

  extraHeaders.push('Contact: ' + this.contact);
  extraHeaders.push('Allow: ' + Utils.getAllowedMethods(this.ua));

  this.request = new SIPMessage.OutgoingRequest(method, target, this.ua, requestParams, extraHeaders);

  this.id = this.request.call_id + this.from_tag;

  this.logger = this.ua.getLogger('rtcsession', this.id);

  //Save the session into the ua sessions collection.
  this.ua.sessions[this.id] = this;

  this.newRTCSession('local', this.request);

  return new RequestSender(this, this.ua);

};

RTCSession.prototype.sendReferRequest = function(sessionToTransfer, options) {
  this.sessionToTransfer = sessionToTransfer;
  options = options || {};
  options.status = C.STATUS_REFER_SENT;
  options.target = sessionToTransfer.dialog.remote_target;
  this.sendRequest(ExSIP_C.REFER, options);
};

RTCSession.prototype.sendNotifyRequest = function(options, successCallback, failureCallback) {
  options = options || {};
  var extraHeaders = ['Content-Type: message/sipfrag',
    'Subscription-State: ' + (options.subscriptionState || "active;expires=60"),
    'Event: refer'
  ];
  options = Utils.merge_options({
    extraHeaders: extraHeaders
  }, options);
  this.sendRequest(ExSIP_C.NOTIFY, options, {
    success: successCallback,
    failure: failureCallback
  });
};

RTCSession.prototype.isStarted = function() {
  return this.start_time !== null;
};

RTCSession.prototype.isHeld = function() {
  return this.isOnHold;
};

RTCSession.prototype.iceConnected = function(originator, message) {
  var session = this,
    event_name = 'iceconnected';

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.iceCompleted = function(originator, message) {
  var session = this,
    event_name = 'icecompleted';

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.iceClosed = function(originator, message) {
  var session = this,
    event_name = 'iceclosed';

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.held = function() {
  this.isOnHold = true;
  this.emit('held', this);
};

RTCSession.prototype.resumed = function() {
  this.isOnHold = false;
  this.emit('resumed', this);
};

RTCSession.prototype.hold = function(inviteSuccessCallback, inviteFailureCallback) {
  var self = this;
  this.changeSession({
      audioMode: ExSIP_C.INACTIVE,
      audioPort: "0",
      videoMode: ExSIP_C.INACTIVE,
      videoPort: "0"
    }, function() {
      self.held();
      if (inviteSuccessCallback) {
        inviteSuccessCallback();
      }
    },
    inviteFailureCallback);
};

RTCSession.prototype.unhold = function(inviteSuccessCallback, inviteFailureCallback) {
  var self = this;
  this.changeSession({
      audioMode: ExSIP_C.SENDRECV,
      videoMode: ExSIP_C.SENDRECV
    }, function() {
      self.resumed();
      if (inviteSuccessCallback) {
        inviteSuccessCallback();
      }
    },
    inviteFailureCallback);
};

RTCSession.prototype.changeSession = function(sdpOptions, inviteSuccessCallback, inviteFailureCallback) {
  var self = this;
  this.logger.debug('changeSession : ' + JSON.stringify(sdpOptions));
  this.reconnectRtcMediaHandler(function() {
    self.logger.debug('changeSession : reconnectRtcMediaHandler : success');
    self.receiveResponse = self.receiveReinviteResponse;
    self.reinviteSucceeded = inviteSuccessCallback;
    self.reinviteFailed = inviteFailureCallback;
    self.sendInviteRequest(undefined, undefined);
  }, function() {
    self.logger.error("Could not change local mode");
  }, sdpOptions);
};

/**
 * Reception of Response for Initial INVITE
 */
RTCSession.prototype.receiveInviteResponse = function(response) {
  var cause, dialog,
    session = this;

  // Handle 2XX retransmissions and responses from forked requests
  if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {

    /*
     * If it is a retransmission from the endpoint that established
     * the dialog, send an ACK
     */
    if (this.dialog.id.call_id === response.call_id &&
      this.dialog.id.local_tag === response.from_tag &&
      this.dialog.id.remote_tag === response.to_tag) {
      this.sendRequest(ExSIP_C.ACK);
      return;
    }

    // If not, send an ACK  and terminate
    else {
      dialog = new Dialog(this, response, 'UAC');

      if (dialog.error !== undefined) {
        this.logger.error(dialog.error);
        return;
      }

      dialog.sendRequest({
        owner: {
          status: C.STATUS_TERMINATED
        },
        onRequestTimeout: function() {},
        onTransportError: function() {},
        onDialogError: function() {},
        receiveResponse: function() {}
      }, ExSIP_C.ACK);

      dialog.sendRequest({
        owner: {
          status: C.STATUS_TERMINATED
        },
        onRequestTimeout: function() {},
        onTransportError: function() {},
        onDialogError: function() {},
        receiveResponse: function() {}
      }, ExSIP_C.BYE);
      return;
    }

  }

  // Proceed to cancellation if the user requested.
  if (this.isCanceled) {
    // Remove the flag. We are done.
    this.isCanceled = false;

    if (response.status_code >= 100 && response.status_code < 200) {
      this.request.cancel(this.cancelReason);
    } else if (response.status_code >= 200 && response.status_code < 299) {
      this.acceptAndTerminate(response);
    }
    return;
  }

  if (this.status !== C.STATUS_INVITE_SENT && this.status !== C.STATUS_1XX_RECEIVED) {
    return;
  }

  switch (true) {
    case /^100$/.test(response.status_code):
      this.received_100 = true;
      break;
    case /^1[0-9]{2}$/.test(response.status_code):
      this.received_100 = true;
      if (this.status !== C.STATUS_INVITE_SENT && this.status !== C.STATUS_1XX_RECEIVED) {
        break;
      }

      // Do nothing with 1xx responses without To tag.
      if (!response.to_tag) {
        this.logger.warn('1xx response received without to tag');
        break;
      }

      // Create Early Dialog if 1XX comes with contact
      if (response.hasHeader('contact')) {
        // An error on dialog creation will fire 'failed' event
        if (!this.createDialog(response, 'UAC', true)) {
          break;
        }
      }

      this.setStatus(C.STATUS_1XX_RECEIVED);
      this.progress('remote', response);

      if (!response.body) {
        break;
      }

      this.rtcMediaHandler.onMessage(
        'pranswer',
        response.body,
        /*
         * OnSuccess.
         * SDP Answer fits with Offer.
         */
        function() {},
        /*
         * OnFailure.
         * SDP Answer does not fit with Offer.
         */
        function(e) {
          session.logger.warn(e);
          session.earlyDialogs[response.call_id + response.from_tag + response.to_tag].terminate();
        }
      );
      break;
    case /^2[0-9]{2}$/.test(response.status_code):
      this.setStatus(C.STATUS_CONFIRMED);

      if (!response.body) {
        this.acceptAndTerminate(response, 400, ExSIP_C.causes.MISSING_SDP);
        this.failed('remote', response, ExSIP_C.causes.BAD_MEDIA_DESCRIPTION);
        break;
      }

      // An error on dialog creation will fire 'failed' event
      if (!this.createDialog(response, 'UAC')) {
        break;
      }

      this.rtcMediaHandler.onMessage(
        'answer',
        response.body,
        /*
         * onSuccess
         * SDP Answer fits with Offer. Media will start
         */
        function() {
          session.accepted('remote', response);
          session.started('remote', response);
          session.sendRequest(ExSIP_C.ACK);
          session.confirmed('local', null);
        },
        /*
         * onFailure
         * SDP Answer does not fit the Offer. Accept the call and Terminate.
         */
        function(e) {
          session.logger.warn(e);
          session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
          session.failed('remote', response, ExSIP_C.causes.BAD_MEDIA_DESCRIPTION);
        }
      );
      break;
    default:
      cause = Utils.sipErrorCause(response.status_code);
      this.failed('remote', response, cause);
  }
};

/**
 * Dialog Management
 */
RTCSession.prototype.createDialog = function(message, type, early) {
  var dialog, early_dialog,
    local_tag = (type === 'UAS') ? message.to_tag : message.from_tag,
    remote_tag = (type === 'UAS') ? message.from_tag : message.to_tag,
    id = message.call_id + local_tag + remote_tag;

  early_dialog = this.earlyDialogs[id];

  // Early Dialog
  if (early) {
    if (early_dialog) {
      return true;
    } else {
      early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);

      // Dialog has been successfully created.
      if (early_dialog.error) {
        this.logger.error(dialog.error);
        this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
        return false;
      } else {
        this.earlyDialogs[id] = early_dialog;
        return true;
      }
    }
  }

  // Confirmed Dialog
  else {
    // In case the dialog is in _early_ state, update it
    if (early_dialog) {
      early_dialog.update(message, type);
      this.dialog = early_dialog;
      delete this.earlyDialogs[id];
      return true;
    }

    // Otherwise, create a _confirmed_ dialog
    dialog = new Dialog(this, message, type);

    if (dialog.error) {
      this.logger.error(dialog.error);
      this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
      return false;
    } else {
      this.to_tag = message.to_tag;
      this.dialog = dialog;
      return true;
    }
  }
};

/**
 * In dialog INVITE Reception
 */

RTCSession.prototype.receiveReinvite = function(request) {
  var
    sdp, idx, direction,
    self = this,
    contentType = request.getHeader('Content-Type'),
    hold = false,

    createSdp = function(onSuccess, onFailure) {
      if (self.late_sdp) {
        self.rtcMediaHandler.createOffer(onSuccess, onFailure);
      } else {
        self.rtcMediaHandler.createAnswer(onSuccess, onFailure);
      }
    },

    answer = function() {
      createSdp(
        // onSuccess
        function(body) {
          request.reply(200, null, ['Contact: ' + self.contact], body,
            function() {
              self.setStatus(C.STATUS_WAITING_FOR_ACK);
              self.setInvite2xxTimer(request, body);
              self.setACKTimer();

              if (self.remote_hold === true && hold === false) {
                self.onunhold('remote');
              } else if (self.remote_hold === false && hold === true) {
                self.onhold('remote');
              }
            }
          );
        },
        // onFailure
        function() {
          request.reply(500);
        }
      );
    };


  if (request.body) {
    if (contentType !== 'application/sdp') {
      this.logger.warn('invalid Content-Type');
      request.reply(415);
      return;
    }

    sdp = Parser.parseSDP(request.body);

    for (idx = 0; idx < sdp.media.length; idx++) {
      direction = sdp.direction || sdp.media[idx].direction || 'sendrecv';

      if (direction === 'sendonly' || direction === 'inactive') {
        hold = true;
      }
    }

    this.rtcMediaHandler.onMessage(
      'offer',
      request.body,
      /*
       * onSuccess
       * SDP Offer is valid
       */
      answer,
      /*
       * onFailure
       * Bad media description
       */
      function(e) {
        self.logger.error(e);
        request.reply(488);
      }
    );
  } else {
    this.late_sdp = true;
    answer();
  }
};

/**
 * In dialog UPDATE Reception
 */

RTCSession.prototype.receiveUpdate = function(request) {
  var
    sdp, idx, direction,
    self = this,
    contentType = request.getHeader('Content-Type'),
    hold = true;

  if (!request.body) {
    request.reply(200);
    return;
  }

  if (contentType !== 'application/sdp') {
    this.logger.warn('invalid Content-Type');
    request.reply(415);
    return;
  }

  sdp = Parser.parseSDP(request.body);

  for (idx = 0; idx < sdp.media.length; idx++) {
    direction = sdp.direction || sdp.media[idx].direction || 'sendrecv';

    if (direction !== 'sendonly' && direction !== 'inactive') {
      hold = false;
    }
  }

  this.rtcMediaHandler.onMessage(
    'offer',
    request.body,
    /*
     * onSuccess
     * SDP Offer is valid
     */
    function() {
      self.rtcMediaHandler.createAnswer(
        function(body) {
          request.reply(200, null, ['Contact: ' + self.contact], body,
            function() {
              if (self.remote_hold === true && hold === false) {
                self.onunhold('remote');
              } else if (self.remote_hold === false && hold === true) {
                self.onhold('remote');
              }
            }
          );
        },
        function() {
          request.reply(500);
        }
      );
    },
    /*
     * onFailure
     * Bad media description
     */
    function(e) {
      self.logger.error(e);
      request.reply(488);
    }
  );
};

/**
 * In dialog Request Reception
 */
RTCSession.prototype.receiveRequest = function(request) {
  var contentType,
    self = this;

  if (request.method === ExSIP_C.CANCEL) {
    /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
     * was in progress and that the UAC MAY continue with the session established by
     * any 2xx response, or MAY terminate with BYE. ExSIP does continue with the
     * established session. So the CANCEL is processed only if the session is not yet
     * established.
     */

    /*
     * Terminate the whole session in case the user didn't accept (or yet send the answer)
     * nor reject the request opening the session.
     */
    if (this.status === C.STATUS_WAITING_FOR_ANSWER || this.status === C.STATUS_ANSWERED) {
      this.setStatus(C.STATUS_CANCELED);
      this.request.reply(487);
      this.failed('remote', request, ExSIP_C.causes.CANCELED);
    }
  } else {
    // Requests arriving here are in-dialog requests.
    switch (request.method) {
      case ExSIP_C.ACK:
        if (this.status === C.STATUS_WAITING_FOR_ACK) {
          clearTimeout(this.timers.ackTimer);
          clearTimeout(this.timers.invite2xxTimer);
          this.setStatus(C.STATUS_CONFIRMED);
          if (request.body.length > 0) {
            this.logger.log('set remoteDescription for late offer ACK');
            this.rtcMediaHandler.onMessage(self.rtcMediaHandler.getSetRemoteLocationType(), request.body, function() {
              self.logger.log('late offer remoteDescription success');
              self.started('local', undefined, true);
            }, function() {
              self.logger.log('late offer remoteDescription failure');
            });
          }
        }
        break;
      case ExSIP_C.BYE:
        if (this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_REFER_SENT) {
          request.reply(200);
          this.ended('remote', request, ExSIP_C.causes.BYE);
        } else if (this.status === C.STATUS_INVITE_RECEIVED) {
          request.reply(200);
          this.request.reply(487, 'BYE Received');
          this.ended('remote', request, ExSIP_C.causes.BYE);
        } else {
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.INVITE:
        if (this.status === C.STATUS_CONFIRMED) {
          this.logger.debug('re-INVITE received');
          this.request = request;
          // accept empty reinvites
          if (!request.body || request.body.length === 0) {
            this.acceptReInvite();
            return;
          }

          var description = new WebRTC.RTCSessionDescription({
            type: "offer",
            sdp: request.body
          });
          var oldDescription = this.rtcMediaHandler.peerConnection.remoteDescription;
          var audioAdd = description.hasActiveAudio() && (!oldDescription || !oldDescription.hasActiveAudio());
          var videoAdd = description.hasActiveVideo() && (!oldDescription || !oldDescription.hasActiveVideo());
          if (audioAdd || videoAdd) {
            this.ua.emit("onReInvite", this.ua, {
              session: this,
              request: request,
              audioAdd: audioAdd,
              videoAdd: videoAdd
            });
          } else {
            this.acceptReInvite();
          }
        } else {
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.INFO:
        if (this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_INVITE_RECEIVED || this.status === C.STATUS_ANSWERED) {
          contentType = request.getHeader('content-type');
          if (contentType && (contentType.match(/^application\/dtmf-relay/i))) {
            new RTCSession_DTMF(this).init_incoming(request);
          } else if (contentType && (contentType.match(/^application\/media_control\+xml/i))) {
            request.reply(200);
            this.started('local', undefined, true);
          } else {
            request.reply(415);
          }
        } else {
          this.logger.debug('Wrong Status : ' + this.status);
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.UPDATE:
        if (this.status === C.STATUS_CONFIRMED) {
          this.logger.debug('UPDATE received');
          this.receiveUpdate(request);
        } else {
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.REFER:
        if (this.status === C.STATUS_CONFIRMED) {
          this.ua.processRefer(this, request);
        }
        break;
      case ExSIP_C.NOTIFY:
        if (this.status === C.STATUS_REFER_SENT) {
          request.reply(200);
          this.logger.log('received NOTIFY with body : ' + request.body);
          var status = parseInt(request.body.match(/SIP\/2.0\s(.*)\s/)[1], 10);
          this.logger.log('NOTIFY status : ' + status);

          if (!this.sessionToTransfer) {
            this.logger.warn('no transferred session for REFER session : ' + this.id);
            return;
          }

          if (status >= 200 && status <= 299) {
            this.logger.log('terminate transferred session : ' + this.sessionToTransfer.id);
            this.sessionToTransfer.terminate();
          } else if (status >= 400 && status <= 699) {
            this.logger.warn('resuming session : ' + this.sessionToTransfer.id);
            this.sessionToTransfer.unhold(function() {
              self.logger.log('resumed session : ' + self.sessionToTransfer.id);
            });
          }
        }
        break;
      default:
        request.reply(501);
    }
  }
};


RTCSession.prototype.setStatus = function(status) {
  if (this.logger) {
    this.logger.debug('setStatus : ' + Object.keys(C)[status]);
  }
  this.status = status;
};

RTCSession.prototype.supports = function(name) {
  var supported = this.request.getHeader("Supported");
  return supported !== undefined && supported.indexOf(name) !== -1;
};

/**
 * @private
 */
RTCSession.prototype.sendACK = function() {
  this.sendRequest(ExSIP_C.ACK);
};

/**
 * @private
 */
RTCSession.prototype.sendBye = function(options) {
  var self = this;
  options = options || {};
  options.extraHeaders = options.extraHeaders || [];

  var reason,
    status_code = options.status_code,
    reason_phrase = options.reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '',
    body = options.body;

  if (status_code && (status_code < 200 || status_code >= 700)) {
    throw new TypeError('Invalid status_code: ' + status_code);
  } else if (status_code) {
    reason = 'SIP ;cause=' + status_code + '; text="' + reason_phrase + '"';
    options.extraHeaders.push('Reason: ' + reason);
  }

  options.sdp = body;
  options.status = C.STATUS_BYE_SENT;
  var callbacks = {
    success: function() {
      self.sendACK();
      self.ended('local', null, ExSIP_C.causes.BYE);
    }
  };
  this.logger.log('sendBye : ' + callbacks);
  this.sendRequest(ExSIP_C.BYE, options, callbacks);
};


/**
 * @private
 */
RTCSession.prototype.sendRequest = function(method, options, requestCallbacks) {
  var request_sender;
  options = options || {};
  if (this.dialog) {
    this.logger.debug('sendRequest : dialog : ' + method);
    request_sender = this.dialog.createRequestSender(this, method, options);
  } else {
    this.logger.debug('sendRequest : createOutgoingRequestSender : ' + method + ', ' + JSON.stringify(options));
    request_sender = this.createOutgoingRequestSender(options.target, method, options);
  }

  if (!request_sender) {
    return;
  }

  if (options.status) {
    this.setStatus(options.status);
  }
  request_sender.request.body = options.sdp;

  var hasSdp = request_sender.request.body && request_sender.request.body.length > 0;
  if (!Utils.containsHeader(request_sender.request.extraHeaders, "Content-Type") && hasSdp) {
    request_sender.request.extraHeaders.push('Content-Type: application/sdp');
  }
  this.logger.debug('request_sender.request.extraHeaders : ' + Utils.toString(request_sender.request.extraHeaders));

  request_sender.send(requestCallbacks);
};

/**
 * Session 1009s
 */

/**
 * Callback to be called from UA instance when TransportError occurs
 * @private
 */
RTCSession.prototype.onTransportError = function() {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    } else {
      this.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    }
  }
};

/**
 * Initial Request Sender
 */
RTCSession.prototype.connectLocalMedia = function(target, options, success, failure) {
  var
    self = this;

  // // User media succeeded
  // userMediaSucceeded = function(stream) {
  //   self.rtcMediaHandler.addStream(
  //     stream,
  //     streamAdditionSucceeded,
  //     streamAdditionFailed
  //   );
  // },

  // // User media failed
  // userMediaFailed = function() {
  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.failed('local', null, ExSIP_C.causes.USER_DENIED_MEDIA_ACCESS);
  // },

  // // rtcMediaHandler.addStream successfully added
  // streamAdditionSucceeded = function() {
  //   self.connecting(self.request);

  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.rtcMediaHandler.createOffer(
  //     offerCreationSucceeded,
  //     offerCreationFailed,
  //     RTCOfferConstraints
  //   );
  // },

  // // rtcMediaHandler.addStream failed
  // streamAdditionFailed = function() {
  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.failed('system', null, ExSIP_C.causes.WEBRTC_ERROR);
  // },

  // // rtcMediaHandler.createOffer succeeded
  // offerCreationSucceeded = function(offer) {
  //   if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.request.body = offer;
  //   self.status = C.STATUS_INVITE_SENT;
  //   request_sender.send();
  // },

  // // rtcMediaHandler.createOffer failed
  // offerCreationFailed = function() {
  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.failed('system', null, ExSIP_C.causes.WEBRTC_ERROR);
  // };

  this.receiveResponse = this.receiveInviteResponse;
  var mediaConstraints = options.mediaConstraints || {
    audio: true,
    video: true
  };

  this.getUserMedia(mediaConstraints, function() {
    self.logger.log('getUserMedia succeeded');
    success();
  }, function() {
    self.logger.log('getUserMedia failed');
    self.failed('local', null, ExSIP_C.causes.WEBRTC_ERROR);
    failure();
  }, options);

  // if (mediaStream) {
  //   userMediaSucceeded(mediaStream);
  // } else {
  //   this.getUserMedia(
  //     mediaConstraints,
  //     userMediaSucceeded,
  //     userMediaFailed
  //   );
  // }
};

/**
 * Send Re-INVITE
 */
RTCSession.prototype.sendReinvite = function(options) {
  options = options || {};

  var
    self = this,
    extraHeaders = options.extraHeaders || [],
    eventHandlers = options.eventHandlers || {},
    mangle = options.mangle || null;

  if (eventHandlers.succeeded) {
    this.reinviteSucceeded = eventHandlers.succeeded;
  } else {
    this.reinviteSucceeded = function() {};
  }
  if (eventHandlers.failed) {
    this.reinviteFailed = eventHandlers.failed;
  } else {
    this.reinviteFailed = function() {};
  }

  extraHeaders.push('Contact: ' + this.contact);
  extraHeaders.push('Content-Type: application/sdp');

  this.receiveResponse = this.receiveReinviteResponse;

  this.rtcMediaHandler.createOffer(
    function(body) {
      if (mangle) {
        body = mangle(body);
      }

      self.dialog.sendRequest(self, ExSIP_C.INVITE, {
        extraHeaders: extraHeaders,
        body: body
      });
    },
    function() {
      if (self.isReadyToReinvite()) {
        self.onReadyToReinvite();
      }
      self.reinviteFailed();
    }
  );
};


/**
 * Reception of Response for in-dialog INVITE
 */
RTCSession.prototype.receiveReinviteResponse = function(response) {
  var
    self = this,
    contentType = response.getHeader('Content-Type');

  if (this.status === C.STATUS_TERMINATED) {
    return;
  }

  switch (true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      break;
    case /^2[0-9]{2}$/.test(response.status_code):
      if(this.status !== C.STATUS_CONFIRMED) {
        this.setStatus(C.STATUS_CONFIRMED);
        this.sendRequest(ExSIP_C.ACK);

        if (!response.body) {
          this.reinviteFailed();
          break;
        } else if (contentType !== 'application/sdp') {
          this.reinviteFailed();
          break;
        }

        this.rtcMediaHandler.onMessage(
          'answer',
          response.body,
          /*
           * onSuccess
           * SDP Answer fits with Offer.
           */
          function() {
            if (self.reinviteSucceeded) {
              self.reinviteSucceeded();
            }
          },
          /*
           * onFailure
           * SDP Answer does not fit the Offer.
           */
          function() {
            if (self.reinviteFailed) {
              self.reinviteFailed();
            }
          }
        );

      }
      break;
    default:
      if (this.reinviteFailed) {
        this.reinviteFailed();
      }
  }
};



RTCSession.prototype.acceptAndTerminate = function(response, status_code, reason_phrase) {
  var extraHeaders = [];

  if (status_code) {
    reason_phrase = reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '';
    extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text="' + reason_phrase + '"');
  }

  // An error on dialog creation will fire 'failed' event
  if (this.dialog || this.createDialog(response, 'UAC')) {
    this.sendRequest(ExSIP_C.ACK);
    this.sendBye();
    // this.sendRequest(ExSIP_C.BYE, {
    //   extraHeaders: extraHeaders
    // });
  }

  // Update session status.
  this.setStatus(C.STATUS_TERMINATED);
};


RTCSession.prototype.toogleMuteAudio = function(mute) {
  var streamIdx, trackIdx, tracks,
    localStreams = this.getLocalStreams();

  for (streamIdx in localStreams) {
    tracks = localStreams[streamIdx].getAudioTracks();
    for (trackIdx in tracks) {
      tracks[trackIdx].enabled = !mute;
    }
  }
};

RTCSession.prototype.toogleMuteVideo = function(mute) {
  var streamIdx, trackIdx, tracks,
    localStreams = this.getLocalStreams();

  for (streamIdx in localStreams) {
    tracks = localStreams[streamIdx].getVideoTracks();
    for (trackIdx in tracks) {
      tracks[trackIdx].enabled = !mute;
    }
  }
};

/**
 * Session Callbacks
 */

RTCSession.prototype.onTransportError = function() {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    } else {
      this.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    }
  }
};

/**
 * Callback to be called from UA instance when RequestTimeout occurs
 * @private
 */
RTCSession.prototype.onRequestTimeout = function() {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, ExSIP_C.causes.REQUEST_TIMEOUT);
    } else {
      this.ua.reconnect();
      this.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    }
  }
};

RTCSession.prototype.onDialogError = function(response) {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('remote', response, ExSIP_C.causes.DIALOG_ERROR);
    } else {
      this.failed('remote', response, ExSIP_C.causes.DIALOG_ERROR);
    }
  }
};

/**
 * Internal Callbacks
 */

RTCSession.prototype.newRTCSession = function(originator, request) {
  var session = this,
    event_name = 'newRTCSession';

  if (originator === 'remote') {
    session.direction = 'incoming';
    session.local_identity = request.to;
    session.remote_identity = request.from;
  } else if (originator === 'local') {
    session.direction = 'outgoing';
    session.local_identity = request.from;
    session.remote_identity = request.to;
  }

  session.ua.emit(event_name, session.ua, {
    originator: originator,
    session: session,
    request: request
  });
};

RTCSession.prototype.connecting = function(request) {
  var session = this,
    event_name = 'connecting';

  session.emit(event_name, session, {
    request: request
  });
};

RTCSession.prototype.progress = function(originator, response) {
  var session = this,
    event_name = 'progress';

  session.emit(event_name, session, {
    originator: originator,
    response: response || null
  });
};

RTCSession.prototype.accepted = function(originator, message) {
  var session = this,
    event_name = 'accepted';

  session.start_time = new Date();

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.started = function(originator, message, isReconnect) {
  var session = this,
    event_name = 'started';

  session.start_time = new Date();

  session.emit(event_name, session, {
    originator: originator,
    response: message || null,
    isReconnect: isReconnect
  });
};

RTCSession.prototype.confirmed = function(originator, ack) {
  var session = this,
    event_name = 'confirmed';

  this.is_confirmed = true;

  session.emit(event_name, session, {
    originator: originator,
    ack: ack || null
  });
};

RTCSession.prototype.ended = function(originator, message, cause) {
  var session = this,
    event_name = 'ended';

  session.end_time = new Date();

  session.close();
  session.emit(event_name, session, {
    originator: originator,
    message: message || null,
    cause: cause
  });
};

RTCSession.prototype.failed = function(originator, message, cause) {
  var session = this,
    event_name = 'failed';

  session.close();
  session.emit(event_name, session, {
    originator: originator,
    message: message || null,
    cause: cause
  });
};

RTCSession.prototype.onhold = function(originator) {
  if (originator === 'local') {
    this.local_hold = true;
  } else {
    this.remote_hold = true;
  }

  this.emit('hold', this, {
    originator: originator
  });
};

RTCSession.prototype.onunhold = function(originator) {
  if (originator === 'local') {
    this.local_hold = false;
  } else {
    this.remote_hold = false;
  }

  this.emit('unhold', this, {
    originator: originator
  });
};

RTCSession.prototype.onmute = function(options) {
  this.emit('muted', this, {
    audio: options.audio,
    video: options.video
  });
};

RTCSession.prototype.onunmute = function(options) {
  this.emit('unmuted', this, {
    audio: options.audio,
    video: options.video
  });
};

RTCSession.prototype.onReadyToReinvite = function() {
  var action = (this.pending_actions.length() > 0) ? this.pending_actions.shift() : null;

  if (!action) {
    return;
  }

  if (action.name === 'hold') {
    this.hold();
  } else if (action.name === 'unhold') {
    this.unhold();
  }
};
},{"./Constants":500,"./Dialog":501,"./EventEmitter":504,"./Exceptions":506,"./Parser":512,"./RTCSession/DTMF":514,"./RTCSession/RTCMediaHandler":516,"./RequestSender":518,"./SIPMessage":519,"./Timers":520,"./UA":523,"./Utils":525,"./WebRTC":526}],514:[function(require,module,exports){
module.exports = DTMF;


var C = {
  MIN_DURATION:            70,
  MAX_DURATION:            6000,
  DEFAULT_DURATION:        100,
  MIN_INTER_TONE_GAP:      50,
  DEFAULT_INTER_TONE_GAP:  500
};

/**
 * Expose C object.
 */
DTMF.C = C;


/**
 * Dependencies.
 */
var EventEmitter = require('../EventEmitter');
var Exceptions = require('../Exceptions');
var RTCSession = require('../RTCSession');
var Utils = require('../Utils');


function DTMF(session) {
  var events = [
  'succeeded',
  'failed'
  ];

  this.sendTimeoutId = null;
  this.queuedDTMFs = [];
  this.session = session;
  this.direction = null;
  this.tone = null;
  this.duration = null;
  this.interToneGap = null;
  this.dtmfSender = null;

  this.logger = this.session.ua.getLogger('rtcsession.dtmf', session.id);

  this.initEvents(events);
}

DTMF.prototype = new EventEmitter();

DTMF.prototype.send = function(tone, options) {
  var event, eventHandlers, extraHeaders;

  if (tone === undefined) {
    throw new TypeError('Not enough arguments');
  }

  this.direction = 'outgoing';

  // Check RTCSession Status
  if (this.session.status !== RTCSession.C.STATUS_CONFIRMED && this.session.status !== RTCSession.C.STATUS_WAITING_FOR_ACK) {
    throw new Exceptions.InvalidStateError(this.session.status);
  }

  // Get DTMF options
  options = options || {};
  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
  eventHandlers = options.eventHandlers || {};

  // Check tone type
  if (typeof tone === 'string' ) {
    tone = tone.toUpperCase();
  } else if (typeof tone === 'number') {
    tone = tone.toString();
  } else {
    throw new TypeError('Invalid tone: '+ tone);
  }

  // Check tone value
  if (!tone.match(/^[0-9A-D#*,]+$/i)) {
    throw new TypeError('Invalid tone: '+ tone);
  } else {
    this.tone = tone;
  }

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  this.queueTone(this.tone, options.duration, options.interToneGap);
};

DTMF.prototype.processQueuedDTMFs = function() {
  var self = this;
  if(this.queuedDTMFs.length === 0) {
    return;
  }
  if(!this.dtmfSender.canInsertDTMF) {
    this.logger.log("DTMF Sender cannot insert DTMF - trying again after timeout", this.session.ua);
    this.sendTimeoutId = setTimeout(function(){
      self.processQueuedDTMFs();
    }, 1000);
    return;
  }
  var tones = "";
  var durationSum = 0;
  var interToneGapSum = 0;
  for(var i=0; i < this.queuedDTMFs.length; i++) {
    var dtmf = this.queuedDTMFs[i];
    tones += dtmf.tone;
    durationSum += dtmf.duration;
    interToneGapSum += dtmf.interToneGap;
  }
  var duration = durationSum / this.queuedDTMFs.length;
  var interToneGap = interToneGapSum / this.queuedDTMFs.length;

  this.logger.log("sending DTMF with tones "+tones+", duration "+duration+", gap "+interToneGap);
  this.dtmfSender.insertDTMF(tones, duration, interToneGap);
};

DTMF.prototype.queueTone = function(tone, duration, interToneGap) {
  this.logger.log("Queue tone : "+tone);
  clearTimeout(this.sendTimeoutId);
  this.queuedDTMFs.push({tone: tone, duration: duration, interToneGap: interToneGap});
  var self = this;
  this.sendTimeoutId = setTimeout(function(){
    self.processQueuedDTMFs();
  }, 2 * duration);
};

DTMF.prototype.onDTMFSent = function(tone) {
  if (!tone) {
    return;
  }

  this.logger.log("Sent Dtmf tone: " + tone.tone);
  for(var i=0; i < this.queuedDTMFs.length; i++) {
    var dtmf = this.queuedDTMFs[i];
    if(tone.tone === dtmf.tone) {
      this.queuedDTMFs.splice(i, 1);
      this.logger.log("removing from queued tones - remaining queue: \t" + Utils.toString(this.queuedDTMFs));
      break;
    } else if(dtmf.tone.indexOf(tone.tone) !== -1) {
      dtmf.tone = dtmf.tone.replace(tone.tone, '');
      this.queuedDTMFs[i] = dtmf;
      this.logger.log("removing from queued tones as contained - remaining queue: \t" + Utils.toString(this.queuedDTMFs));
      break;
    }
  }
  this.session.emit('newDTMF', this.session, {
    originator: 'local',
    dtmf: this,
    tone: tone.tone
  });
};

DTMF.prototype.enableDtmfSender = function(localstream, peerConnection) {
  var self = this;
  this.logger.debug('enableDtmfSender : '+localstream);
  if (localstream !== null) {
    var local_audio_track = localstream.getAudioTracks()[0];
    this.dtmfSender = peerConnection.createDTMFSender(local_audio_track);
    this.logger.log("Created DTMF Sender with canInsertDTMF : "+this.dtmfSender.canInsertDTMF);

    this.dtmfSender.ontonechange = function(tone) {
      self.onDTMFSent(tone);
    };

    this.processQueuedDTMFs();
  }
  else {
    this.logger.error("No Local Stream to create DTMF Sender");
  }
};

/**
* @private
*/
DTMF.prototype.receiveResponse = function(response) {
  var cause;

  switch(true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      // Ignore provisional responses.
      break;

    case /^2[0-9]{2}$/.test(response.status_code):
      this.emit('succeeded', this, {
        originator: 'remote',
        response: response
      });
      break;

    default:
      cause = Utils.sipErrorCause(response.status_code);
      this.emit('failed', this, {
        originator: 'remote',
        response: response,
        cause: cause
      });
      break;
  }
};

/**
 * @private
 */
DTMF.prototype.onRequestTimeout = function() {
  this.emit('failed', this, {
    originator: 'system',
    cause: C.causes.REQUEST_TIMEOUT
  });
};

/**
 * @private
 */
DTMF.prototype.onTransportError = function() {
  this.emit('failed', this, {
    originator: 'system',
    cause: C.causes.CONNECTION_ERROR
  });
};

/**
 * @private
 */
DTMF.prototype.init_incoming = function(request) {
  var body,
    reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
    reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;

  this.direction = 'incoming';
  this.request = request;

  request.reply(200);

  if (request.body) {
    body = request.body.split('\r\n');
    if (body.length === 2) {
      if (reg_tone.test(body[0])) {
        this.tone = body[0].replace(reg_tone,"$2");
      }
      if (reg_duration.test(body[1])) {
        this.duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
      }
    }
  }

  if (!this.tone || !this.duration) {
    this.logger.warn('invalid INFO DTMF received, discarded');
  } else {
    this.session.emit('newDTMF', this.session, {
      originator: 'remote',
      dtmf: this,
      request: request
    });
  }
};
},{"../EventEmitter":504,"../Exceptions":506,"../RTCSession":513,"../Utils":525}],515:[function(require,module,exports){
module.exports = DataChannel;

var EventEmitter = require('../EventEmitter');
/**
 * Dependencies.
 */
function DataChannel(session, peerConnection) {

  this.session = session;
  this.peerConnection = peerConnection;
  this.sendChannel = null;
  this.receiveChannel = null;
  this.chunkLength = 60000;
  this.dataReceived = [];

  this.logger = session.ua.getLogger('ExSIP.rtcsession.datachannel', session.id);

  this.initSendChannel();
}

DataChannel.prototype = new EventEmitter();

DataChannel.prototype.isDebug = function() {
  return this.session.ua.isDebug();
};

DataChannel.prototype.close = function() {
  if(this.sendChannel) {
    this.sendChannel.close();
  }
  if(this.receiveChannel) {
    this.receiveChannel.close();
  }
};

DataChannel.prototype.send = function(data) {
  this.sendInChunks(data);
  this.logger.log('Sent Data: ' + data, this.session.ua);
  this.session.emit('dataSent', this, { data: data });
};

DataChannel.prototype.sendInChunks = function(data) {
  var text = null, last = false, self = this;
  if (data.length > this.chunkLength) {
    text = data.slice(0, this.chunkLength); // getting chunk using predefined chunk length
  } else {
    text = data;
    last = true;
  }

  this.sendChannel.send(text + (last ? "\n" : "")); // use JSON.stringify for chrome!

  if (!last) {
    var remainingDataURL = data.slice(text.length);
    window.setTimeout(function () {
      self.sendInChunks(remainingDataURL); // continue transmitting
    }, 50);
  }
};

DataChannel.prototype.initSendChannel = function() {
  var self = this;
  try {
    // Data Channel api supported from Chrome M25.
    // You might need to start chrome with  --enable-data-channels flag.
    this.sendChannel = this.peerConnection.createDataChannel("sendDataChannel", null);
    this.logger.log('Created send data channel', this.session.ua);

    var onSendChannelStateChange = function() {
      var readyState = self.sendChannel.readyState;
      this.logger.log('Send channel state is: ' + readyState, self.session.ua);
    };

    this.sendChannel.onopen = onSendChannelStateChange;
    this.sendChannel.onclose = onSendChannelStateChange;

    var receiveChannelCallback = function(event) {
      this.logger.log('Receive Channel Callback', self.session.ua);
      self.receiveChannel = event.channel;

      var onReceiveChannelStateChange = function() {
        var readyState = self.receiveChannel.readyState;
        this.logger.log('Receive channel state is: ' + readyState, self.session.ua);
      };

      var onReceiveMessageCallback = function(event) {
        this.logger.log('Received Message : '+event.data, self.session.ua);

        if(event.data.indexOf('\n') !== -1) {
          self.dataReceived.push(event.data.replace('\n', ''));
          var data = self.dataReceived.join('');
          self.dataReceived = [];
          self.session.emit('dataReceived', self, { data: data });
        } else {
          self.dataReceived.push(event.data);
        }
      };

      self.receiveChannel.onmessage = onReceiveMessageCallback;
      self.receiveChannel.onopen = onReceiveChannelStateChange;
      self.receiveChannel.onclose = onReceiveChannelStateChange;
    };

    this.peerConnection.ondatachannel = receiveChannelCallback;
  } catch (e) {
    this.emit('failed', this, {
      cause: 'Failed to create data channel'
    });
    self.logger.error('Create Data channel failed with exception: ' + e.message);
  }
};
},{"../EventEmitter":504}],516:[function(require,module,exports){
module.exports = RTCMediaHandler;

/**
 * Dependencies.
 */
var ExSIP_C = require('../Constants');
var WebRTC = require('../WebRTC');
var Utils = require('../Utils');
var DataChannel = require('./DataChannel');


/* RTCMediaHandler
 * -class PeerConnection helper Class.
 * -param {RTCSession} session
 * -param {Object} [contraints]
 */
function RTCMediaHandler(session, constraints) {
  constraints = constraints || {};
  this.logger = session.ua.getLogger('ExSIP.rtcsession.rtcmediahandler', session.id);

  this.logger.log('constraints : '+Utils.toString(constraints), session.ua);
  this.session = session;
  this.localMedia = null;
  this.peerConnection = null;
  this.createOfferConstraints = null;
  this.dataChannel = null;
  this.ready = true;

  this.init(constraints);
}


RTCMediaHandler.prototype = {
  isReady: function() {
    return this.ready;
  },

  copy: function(rtcMediaHandler) {
    var self = this;

    var streamAdditionSucceeded = function() {
    };
    var streamAdditionFailed = function() {
      if (self.session.status === ExSIP_C.STATUS_TERMINATED) {
        return;
      }

      self.session.failed('local', null, ExSIP_C.causes.WEBRTC_ERROR);
    };

    var description = new WebRTC.RTCSessionDescription({type: this.getSetLocalDescriptionType(), sdp: rtcMediaHandler.peerConnection.localDescription.sdp});
    this.setLocalDescription(description);

    this.addStream(rtcMediaHandler.localMedia, streamAdditionSucceeded, streamAdditionFailed);
  },

  connect: function(stream, connectSucceeded, connectFailed, options) {
    var self = this;
    options = options || {};
    this.logger.log('connect with isAnswer : '+options.isAnswer+" and remoteSdp : "+options.remoteSdp, self.session.ua);

    var setLocalDescription = function(callback) {
      self.setLocalDescription(options.localDescription, callback || connectSucceeded, connectFailed);
    };

    var setRemoteDescription = function(successCallback) {
      self.onMessage(
        self.getSetRemoteLocationType(),
        options.remoteSdp,
        successCallback || connectSucceeded, function(e){
          self.logger.error("setRemoteDescription failed");
          self.logger.error(Utils.toString(e));
          connectFailed();
        }
      );
    };

    var createAnswer = function(){
      self.createAnswer(connectSucceeded, connectFailed, options.mediaConstraints);
    };

    var createOffer = function(){
      self.createOffer(function(sdp){
        if(options.remoteSdp && options.remoteSdp !== "") {
          setRemoteDescription(connectSucceeded);
        } else {
          connectSucceeded(sdp);
        }
      }, connectFailed, options.createOfferConstraints, options);
    };

    var streamAdditionSucceeded = function() {
      var hasRemoteSdp = options.remoteSdp && options.remoteSdp.length > 0;
      var isRemote = options.isAnswer && hasRemoteSdp;
      self.logger.log("isRemote : "+isRemote+", isAnswer : "+options.isAnswer+", hasRemoteSdp :"+hasRemoteSdp, self.session.ua);
      if(isRemote) {
        if(options.localDescription) {
          setRemoteDescription(setLocalDescription);
        } else {
          setRemoteDescription(createAnswer);
        }
      } else {
        if(options.remoteSdp) {
          setLocalDescription(setRemoteDescription);
        } else {
          createOffer();
        }
      }
    };

    var streamAdditionFailed = function() {
      if (self.session.status === ExSIP_C.STATUS_TERMINATED) {
        return;
      }

      self.session.failed('local', null, ExSIP_C.causes.WEBRTC_ERROR);
      connectFailed();
    };

    this.addStream(
      stream,
      streamAdditionSucceeded,
      streamAdditionFailed
    );
  },

  createOffer: function(onSuccess, onFailure, constraints, options) {
    var self = this;
    options = options || {};

    function onSetLocalDescriptionSuccess() {
      if (self.peerConnection.iceGatheringState === 'complete' && (self.peerConnection.iceConnectionState === 'connected' || self.peerConnection.iceConnectionState === 'completed') ||
          !self.peerConnection.localDescription.isActive()) {
        self.ready = true;
        onSuccess(self.peerConnection.localDescription.sdp);
      } else {
        self.onIceCompleted = function() {
          self.onIceCompleted = undefined;
          self.ready = true;
          onSuccess(self.peerConnection.localDescription.sdp);
        };
      }
    }

    this.ready = false;

    this.createOfferConstraints = constraints;
    this.logger.log("createOffer with createOfferConstraints : "+Utils.toString(this.createOfferConstraints), this.session.ua);
    this.peerConnection.createOffer(
      function(sessionDescription){
        if(options.videoMode) {
          sessionDescription.setVideoMode(options.videoMode);
        }
        if(options.videoPort) {
          sessionDescription.setVideoPort(options.videoPort);
        }
        if(options.audioMode) {
          sessionDescription.setAudioMode(options.audioMode);
        }
        if(options.audioPort) {
          sessionDescription.setAudioPort(options.audioPort);
        }
        self.setLocalDescription(
          sessionDescription,
          onSetLocalDescriptionSuccess,
          function(e) {
            self.ready = true;
            onFailure(e);
          }
        );
      },
      function(e) {
        self.ready = true;
        self.logger.error('unable to create offer');
        self.logger.error(e);
        onFailure(e);
      },
      constraints
    );
  },

  getRemoteDescriptionSdp: function() {
    return this.peerConnection.remoteDescription ? this.peerConnection.remoteDescription.sdp : undefined;
  },

  createAnswer: function(onSuccess, onFailure, constraints) {
    var self = this;

    function onSetLocalDescriptionSuccess() {
      if (self.peerConnection.iceGatheringState === 'complete' && (self.peerConnection.iceConnectionState === 'connected' || self.peerConnection.iceConnectionState === 'completed') ||
          !self.peerConnection.localDescription.isActive()) {
        self.ready = true;
        onSuccess(self.peerConnection.localDescription.sdp);
      } else {
        self.onIceCompleted = function() {
          self.onIceCompleted = undefined;
          self.ready = true;
          onSuccess(self.peerConnection.localDescription.sdp);
        };
      }
    }

    this.ready = false;

    constraints = constraints ||  this.createOfferConstraints;
    this.logger.log("createAnswer with constraints : "+constraints, this.session.ua);
    this.peerConnection.createAnswer(
      function(sessionDescription){
        self.setLocalDescription(
          sessionDescription,
          onSetLocalDescriptionSuccess,
          function(e) {
            self.ready = true;
            onFailure(e);
          }
        );
      },
      function(e) {
        self.ready = true;
        self.logger.error('unable to create answer');
        self.logger.error(e);
        onFailure(e);
      },
      constraints
    );
  },

  setLocalDescription: function(sessionDescription, onSuccess, onFailure) {
    var self = this;

    this.peerConnection.setLocalDescription(
      sessionDescription,
      onSuccess,
      function(e) {
        self.logger.error('unable to set local description');
        self.logger.error(e);
        onFailure(e);
      }
    );
  },

  addStream: function(stream, onSuccess, onFailure, constraints) {
    try {
      this.logger.log("add stream : "+Utils.toString(stream), this.session.ua);
      this.peerConnection.addStream(stream, constraints);
    } catch(e) {
      this.logger.error('error adding stream');
      this.logger.error(e);
      onFailure();
      return;
    }

    onSuccess();
  },

  clearStreams: function() {
    if(!this.localMedia) {
      return;
    }
    if(this.removeStream(this.localMedia)) {
      this.localMedia = null;
    }
    return;
  },

  removeStream: function(stream) {
    try {
      this.logger.log("remove stream : "+Utils.toString(stream), this.session.ua);
      this.peerConnection.removeStream(stream);
    } catch(e) {
      this.logger.error('error removing stream');
      this.logger.error(e);
      return false;
    }

    return true;
  },

  getSetLocalDescriptionType: function(){
    var state = this.peerConnection.signalingState;
    if(state === 'stable' || state === 'have-local-offer') {
      return "offer";
    } else if(state === 'have-remote-offer' || state === 'have-local-pr-answer'){
      return "answer";
    } else {
      this.logger.error("state "+state +" not implemented - returning offer");
      return "offer";
    }
  },

  getSetRemoteLocationType: function(){
    var state = this.peerConnection.signalingState;
    if(state === 'stable' || state === 'have-remote-offer') {
      return "offer";
    } else if(state === 'have-local-offer' || state === 'have-remote-pr-answer'){
      return "answer";
    } else {
      this.logger.error("state "+state +" not implemented - returning offer");
      return "offer";
    }
  },

  sendData: function(data) {
    if(this.dataChannel) {
      this.dataChannel.send(data);
    } else {
      this.logger.error('datachannel is not enabled - see UA.configuration.enable_datachannel');
    }
  },

  /**
  * peerConnection creation.
  */
  init: function(options) {
    options = options || {};

    var idx, length, server,
      self = this,
      servers = [],
      constraints = options.constraints || {},
      stun_servers = options.stun_servers  || null,
      turn_servers = options.turn_servers || null,
      config = this.session.ua.configuration;

    if (!stun_servers) {
      stun_servers = config.stun_servers;
    }

    if (!turn_servers) {
      turn_servers = config.turn_servers;
    }

    /* Change 'url' to 'urls' whenever this issue is solved:
     * https://code.google.com/p/webrtc/issues/detail?id=2096
     */

    if (stun_servers.length > 0) {
      servers.push({'url': stun_servers});
    }

    length = turn_servers.length;
    for (idx = 0; idx < length; idx++) {
      server = turn_servers[idx];
      servers.push({
        'url': server.urls,
        'username': server.username,
        'credential': server.credential
      });
    }

    this.peerConnection = new WebRTC.RTCPeerConnection({'iceServers': servers}, constraints);

    this.peerConnection.onaddstream = function(e) {
      self.logger.debug('stream added: '+ e.stream.id);
    };

    this.peerConnection.onremovestream = function(e) {
      self.logger.debug('stream removed: '+ e.stream.id);
    };

    this.peerConnection.onicecandidate = function(e) {
      if (e.candidate && self.session.ua.rtcMediaHandlerOptions.enableICE) {
        self.logger.debug('ICE candidate received: '+ e.candidate.candidate);
      } else if (self.onIceCompleted !== undefined) {
        self.logger.log('onIceCompleted with ready : '+ self.ready+" and candidate : "+Utils.toString(e.candidate), self.session.ua);
        if(!self.ready && e.candidate) {
          self.onIceCompleted();
        }      
      }
    };

    this.peerConnection.oniceconnectionstatechange = function() {
      self.logger.debug('ICE connection state changed to "'+ this.iceConnectionState +'"');

      if (this.iceConnectionState === 'connected') {
        self.session.iceConnected();
      } else if (this.iceConnectionState === 'completed') {
        self.session.iceCompleted();
      } else if (this.iceConnectionState === 'closed') {
        self.session.iceClosed();
      } else if (this.iceConnectionState === 'failed') {
        self.session.terminate({
          cause: ExSIP_C.causes.RTP_TIMEOUT,
          status_code: 200,
          reason_phrase: ExSIP_C.causes.RTP_TIMEOUT
        });
      }
    };


    this.peerConnection.onstatechange = function() {
      self.logger.debug('PeerConnection state changed to "'+ this.readyState +'"');
    };

    if(self.session.ua.configuration.enable_datachannel) {
      this.dataChannel = new DataChannel(this.session, this.peerConnection);
    }
  },

  close: function(stopLocalMedia) {
    this.logger.debug('closing PeerConnection');
    if(this.peerConnection) {
      if(this.peerConnection.signalingState !== 'closed') {
        this.logger.log('closing PeerConnection', this.session.ua);
        this.peerConnection.close();
      }

      if(stopLocalMedia) {
        if(this.localMedia) {
          this.logger.log('stopping local media '+Utils.toString(this.localMedia), this.session.ua);
          this.localMedia.stop();
        }
      }
    }
  },

  /**
  * -param {Object} mediaConstraints
  * -param {Function} onSuccess
  * -param {Function} onFailure
  */
  getUserMedia: function(onSuccess, onFailure, constraints) {
    var self = this;

    this.logger.debug('requesting access to local media');

    WebRTC.getUserMedia(constraints,
      function(stream) {
        self.logger.debug('got local media stream');
        self.localMedia = stream;
        onSuccess(stream);
      },
      function(e) {
        self.logger.error('unable to get user media');
        self.logger.error(e);
        onFailure();
      }
    );
  },

  /**
  * Message reception.
  * -param {String} type
  * -param {String} sdp
  * -param {Function} onSuccess
  * -param {Function} onFailure
  */
  onMessage: function(type, body, onSuccess, onFailure) {
    var self = this;
    var description = new WebRTC.RTCSessionDescription({type: type, sdp:body});
    if(this.session.ua.rtcMediaHandlerOptions.videoBandwidth) {
      description.setVideoBandwidth(this.session.ua.rtcMediaHandlerOptions.videoBandwidth);
      this.logger.log("Modifying SDP with videoBandwidth : "+this.session.ua.rtcMediaHandlerOptions.videoBandwidth);
    }

    if(this.peerConnection) {
      if(!description.sdp) {
        this.logger.log('empty sdp on setRemoteDescription - calling success');
        onSuccess();
        return;
      }

      var unsupportedMedia = description.removeUnsupportedMedia();
      if(unsupportedMedia) {
        this.logger.log('removed unsupported media : '+unsupportedMedia);
        this.peerConnection.remoteUnsupportedMedia = unsupportedMedia;
      }

      this.logger.log('peerConnection.setRemoteDescription : description : '+Utils.toString(description));
      this.logger.log('peerConnection.setRemoteDescription for type '+description.type+' : '+description.sdp);
      this.peerConnection.setRemoteDescription(
        description,
        onSuccess,
        function(e){
          self.logger.log("----------setRemoteDescription with error : "+JSON.stringify(e));
          onFailure(e);
        }
      );
    }
  }
};
},{"../Constants":500,"../Utils":525,"../WebRTC":526,"./DataChannel":515}],517:[function(require,module,exports){
module.exports = Registrator;


/**
 * Dependecies
 */
var Utils = require('./Utils');
var ExSIP_C = require('./Constants');
var SIPMessage = require('./SIPMessage');
var RequestSender = require('./RequestSender');

function Registrator(ua, transport) {
  var reg_id=1; //Force reg_id to 1.

  this.logger = ua.getLogger('ExSIP.registrator');

  this.ua = ua;
  this.transport = transport;

  this.registrar = ua.configuration.registrar_server;
  this.expires = ua.configuration.register_expires;

  // Call-ID and CSeq values RFC3261 10.2
  this.call_id = Utils.createRandomToken(22);
  this.cseq = 0;

  // this.to_uri
  this.to_uri = ua.configuration.uri;

  this.registrationTimer = null;

  // Set status
  this.registered = false;

  // Contact header
  this.contact = this.ua.contact.toString();

  // sip.ice media feature tag (RFC 5768)
  this.contact += ';+sip.ice';

  // Custom headers for REGISTER and un-REGISTER.
  this.extraHeaders = [];

  // Custom Contact header params for REGISTER and un-REGISTER.
  this.extraContactParams = "";

  if(reg_id) {
    this.contact += ';reg-id='+ reg_id;
    this.contact += ';+sip.instance="<urn:uuid:'+ this.ua.configuration.instance_id+'>"';
  }
}


Registrator.prototype = {
  setExtraHeaders: function(extraHeaders) {
    if (! extraHeaders instanceof Array) {
      extraHeaders = [];
    }

    this.extraHeaders = extraHeaders.slice();
  },

  setExtraContactParams: function(extraContactParams) {
    if (! extraContactParams instanceof Object) {
      extraContactParams = {};
    }

    // Reset it.
    this.extraContactParams = "";

    for(var param_key in extraContactParams) {
      var param_value = extraContactParams[param_key];
      this.extraContactParams += (";" + param_key);
      if (param_value) {
        this.extraContactParams += ("=" + param_value);
      }
    }
  },

  register: function() {
    var request_sender, cause, extraHeaders,
      self = this;

    extraHeaders = this.extraHeaders.slice();
    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires + this.extraContactParams);
    extraHeaders.push('Expires: '+ this.expires);

    this.request = new SIPMessage.OutgoingRequest(ExSIP_C.REGISTER, this.registrar, this.ua, {
        'to_uri': this.to_uri,
        'call_id': this.call_id,
        'cseq': (this.cseq += 1)
      }, extraHeaders);

    request_sender = new RequestSender(this, this.ua);

    this.receiveResponse = function(response) {
      var contact, expires,
        contacts = response.getHeaders('contact').length;

      // Discard responses to older REGISTER/un-REGISTER requests.
      if(response.cseq !== this.cseq) {
        return;
      }

      // Clear registration timer
      if (this.registrationTimer !== null) {
        clearTimeout(this.registrationTimer);
        this.registrationTimer = null;
      }

      switch(true) {
        case /^1[0-9]{2}$/.test(response.status_code):
          // Ignore provisional responses.
          break;
        case /^2[0-9]{2}$/.test(response.status_code):
          if(response.hasHeader('expires')) {
            expires = response.getHeader('expires');
          }

          // Search the Contact pointing to us and update the expires value accordingly.
          if (!contacts) {
            this.logger.warn('no Contact header in response to REGISTER, response ignored');
            break;
          }

          while(contacts--) {
            contact = response.parseHeader('contact', contacts);
            if(contact.uri.user === this.ua.contact.uri.user) {
              expires = contact.getParam('expires');
              break;
            } else {
              contact = null;
            }
          }

          if (!contact) {
            this.logger.warn('no Contact header pointing to us, response ignored');
            break;
          }

          if(!expires) {
            expires = this.expires;
          }

          // Re-Register before the expiration interval has elapsed.
          // For that, decrease the expires value. ie: 3 seconds
          this.registrationTimer = setTimeout(function() {
            self.registrationTimer = null;
            self.register();
          }, (expires * 1000) - 3000);

          //Save gruu values
          if (contact.hasParam('temp-gruu')) {
            this.ua.contact.temp_gruu = contact.getParam('temp-gruu').replace(/"/g,'');
          }
          if (contact.hasParam('pub-gruu')) {
            this.ua.contact.pub_gruu = contact.getParam('pub-gruu').replace(/"/g,'');
          }

          if (! this.registered) {
            this.registered = true;
            this.ua.emit('registered', this.ua, {
              response: response
            });
          }
          break;
        // Interval too brief RFC3261 10.2.8
        case /^423$/.test(response.status_code):
          if(response.hasHeader('min-expires')) {
            // Increase our registration interval to the suggested minimum
            this.expires = response.getHeader('min-expires');
            // Attempt the registration again immediately
            this.register();
          } else { //This response MUST contain a Min-Expires header field
            this.logger.warn('423 response received for REGISTER without Min-Expires');
            this.registrationFailure(response, ExSIP_C.causes.SIP_FAILURE_CODE);
          }
          break;
        default:
          cause = Utils.sipErrorCause(response.status_code);
          this.registrationFailure(response, cause);
      }
    };

    this.onRequestTimeout = function() {
      this.registrationFailure(null, ExSIP_C.causes.REQUEST_TIMEOUT);
    };

    this.onTransportError = function() {
      this.registrationFailure(null, ExSIP_C.causes.CONNECTION_ERROR);
    };

    request_sender.send();
  },

  unregister: function(options) {
    var extraHeaders;

    // if(!this.registered) {
    //   this.logger.debug('already unregistered');
    //   return;
    // }

    options = options || {};

    this.registered = false;

    // Clear the registration timer.
    if (this.registrationTimer !== null) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = null;
    }

    extraHeaders = this.extraHeaders.slice();

    if(options.all) {
      extraHeaders.push('Contact: *' + this.extraContactParams);
      extraHeaders.push('Expires: 0');

      this.request = new SIPMessage.OutgoingRequest(ExSIP_C.REGISTER, this.registrar, this.ua, {
          'to_uri': this.to_uri,
          'call_id': this.call_id,
          'cseq': (this.cseq += 1)
        }, extraHeaders);
    } else {
      extraHeaders.push('Contact: '+ this.contact + ';expires=0' + this.extraContactParams);
      extraHeaders.push('Expires: 0');

      this.request = new SIPMessage.OutgoingRequest(ExSIP_C.REGISTER, this.registrar, this.ua, {
          'to_uri': this.to_uri,
          'call_id': this.call_id,
          'cseq': (this.cseq += 1)
        }, extraHeaders);
    }

    var request_sender = new RequestSender(this, this.ua);

    this.receiveResponse = function(response) {
      var cause;

      switch(true) {
        case /^1[0-9]{2}$/.test(response.status_code):
          // Ignore provisional responses.
          break;
        case /^2[0-9]{2}$/.test(response.status_code):
          this.unregistered(response);
          break;
        default:
          cause = Utils.sipErrorCause(response.status_code);
          this.unregistered(response, cause);
      }
    };

    this.onRequestTimeout = function() {
      this.unregistered(null, ExSIP_C.causes.REQUEST_TIMEOUT);
    };

    this.onTransportError = function() {
      this.unregistered(null, ExSIP_C.causes.CONNECTION_ERROR);
    };

    request_sender.send();
  },

  registrationFailure: function(response, cause) {
    this.ua.emit('registrationFailed', this.ua, {
      response: response || null,
      cause: cause
    });

    if (this.registered) {
      this.registered = false;
      this.ua.emit('unregistered', this.ua, {
        response: response || null,
        cause: cause
      });
    }
  },

  unregistered: function(response, cause) {
    this.registered = false;
    this.ua.emit('unregistered', this.ua, {
      response: response || null,
      cause: cause || null
    });
  },

  onTransportConnected: function() {
    this.register();
  },

  onTransportClosed: function() {
    if (this.registrationTimer !== null) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = null;
    }

    if(this.registered) {
      this.registered = false;
      this.ua.emit('unregistered', this.ua);
    }
  },

  close: function() {
    if (this.registered) {
      this.unregister();
    }
  }
};
},{"./Constants":500,"./RequestSender":518,"./SIPMessage":519,"./Utils":525}],518:[function(require,module,exports){
module.exports = RequestSender;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var UA = require('./UA');
var DigestAuthentication = require('./DigestAuthentication');
var Transactions = require('./Transactions');

function RequestSender(applicant, ua) {
  this.logger = ua.getLogger('ExSIP.requestsender');
  this.ua = ua;
  this.applicant = applicant;
  this.method = applicant.request.method;
  this.request = applicant.request;
  this.credentials = null;
  this.challenged = false;
  this.staled = false;

  // If ua is in closing process or even closed just allow sending Bye and ACK
  if (ua.status === UA.C.STATUS_USER_CLOSED && (this.method !== ExSIP_C.BYE || this.method !== ExSIP_C.ACK)) {
    this.onTransportError();
  }
}


/**
 * Create the client transaction and send the message.
 */
RequestSender.prototype = {
  send: function(callbacks) {
    this.callbacks = callbacks || {};
    this.logger.log('callbacks : ' + this.callbacks);

    switch (this.method) {
      case "INVITE":
        this.clientTransaction = new Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
        break;
      case "ACK":
        this.clientTransaction = new Transactions.AckClientTransaction(this, this.request, this.ua.transport);
        break;
      default:
        this.clientTransaction = new Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
    }
    this.clientTransaction.send();
  },

  /**
   * Callback fired when receiving a request timeout error from the client transaction.
   * To be re-defined by the applicant.
   */
  onRequestTimeout: function() {
    this.logger.log('******************** onRequestTimeout : '+this.applicant);
    this.applicant.onRequestTimeout();
  },

  /**
   * Callback fired when receiving a transport error from the client transaction.
   * To be re-defined by the applicant.
   */
  onTransportError: function() {
    this.applicant.onTransportError();
  },

  /**
   * Called from client transaction when receiving a correct response to the request.
   * Authenticate request if needed or pass the response back to the applicant.
   */
  receiveResponse: function(response) {
    var cseq, challenge, authorization_header_name,
      status_code = response.status_code;
    this.logger.log('receiveResponse: callbacks : ' + this.callbacks);


    /*
     * Authentication
     * Authenticate once. _challenged_ flag used to avoid infinite authentications.
     */
    if ((status_code === 401 || status_code === 407)) {

      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
      if (response.status_code === 401) {
        challenge = response.parseHeader('www-authenticate');
        authorization_header_name = 'authorization';
      } else {
        challenge = response.parseHeader('proxy-authenticate');
        authorization_header_name = 'proxy-authorization';
      }

      // Verify it seems a valid challenge.
      if (!challenge) {
        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');
        this.applicant.receiveResponse(response);
        return;
      }

      if (!this.challenged || (!this.staled && challenge.stale === true)) {
        if (!this.credentials) {
          this.credentials = new DigestAuthentication(this.ua);
        }

        // Verify that the challenge is really valid.
        if (!this.credentials.authenticate(this.request, challenge)) {
          this.applicant.receiveResponse(response);
          return;
        }
        this.challenged = true;

        if (challenge.stale) {
          this.staled = true;
        }

        if (response.method === ExSIP_C.REGISTER) {
          cseq = this.applicant.cseq += 1;
        } else if (this.request.dialog) {
          cseq = this.request.dialog.local_seqnum += 1;
        } else {
          cseq = this.request.cseq + 1;
          this.request.cseq = cseq;
        }
        this.request.setHeader('cseq', cseq + ' ' + this.method);

        this.request.setHeader(authorization_header_name, this.credentials.toString());
        this.send();
      } else {
        this.applicant.receiveResponse(response);
      }
    } else {
      this.applicant.receiveResponse(response);
    }

    switch (true) {
      case /^1[0-9]{2}$/.test(response.status_code):
        break;
      case /^2[0-9]{2}$/.test(response.status_code):
        if (this.callbacks.success) {
          this.callbacks.success();
        }
        break;
      default:
        if (this.callbacks.failure) {
          this.callbacks.failure(response);
        }
        break;
    }

  }
};
},{"./Constants":500,"./DigestAuthentication":503,"./Transactions":521,"./UA":523}],519:[function(require,module,exports){
module.exports = {
  OutgoingRequest: OutgoingRequest,
  IncomingRequest: IncomingRequest,
  IncomingResponse: IncomingResponse
};


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var Utils = require('./Utils');
var NameAddrHeader = require('./NameAddrHeader');
var Grammar = require('./Grammar');


/**
 * -param {String} method request method
 * -param {String} ruri request uri
 * -param {UA} ua
 * -param {Object} params parameters that will have priority over ua.configuration parameters:
 * <br>
 *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set
 * -param {Object} [headers] extra headers
 * -param {String} [body]
 */
function OutgoingRequest(method, ruri, ua, params, extraHeaders, body) {
  var
    to,
    from,
    call_id,
    cseq;

  params = params || {};

  this.logger = ua.getLogger('ExSIP.sipmessage');

  this.logger.debug('OutgoingRequest.extraHeaders : '+method+', '+ruri+', '+extraHeaders);
  // Mandatory parameters check
  if(!method || !ruri || !ua) {
    return null;
  }

  this.ua = ua;
  this.headers = {};
  this.method = method;
  this.ruri = ruri;
  this.body = body;
  this.extraHeaders = extraHeaders && extraHeaders.slice() || [];
this.logger.debug('OutgoingRequest.extraHeaders 2 : '+this.extraHeaders);
  // Fill the Common SIP Request Headers

  // Route
  if (params.route_set) {
    this.setHeader('route', params.route_set);
  } else if (ua.configuration.use_preloaded_route){
    this.setHeader('route', ua.transport.server.sip_uri);
  }

  // Via
  // Empty Via header. Will be filled by the client transaction.
  this.setHeader('via', '');

  // Max-Forwards
  this.setHeader('max-forwards', ExSIP_C.MAX_FORWARDS);

  // To
  to = (params.to_display_name || params.to_display_name === 0) ? '"' + params.to_display_name + '" ' : '';
  var toUri = (params.to_uri || ruri);
  to += '<' + (ua.configuration.enable_ims && toUri.isPhoneNumber() && toUri.toString().indexOf(';user=phone') === -1 ? toUri +";user=phone" : toUri) + '>';
  to += params.to_tag ? ';tag=' + params.to_tag : '';
  this.to = new NameAddrHeader.parse(to);
  this.setHeader('to', to);


  // From
  var fromName;
  if (params.from_display_name || params.from_display_name === 0) {
    fromName = '"' + params.from_display_name + '" ';
  } else if (ua.configuration.display_name) {
    fromName = '"' + ua.configuration.display_name + '" ';
  } else {
    fromName = '';
  }
  var fromUri = (params.from_uri || ua.configuration.uri);
  fromName += '<' + (ua.configuration.enable_ims && fromUri.isPhoneNumber() && fromUri.toString().indexOf(';user=phone') === -1 ? fromUri +";user=phone" : fromUri) + '>';
  var fromTag = ';tag=' + (params.from_tag || Utils.newTag());
  from = fromName + fromTag;
  this.from = new NameAddrHeader.parse(from);
  this.setHeader('from', from);

  // Call-ID
  call_id = params.call_id || (ua.configuration.exsip_id + Utils.createRandomToken(15));
  this.call_id = call_id;
  this.setHeader('call-id', call_id);

  // CSeq
  cseq = params.cseq || Math.floor(Math.random() * 10000);
  this.cseq = cseq;
  this.setHeader('cseq', cseq + ' ' + method);

  // P-Asserted-Identity
  if(ua.configuration.enable_ims) {
    this.setHeader('P-Asserted-Identity', fromName);
  } else if(ua.configuration.p_asserted_identity) {
    this.setHeader('P-Asserted-Identity', ua.configuration.p_asserted_identity);
  }
}

OutgoingRequest.prototype = {
  /**
   * Replace the the given header by the given value.
   * -param {String} name header name
   * -param {String | Array} value header value
   */
  setHeader: function(name, value) {
    this.headers[Utils.headerize(name)] = (value instanceof Array) ? value : [value];
  },

  /**
   * Get the value of the given header name at the given position.
   * -param {String} name header name
   * -returns {String|undefined} Returns the specified header, null if header doesn't exist.
   */
  getHeader: function(name) {
    var regexp, idx,
      length = this.extraHeaders.length,
      header = this.headers[Utils.headerize(name)];

    if(header) {
      if(header[0]) {
        return header[0];
      }
    } else {
      regexp = new RegExp('^\\s*'+ name +'\\s*:','i');
      for (idx=0; idx<length; idx++) {
        header = this.extraHeaders[idx];
        if (regexp.test(header)) {
          return header.substring(header.indexOf(':')+1).trim();
        }
      }
    }

    return;
  },

  /**
   * Get the header/s of the given name.
   * -param {String} name header name
   * -returns {Array} Array with all the headers of the specified name.
   */
  getHeaders: function(name) {
    var idx, length, regexp,
      header = this.headers[Utils.headerize(name)],
      result = [];

    if (header) {
      length = header.length;
      for (idx = 0; idx < length; idx++) {
        result.push(header[idx]);
      }
      return result;
    } else {
      length = this.extraHeaders.length;
      regexp = new RegExp('^\\s*'+ name +'\\s*:','i');
      for (idx=0; idx<length; idx++) {
        header = this.extraHeaders[idx];
        if (regexp.test(header)) {
          result.push(header.substring(header.indexOf(':')+1).trim());
        }
      }
      return result;
    }
  },

  /**
   * Verify the existence of the given header.
   * -param {String} name header name
   * -returns {boolean} true if header with given name exists, false otherwise
   */
  hasHeader: function(name) {
    var regexp, idx,
      length = this.extraHeaders.length;

    if (this.headers[Utils.headerize(name)]) {
      return true;
    } else {
      regexp = new RegExp('^\\s*'+ name +'\\s*:','i');
      for (idx=0; idx<length; idx++) {
        if (regexp.test(this.extraHeaders[idx])) {
          return true;
        }
      }
    }

    return false;
  },

  toString: function() {
    var msg = '', header, length, idx,
      supported = [];

    msg += this.method + ' ' + (this.ua.configuration.enable_ims && this.ruri.isPhoneNumber() ? this.ruri + ";user=phone" : this.ruri) + ' SIP/2.0\r\n';

    for (header in this.headers) {
      length = this.headers[header].length;
      for (idx = 0; idx < length; idx++) {
        msg += header + ': ' + this.headers[header][idx] + '\r\n';
      }
    }

    length = this.extraHeaders.length;
    for (idx = 0; idx < length; idx++) {
      msg += this.extraHeaders[idx].trim() +'\r\n';
    }

    // Supported
    switch (this.method) {
      case ExSIP_C.REGISTER:
        supported.push('path', 'gruu');
        break;
      case ExSIP_C.INVITE:
        if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {
          supported.push('gruu');
        }
        break;
    }

    supported.push('outbound');

    // Allow
    if(!this.hasHeader('Allow')) {
      msg += 'Allow: '+ ExSIP_C.ALLOWED_METHODS +'\r\n';      
    }

    if(!this.hasHeader('Supported')) {
      msg += 'Supported: ' +  supported +'\r\n';
    }
    
    msg += 'User-Agent: ' + ExSIP_C.USER_AGENT +'\r\n';

    if(this.body) {
      length = Utils.str_utf8_length(this.body);
      msg += 'Content-Length: ' + length + '\r\n\r\n';
      msg += this.body;
    } else {
      msg += 'Content-Length: 0\r\n\r\n';
    }

    return msg;
  }
};


function IncomingMessage(){
  this.data = null;
  this.headers = null;
  this.method =  null;
  this.via = null;
  this.via_branch = null;
  this.call_id = null;
  this.cseq = null;
  this.from = null;
  this.from_tag = null;
  this.to = null;
  this.to_tag = null;
  this.body = null;
}

IncomingMessage.prototype = {
  /**
  * Insert a header of the given name and value into the last position of the
  * header array.
  */
  addHeader: function(name, value) {
    var header = { raw: value };

    name = Utils.headerize(name);

    if(this.headers[name]) {
      this.headers[name].push(header);
    } else {
      this.headers[name] = [header];
    }
  },

  getHeader: function(name) {
    var header = this.headers[Utils.headerize(name)];

    if(header) {
      if(header[0]) {
        return header[0].raw;
      }
    } else {
      return;
    }
  },

  /**
   * Get the header/s of the given name.
   */
  getHeaders: function(name) {
    var idx, length,
      header = this.headers[Utils.headerize(name)],
      result = [];

    if(!header) {
      return [];
    }

    length = header.length;
    for (idx = 0; idx < length; idx++) {
      result.push(header[idx].raw);
    }

    return result;
  },

  /**
   * Verify the existence of the given header.
   */
  hasHeader: function(name) {
    return(this.headers[Utils.headerize(name)]) ? true : false;
  },

  /**
  * Parse the given header on the given index.
  * -param {String} name header name
  * -param {Number} [idx=0] header index
  * -returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
  */
  parseHeader: function(name, idx) {
    var header, value, parsed;

    name = Utils.headerize(name);

    idx = idx || 0;

    if(!this.headers[name]) {
      this.logger.log('header "' + name + '" not present');
      return;
    } else if(idx >= this.headers[name].length) {
      this.logger.log('not so many "' + name + '" headers present');
      return;
    }

    header = this.headers[name][idx];
    value = header.raw;

    if(header.parsed) {
      return header.parsed;
    }

    //substitute '-' by '_' for grammar rule matching.
    parsed = Grammar.parse(value, name.replace(/-/g, '_'));

    if(parsed === -1) {
      this.headers[name].splice(idx, 1); //delete from headers
      this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
      return;
    } else {
      header.parsed = parsed;
      return parsed;
    }
  },

  /**
   * Message Header attribute selector. Alias of parseHeader.
   * -param {String} name header name
   * -param {Number} [idx=0] header index
   * -returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
   *
   * -example
   * message.s('via',3).port
   */
  s: function(name, idx) {
    return this.parseHeader(name, idx);
  },

  /**
  * Replace the value of the given header by the value.
  * -param {String} name header name
  * -param {String} value header value
  */
  setHeader: function(name, value) {
    var header = { raw: value };
    this.headers[Utils.headerize(name)] = [header];
  }
};

function IncomingRequest(ua) {
  this.logger = ua.getLogger('ExSIP.sipmessage');
  this.ua = ua;
  this.headers = {};
  this.ruri = null;
  this.transport = null;
  this.server_transaction = null;
}

IncomingRequest.prototype = new IncomingMessage();

/**
* Stateful reply.
* -param {Number} code status code
* -param {String} reason reason phrase
* -param {Object} headers extra headers
* -param {String} body body
* -param {Function} [onSuccess] onSuccess callback
* -param {Function} [onFailure] onFailure callback
*/
IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
  var rr, vias, length, idx, response,
    supported = [],
    to = this.getHeader('To'),
    r = 0,
    v = 0;

  code = code || null;
  reason = reason || null;

  // Validate code and reason values
  if (!code || (code < 100 || code > 699)) {
    throw new TypeError('Invalid status_code: '+ code);
  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
    throw new TypeError('Invalid reason_phrase: '+ reason);
  }

  reason = reason || ExSIP_C.REASON_PHRASE[code] || '';
  extraHeaders = extraHeaders && extraHeaders.slice() || [];

  response = 'SIP/2.0 ' + code + ' ' + reason + '\r\n';

  if(this.method === ExSIP_C.INVITE && code > 100 && code <= 200) {
    rr = this.getHeaders('record-route');
    length = rr.length;

    for(r; r < length; r++) {
      response += 'Record-Route: ' + rr[r] + '\r\n';
    }
  }

  vias = this.getHeaders('via');
  length = vias.length;

  for(v; v < length; v++) {
    response += 'Via: ' + vias[v] + '\r\n';
  }

  if(!this.to_tag && code > 100) {
    to += ';tag=' + Utils.newTag();
  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
    to += ';tag=' + this.to_tag;
  }

  response += 'To: ' + to + '\r\n';
  response += 'From: ' + this.getHeader('From') + '\r\n';
  response += 'Call-ID: ' + this.call_id + '\r\n';
  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';

  length = extraHeaders.length;
  for (idx = 0; idx < length; idx++) {
    response += extraHeaders[idx].trim() +'\r\n';
  }

  // Supported
  switch (this.method) {
    case ExSIP_C.INVITE:
      if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {
        supported.push('gruu');
      }
      break;
  }

  supported.push('outbound');

  // Allow and Accept
  if (this.method === ExSIP_C.OPTIONS) {
    response += 'Allow: '+ ExSIP_C.ALLOWED_METHODS +'\r\n';
    response += 'Accept: '+ ExSIP_C.ACCEPTED_BODY_TYPES +'\r\n';
  } else if (code === 405) {
    response += 'Allow: '+ ExSIP_C.ALLOWED_METHODS +'\r\n';
  } else if (code === 415 ) {
    response += 'Accept: '+ ExSIP_C.ACCEPTED_BODY_TYPES +'\r\n';
  }

  response += 'Supported: ' +  supported +'\r\n';

  if(body) {
    length = Utils.str_utf8_length(body);
    if(response.indexOf('Content-Type:') === -1) {
      response += 'Content-Type: application/sdp\r\n';      
    }
    response += 'Content-Length: ' + length + '\r\n\r\n';
    response += body;
  } else {
    response += 'Content-Length: ' + 0 + '\r\n\r\n';
  }

  this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);
};

/**
* Stateless reply.
* -param {Number} code status code
* -param {String} reason reason phrase
*/
IncomingRequest.prototype.reply_sl = function(code, reason) {
  var to, response,
    v = 0,
    vias = this.getHeaders('via'),
    length = vias.length;

  code = code || null;
  reason = reason || null;

  // Validate code and reason values
  if (!code || (code < 100 || code > 699)) {
    throw new TypeError('Invalid status_code: '+ code);
  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
    throw new TypeError('Invalid reason_phrase: '+ reason);
  }

  reason = reason || ExSIP_C.REASON_PHRASE[code] || '';

  response = 'SIP/2.0 ' + code + ' ' + reason + '\r\n';

  for(v; v < length; v++) {
    response += 'Via: ' + vias[v] + '\r\n';
  }

  to = this.getHeader('To');

  if(!this.to_tag && code > 100) {
    to += ';tag=' + Utils.newTag();
  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
    to += ';tag=' + this.to_tag;
  }

  response += 'To: ' + to + '\r\n';
  response += 'From: ' + this.getHeader('From') + '\r\n';
  response += 'Call-ID: ' + this.call_id + '\r\n';
  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
  response += 'Content-Length: ' + 0 + '\r\n\r\n';

  this.transport.send(response);
};

function IncomingResponse(ua) {
  this.logger = ua.getLogger('ExSIP.sipmessage');
  this.headers = {};
  this.status_code = null;
  this.reason_phrase = null;
}

IncomingResponse.prototype = new IncomingMessage();

},{"./Constants":500,"./Grammar":507,"./NameAddrHeader":511,"./Utils":525}],520:[function(require,module,exports){
var T1 = 500,
  T2 = 4000,
  T4 = 5000;


var Timers = {
  T1: T1,
  T2: T2,
  T4: T4,
  TIMER_B: 64 * T1,
  TIMER_D: 0  * T1,
  TIMER_F: 64 * T1,
  TIMER_H: 64 * T1,
  TIMER_I: 0  * T1,
  TIMER_J: 0  * T1,
  TIMER_K: 0  * T4,
  TIMER_L: 64 * T1,
  TIMER_M: 64 * T1,
  PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1
};

module.exports = Timers;

},{}],521:[function(require,module,exports){
module.exports = {
  C: null,
  NonInviteClientTransaction: NonInviteClientTransaction,
  InviteClientTransaction: InviteClientTransaction,
  AckClientTransaction: AckClientTransaction,
  NonInviteServerTransaction: NonInviteServerTransaction,
  InviteServerTransaction: InviteServerTransaction,
  checkTransaction: checkTransaction
};


var C = {
  // Transaction states
  STATUS_TRYING:     1,
  STATUS_PROCEEDING: 2,
  STATUS_CALLING:    3,
  STATUS_ACCEPTED:   4,
  STATUS_COMPLETED:  5,
  STATUS_TERMINATED: 6,
  STATUS_CONFIRMED:  7,

  // Transaction types
  NON_INVITE_CLIENT: 'nict',
  NON_INVITE_SERVER: 'nist',
  INVITE_CLIENT: 'ict',
  INVITE_SERVER: 'ist'
};

/**
 * Expose C object.
 */
module.exports.C = C;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var EventEmitter = require('./EventEmitter');
var Timers = require('./Timers');


function NonInviteClientTransaction(request_sender, request, transport) {
  var via,
    via_transport,
    events = ['stateChanged'];

  this.type = C.NON_INVITE_CLIENT;
  this.transport = transport;
  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
  this.request_sender = request_sender;
  this.request = request;

  this.logger = request_sender.ua.getLogger('ExSIP.transaction.nict', this.id);

  if (request_sender.ua.configuration.hack_via_tcp) {
    via_transport = 'TCP';
  }
  else if (request_sender.ua.configuration.hack_via_ws) {
    via_transport = 'WS';
  }
  else {
    via_transport = transport.server.scheme;
  }

  via = 'SIP/2.0/' + via_transport;
  via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

  this.request.setHeader('via', via);

  this.request_sender.ua.newTransaction(this);

  this.initEvents(events);
}


NonInviteClientTransaction.prototype = new EventEmitter();

NonInviteClientTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

NonInviteClientTransaction.prototype.send = function() {
  var tr = this;

  this.stateChanged(C.STATUS_TRYING);
  this.F = setTimeout(function() {tr.timer_F();}, Timers.TIMER_F);

  if(!this.transport.send(this.request)) {
    this.onTransportError();
  }
};

NonInviteClientTransaction.prototype.onTransportError = function() {
  this.logger.debug('transport error occurred, deleting non-INVITE client transaction ' + this.id);
  clearTimeout(this.F);
  clearTimeout(this.K);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
  this.request_sender.onTransportError();
};

NonInviteClientTransaction.prototype.timer_F = function() {
  this.logger.debug('Timer F expired for non-INVITE client transaction ' + this.id);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
  this.request_sender.onRequestTimeout();
};

NonInviteClientTransaction.prototype.timer_K = function() {
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
};

NonInviteClientTransaction.prototype.receiveResponse = function(response) {
  var
    tr = this,
    status_code = response.status_code;
  if(status_code < 200) {
    switch(this.state) {
      case C.STATUS_TRYING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_PROCEEDING);
        this.request_sender.receiveResponse(response);
        break;
    }
  } else {
    switch(this.state) {
      case C.STATUS_TRYING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_COMPLETED);
        clearTimeout(this.F);

        if(status_code === 408) {
          this.request_sender.onRequestTimeout();
        } else {
          this.request_sender.receiveResponse(response);
        }

        this.K = setTimeout(function() {tr.timer_K();}, Timers.TIMER_K);
        break;
      case C.STATUS_COMPLETED:
        break;
    }
  }
};


function InviteClientTransaction(request_sender, request, transport) {
  var via,
    tr = this,
    via_transport,
    events = ['stateChanged'];

  this.type = C.INVITE_CLIENT;
  this.transport = transport;
  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
  this.request_sender = request_sender;
  this.request = request;

  this.logger = request_sender.ua.getLogger('ExSIP.transaction.ict', this.id);

  this.logger.log('******************** request_sender : ' + request_sender);
  if (request_sender.ua.configuration.hack_via_tcp) {
    via_transport = 'TCP';
  }
  else if (request_sender.ua.configuration.hack_via_ws) {
    via_transport = 'WS';
  }
  else {
    via_transport = transport.server.scheme;
  }

  via = 'SIP/2.0/' + via_transport;
  via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

  this.request.setHeader('via', via);

  this.request_sender.ua.newTransaction(this);

  // TODO: Adding here the cancel() method is a hack that must be fixed.
  // Add the cancel property to the request.
  //Will be called from the request instance, not the transaction itself.
  this.request.cancel = function(reason) {
    tr.cancel_request(tr, reason);
  };

  this.initEvents(events);
}

InviteClientTransaction.prototype = new EventEmitter();

InviteClientTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

InviteClientTransaction.prototype.send = function() {
  var tr = this;
  this.stateChanged(C.STATUS_CALLING);
  this.B = setTimeout(function() {
    tr.timer_B();
  }, Timers.TIMER_B);

  if(!this.transport.send(this.request)) {
    this.onTransportError();
  }
};

InviteClientTransaction.prototype.onTransportError = function() {
  this.logger.debug('transport error occurred, deleting INVITE client transaction ' + this.id);
  clearTimeout(this.B);
  clearTimeout(this.D);
  clearTimeout(this.M);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);

  if (this.state !== C.STATUS_ACCEPTED) {
    this.request_sender.onTransportError();
  }
};

// RFC 6026 7.2
InviteClientTransaction.prototype.timer_M = function() {
  this.logger.debug('Timer M expired for INVITE client transaction ' + this.id);

  if(this.state === C.STATUS_ACCEPTED) {
    clearTimeout(this.B);
    this.stateChanged(C.STATUS_TERMINATED);
    this.request_sender.ua.destroyTransaction(this);
  }
};

// RFC 3261 17.1.1
InviteClientTransaction.prototype.timer_B = function() {
  this.logger.debug('Timer B expired for INVITE client transaction ' + this.id);
  if(this.state === C.STATUS_CALLING) {
    this.stateChanged(C.STATUS_TERMINATED);
    this.request_sender.ua.destroyTransaction(this);
    this.logger.debug('InviteClientTransaction.timer_B : ' + this.request_sender);
    this.request_sender.onRequestTimeout();
  }
};

InviteClientTransaction.prototype.timer_D = function() {
  this.logger.debug('Timer D expired for INVITE client transaction ' + this.id);
  clearTimeout(this.B);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
};

InviteClientTransaction.prototype.sendACK = function(response) {
  var tr = this;

  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
  this.ack += 'Via: ' + this.request.headers.Via.toString() + '\r\n';

  if(this.request.headers.Route) {
    this.ack += 'Route: ' + this.request.headers.Route.toString() + '\r\n';
  }

  this.ack += 'To: ' + response.getHeader('to') + '\r\n';
  this.ack += 'From: ' + this.request.headers.From.toString() + '\r\n';
  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
  this.ack += 'CSeq: ' + this.request.headers.CSeq.toString().split(' ')[0];
  this.ack += ' ACK\r\n';
  this.ack += 'Content-Length: 0\r\n\r\n';

  this.D = setTimeout(function() {tr.timer_D();}, Timers.TIMER_D);

  this.transport.send(this.ack);
};

InviteClientTransaction.prototype.cancel_request = function(tr, reason) {
  var request = tr.request;

  this.cancel = ExSIP_C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
  this.cancel += 'Via: ' + request.headers.Via.toString() + '\r\n';

  if(this.request.headers.Route) {
    this.cancel += 'Route: ' + request.headers.Route.toString() + '\r\n';
  }

  this.cancel += 'To: ' + request.headers.To.toString() + '\r\n';
  this.cancel += 'From: ' + request.headers.From.toString() + '\r\n';
  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
  this.cancel += 'CSeq: ' + request.headers.CSeq.toString().split(' ')[0] +
  ' CANCEL\r\n';

  if(reason) {
    this.cancel += 'Reason: ' + reason + '\r\n';
  }

  this.cancel += 'Content-Length: 0\r\n\r\n';

  // Send only if a provisional response (>100) has been received.
  if(this.state === C.STATUS_PROCEEDING) {
    this.transport.send(this.cancel);
  }
};

InviteClientTransaction.prototype.receiveResponse = function(response) {
  var
  tr = this,
  status_code = response.status_code;

  if(status_code >= 100 && status_code <= 199) {
    this.logger.debug('received 1xx : '+this.state);
    switch(this.state) {
      case C.STATUS_CALLING:
        this.stateChanged(C.STATUS_PROCEEDING);
        this.request_sender.receiveResponse(response);
        break;
      case C.STATUS_PROCEEDING:
        this.request_sender.receiveResponse(response);
        break;
    }
  } else if(status_code >= 200 && status_code <= 299) {
    switch(this.state) {
      case C.STATUS_CALLING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_ACCEPTED);
        this.M = setTimeout(function() {
          tr.timer_M();
        }, Timers.TIMER_M);
        this.request_sender.receiveResponse(response);
        break;
      case C.STATUS_ACCEPTED:
        this.request_sender.receiveResponse(response);
        break;
    }
  } else if(status_code >= 300 && status_code <= 699) {
      switch(this.state) {
        case C.STATUS_CALLING:
        case C.STATUS_PROCEEDING:
          this.state = C.STATUS_COMPLETED;
          this.sendACK(response);
          if(status_code === 503) {
            var options = {code: 503, reason: 'Service Unavailable', retryCallback: function(transport){
              transport.ua.once("connected", function(e){
                if(transport === e.data.transport) {
                  tr.send();
                }
              });
            }};
            this.request_sender.ua.onTransportError(this.request_sender.ua.transport, options);
          } else {
            this.request_sender.receiveResponse(response);
          }
          break;
        case C.STATUS_COMPLETED:
          this.sendACK(response);
          break;
      }
    }
};


function AckClientTransaction(request_sender, request, transport) {
  var via,
    via_transport;

  this.transport = transport;
  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
  this.request_sender = request_sender;
  this.request = request;

  this.logger = request_sender.ua.getLogger('ExSIP.transaction.nict', this.id);

  if (request_sender.ua.configuration.hack_via_tcp) {
    via_transport = 'TCP';
  }
  else if (request_sender.ua.configuration.hack_via_ws) {
    via_transport = 'WS';
  }
  else {
    via_transport = transport.server.scheme;
  }

  via = 'SIP/2.0/' + via_transport;
  via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

  this.request.setHeader('via', via);
}

AckClientTransaction.prototype = new EventEmitter();

AckClientTransaction.prototype.send = function() {
  if(!this.transport.send(this.request)) {
    this.onTransportError();
  }
};

AckClientTransaction.prototype.onTransportError = function() {
  this.logger.debug('transport error occurred, for an ACK client transaction ' + this.id);
  this.request_sender.onTransportError();
};


function NonInviteServerTransaction(request, ua) {
  var events = ['stateChanged'];

  this.type = C.NON_INVITE_SERVER;
  this.id = request.via_branch;
  this.request = request;
  this.transport = request.transport;
  this.ua = ua;
  this.last_response = '';
  request.server_transaction = this;

  this.logger = ua.getLogger('ExSIP.transaction.nist', this.id);

  this.state = C.STATUS_TRYING;

  ua.newTransaction(this);

  this.initEvents(events);
}

NonInviteServerTransaction.prototype = new EventEmitter();

NonInviteServerTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

NonInviteServerTransaction.prototype.timer_J = function() {
  this.logger.debug('Timer J expired for non-INVITE server transaction ' + this.id);
  this.stateChanged(C.STATUS_TERMINATED);
  this.ua.destroyTransaction(this);
};

NonInviteServerTransaction.prototype.onTransportError = function() {
  if (!this.transportError) {
    this.transportError = true;

    this.logger.debug('transport error occurred, deleting non-INVITE server transaction ' + this.id);

    clearTimeout(this.J);
    this.stateChanged(C.STATUS_TERMINATED);
    this.ua.destroyTransaction(this);
  }
};

NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {
  var tr = this;

  if(status_code === 100) {
    /* RFC 4320 4.1
     * 'A SIP element MUST NOT
     * send any provisional response with a
     * Status-Code other than 100 to a non-INVITE request.'
     */
    switch(this.state) {
      case C.STATUS_TRYING:
        this.stateChanged(C.STATUS_PROCEEDING);
        if(!this.transport.send(response))  {
          this.onTransportError();
        }
        break;
      case C.STATUS_PROCEEDING:
        this.last_response = response;
        if(!this.transport.send(response)) {
          this.onTransportError();
          if (onFailure) {
            onFailure();
          }
        } else if (onSuccess) {
          onSuccess();
        }
        break;
    }
  } else if(status_code >= 200 && status_code <= 699) {
    switch(this.state) {
      case C.STATUS_TRYING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_COMPLETED);
        this.last_response = response;
        if(Timers.TIMER_J === 0) {
            tr.timer_J();
        } else {
          this.J = setTimeout(function() {
            tr.timer_J();
          }, Timers.TIMER_J);
        }
        if(!this.transport.send(response)) {
          this.onTransportError();
          if (onFailure) {
            onFailure();
          }
        } else if (onSuccess) {
          onSuccess();
        }
        break;
      case C.STATUS_COMPLETED:
        break;
    }
  }
};


function InviteServerTransaction(request, ua) {
  var events = ['stateChanged'];

  this.type = C.INVITE_SERVER;
  this.id = request.via_branch;
  this.request = request;
  this.transport = request.transport;
  this.ua = ua;
  this.last_response = '';
  request.server_transaction = this;

  this.logger = ua.getLogger('ExSIP.transaction.ist', this.id);

  this.state = C.STATUS_PROCEEDING;

  ua.newTransaction(this);

  this.resendProvisionalTimer = null;

  request.reply(100);

  this.initEvents(events);
}

InviteServerTransaction.prototype = new EventEmitter();

InviteServerTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

InviteServerTransaction.prototype.timer_H = function() {
  this.logger.debug('Timer H expired for INVITE server transaction ' + this.id);

  if(this.state === C.STATUS_COMPLETED) {
    this.logger.log('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
  }

  this.stateChanged(C.STATUS_TERMINATED);
  this.ua.destroyTransaction(this);
};

InviteServerTransaction.prototype.timer_I = function() {
  this.stateChanged(C.STATUS_TERMINATED);
  this.ua.destroyTransaction(this);
};

// RFC 6026 7.1
InviteServerTransaction.prototype.timer_L = function() {
  this.logger.debug('Timer L expired for INVITE server transaction ' + this.id);

  if(this.state === C.STATUS_ACCEPTED) {
    this.stateChanged(C.STATUS_TERMINATED);
    this.ua.destroyTransaction(this);
  }
};

InviteServerTransaction.prototype.onTransportError = function() {
  if (!this.transportError) {
    this.transportError = true;

    this.logger.debug('transport error occurred, deleting INVITE server transaction ' + this.id);

    if (this.resendProvisionalTimer !== null) {
      clearInterval(this.resendProvisionalTimer);
      this.resendProvisionalTimer = null;
    }

    clearTimeout(this.L);
    clearTimeout(this.H);
    clearTimeout(this.I);

    this.stateChanged(C.STATUS_TERMINATED);
    this.ua.destroyTransaction(this);
  }
};

InviteServerTransaction.prototype.resend_provisional = function() {
  if(!this.transport.send(this.last_response)) {
    this.onTransportError();
  }
};

// INVITE Server Transaction RFC 3261 17.2.1
InviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {
  var tr = this;

  if(status_code >= 100 && status_code <= 199) {
    switch(this.state) {
      case C.STATUS_PROCEEDING:
        if(!this.transport.send(response)) {
          this.onTransportError();
        }
        this.last_response = response;
        break;
    }
  }

  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
    if(this.resendProvisionalTimer === null) {
      this.resendProvisionalTimer = setInterval(function() {
        tr.resend_provisional();}, Timers.PROVISIONAL_RESPONSE_INTERVAL);
    }
  } else if(status_code >= 200 && status_code <= 299) {
    switch(this.state) {
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_ACCEPTED);
        this.last_response = response;
        this.L = setTimeout(function() {
          tr.timer_L();
        }, Timers.TIMER_L);

        if (this.resendProvisionalTimer !== null) {
          clearInterval(this.resendProvisionalTimer);
          this.resendProvisionalTimer = null;
        }
        /* falls through */
        case C.STATUS_ACCEPTED:
          // Note that this point will be reached for proceeding tr.state also.
          if(!this.transport.send(response)) {
            this.onTransportError();
            if (onFailure) {
              onFailure();
            }
          } else if (onSuccess) {
            onSuccess();
          }
          break;
    }
  } else if(status_code >= 300 && status_code <= 699) {
    switch(this.state) {
      case C.STATUS_PROCEEDING:
        if (this.resendProvisionalTimer !== null) {
          clearInterval(this.resendProvisionalTimer);
          this.resendProvisionalTimer = null;
        }

        if(!this.transport.send(response)) {
          this.onTransportError();
          if (onFailure) {
            onFailure();
          }
        } else {
          this.stateChanged(C.STATUS_COMPLETED);
          this.H = setTimeout(function() {
            tr.timer_H();
          }, Timers.TIMER_H);
          if (onSuccess) {
            onSuccess();
          }
        }
        break;
    }
  }
};

/**
 * INVITE:
 *  _true_ if retransmission
 *  _false_ new request
 *
 * ACK:
 *  _true_  ACK to non2xx response
 *  _false_ ACK must be passed to TU (accepted state)
 *          ACK to 2xx response
 *
 * CANCEL:
 *  _true_  no matching invite transaction
 *  _false_ matching invite transaction and no final response sent
 *
 * OTHER:
 *  _true_  retransmission
 *  _false_ new request
 */
function checkTransaction(ua, request) {
  var tr;

  switch(request.method) {
    case ExSIP_C.INVITE:
      tr = ua.transactions.ist[request.via_branch];
      if(tr) {
        switch(tr.state) {
          case C.STATUS_PROCEEDING:
            tr.transport.send(tr.last_response);
            break;

            // RFC 6026 7.1 Invite retransmission
            //received while in C.STATUS_ACCEPTED state. Absorb it.
          case C.STATUS_ACCEPTED:
            break;
        }
        console.log("checkTransaction failed for INVITE request and server transaction in state : "+tr.state);
        return true;
      }
      break;
    case ExSIP_C.ACK:
      tr = ua.transactions.ist[request.via_branch];

      // RFC 6026 7.1
      if(tr) {
        if(tr.state === C.STATUS_ACCEPTED) {
          return false;
        } else if(tr.state === C.STATUS_COMPLETED) {
          tr.state = C.STATUS_CONFIRMED;
          tr.I = setTimeout(function() {tr.timer_I();}, Timers.TIMER_I);
          return true;
        }
      }
      // ACK to 2XX Response.
      else {
        return false;
      }
      break;
    case ExSIP_C.CANCEL:
      tr = ua.transactions.ist[request.via_branch];
      if(tr) {
        request.reply_sl(200);
        if(tr.state === C.STATUS_PROCEEDING) {
          return false;
        } else {
          console.log("checkTransaction failed for CANCEL request and server transaction in state : "+tr.state);
          return true;
        }
      } else {
        request.reply_sl(481);
        console.log("checkTransaction failed for CANCEL request and no server transaction");
        return true;
      }
      break;
    default:

      // Non-INVITE Server Transaction RFC 3261 17.2.2
      console.log('***************** nist : ', Object.keys(ua.transactions.nist));
      tr = ua.transactions.nist[request.via_branch];
      if(tr) {
        switch(tr.state) {
          case C.STATUS_TRYING:
            break;
          case C.STATUS_PROCEEDING:
          case C.STATUS_COMPLETED:
            tr.transport.send(tr.last_response);
            break;
        }
        console.log("checkTransaction failed for non invite server transaction in state : "+tr.state);
        return true;
      }
      break;
  }
}

},{"./Constants":500,"./EventEmitter":504,"./Timers":520}],522:[function(require,module,exports){
(function (global){
module.exports = Transport;


var C = {
  // Transport status codes
  STATUS_READY:        0,
  STATUS_DISCONNECTED: 1,
  STATUS_ERROR:        2
};


/**
 * Expose C object.
 */
Transport.C = C;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var Parser = require('./Parser');
var UA = require('./UA');
var SIPMessage = require('./SIPMessage');
var sanityCheck = require('./sanityCheck');
// Conditional module loading.
var WebSocket;  // jshint ignore:line
var isNode = false;
if (global.WebSocket) {
  WebSocket = global.WebSocket;  // jshint ignore:line
}
else {
  WebSocket = require('ws');  // jshint ignore:line
  isNode = true;
}


function Transport(ua, server) {
  this.logger = ua.getLogger('ExSIP.transport');
  this.ua = ua;
  this.ws = null;
  this.server = server;
  this.reconnection_attempts = 0;
  this.closed = false;
  this.connected = false;
  this.reconnectTimer = null;
  this.lastTransportError = {};

  if (isNode) {
    this.ws_options = this.ua.configuration.node_ws_options;
    this.ws_options.protocol = 'sip';
    this.ws_options.headers = {
      'User-Agent': ExSIP_C.USER_AGENT
    };
  }
}

Transport.prototype = {
  /**
   * Send a message.
   */
  send: function(msg) {
    var message = msg.toString();

    if(this.ws && this.readyState() === WebSocket.OPEN) {
      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('sending WebSocket message:\n\n' + message + '\n');
      }
      this.ws.send(message);
      return true;
    } else {
      this.logger.warn('unable to send message, WebSocket is not open');
      return false;
    }
  },

  readyState: function() {
    return this.ws.readyState;
  },

  /**
  * Disconnect socket.
  */
  disconnect: function() {
    if(this.ws) {
      // Clear reconnectTimer
      clearTimeout(this.reconnectTimer);
      // TODO: should make this.reconnectTimer = null here?

      this.closed = true;
      this.logger.debug('closing WebSocket ' + this.server.ws_uri);
      this.ws.close();
    }

    // TODO: Why this??
    if (this.reconnectTimer !== null) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
      this.ua.emit('disconnected', this.ua, {
        transport: this,
        code: this.lastTransportError.code,
        reason: this.lastTransportError.reason
      });
    }
  },

  /**
  * Connect socket.
  */
  connect: function() {
    var transport = this;

    if(this.ws && (this.readyState() === WebSocket.OPEN || this.readyState() === WebSocket.CONNECTING)) {
      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');
      return false;
    }

    if(this.ws) {
      this.ws.close();
    }

    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);
    this.ua.onTransportConnecting(this,
      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);

    try {
      if (! isNode) {
        this.ws = new WebSocket(this.server.ws_uri, 'sip');
        this.ws.binaryType = 'arraybuffer';
      }
      else {
        this.ws = new WebSocket(this.server.ws_uri, this.ws_options);
      }
      this.ua.usedServers.push(this.server);

      this.ws.onopen = function() {
        transport.onOpen();
      };

      this.ws.onclose = function(e) {
        transport.onClose(e);
      };

      this.ws.onmessage = function(e) {
        transport.onMessage(e);
      };

      this.ws.onerror = function(e) {
        transport.onError(e);
      };
    } catch(e) {
      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
      this.lastTransportError.code = null;
      this.lastTransportError.reason = e.message;
      this.ua.onTransportError(this);
    }
  },

  // Transport Event Handlers

  onOpen: function() {
    this.connected = true;

    this.logger.debug('WebSocket ' + this.server.ws_uri + ' connected');
    // Clear reconnectTimer since we are not disconnected
    if (this.reconnectTimer !== null) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    // Reset reconnection_attempts
    this.reconnection_attempts = 0;
    // Disable closed
    this.closed = false;
    // Trigger onTransportConnected callback
    this.ua.onTransportConnected(this);
  },

  onClose: function(e) {
    var connected_before = this.connected;

    this.connected = false;
    this.lastTransportError.code = e.code;
    this.lastTransportError.reason = e.reason;
    this.logger.debug('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');

    if(e.wasClean === false) {
      this.logger.warn('WebSocket abrupt disconnection');
    }
    // Transport was connected
    if(connected_before === true) {
      this.ua.onTransportClosed(this);
      // Check whether the user requested to close.
      if(!this.closed) {
        this.reConnect();
      } else {
        this.ua.emit('disconnected', this.ua, {
          transport: this,
          code: this.lastTransportError.code,
          reason: this.lastTransportError.reason
        });
      }
    } else {
      // This is the first connection attempt
      // May be a network error (or may be UA.stop() was called)
      this.ua.onTransportError(this);
    }
  },

  onMessage: function(e) {
    var message, transaction,
      data = e.data;

    // CRLF Keep Alive response from server. Ignore it.
    if(data === '\r\n') {
      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('received WebSocket message with CRLF Keep Alive response');
      }
      return;
    }

    // WebSocket binary message.
    else if (typeof data !== 'string') {
      try {
        data = String.fromCharCode.apply(null, new Uint8Array(data));
      } catch(evt) {
        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');
        return;
      }

      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('received WebSocket binary message:\n\n' + data + '\n');
      }
    }

    // WebSocket text message.
    else {
      this.logger.log('onMessage : '+this.ua.configuration.trace_sip);
      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('received WebSocket text message:\n\n' + data + '\n');
      }
    }

    message = Parser.parseMessage(data, this.ua);

    if (! message) {
      return;
    }

    if(this.ua.status === UA.C.STATUS_USER_CLOSED && message instanceof SIPMessage.IncomingRequest) {
      return;
    }

    // Do some sanity check
    if(! sanityCheck(message, this.ua, this)) {
      return;
    }

    if(message instanceof SIPMessage.IncomingRequest) {
      message.transport = this;
      this.ua.receiveRequest(message);
    } else if(message instanceof SIPMessage.IncomingResponse) {
      /* Unike stated in 18.1.2, if a response does not match
      * any transaction, it is discarded here and no passed to the core
      * in order to be discarded there.
      */
      switch(message.method) {
        case ExSIP_C.INVITE:
          transaction = this.ua.transactions.ict[message.via_branch];
          if(transaction) {
            transaction.receiveResponse(message);
          }
          break;
        case ExSIP_C.ACK:
          // Just in case ;-)
          break;
        default:
          transaction = this.ua.transactions.nict[message.via_branch];
          if(transaction) {
            transaction.receiveResponse(message);
          }
          break;
      }
    }
  },

  onError: function(e) {
    this.logger.warn('WebSocket connection error: ' + e);
  },

  /**
  * Reconnection attempt logic.
  */
  reConnect: function() {
    var transport = this;

    this.reconnection_attempts += 1;

    if(this.reconnection_attempts > this.ua.configuration.ws_server_max_reconnection) {
      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
      this.ua.onTransportError(this);
    } else {
      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')'+ ' (reconnection timeout '+this.ua.configuration.ws_server_reconnection_timeout+')');

      if(this.ua.configuration.ws_server_reconnection_timeout === 0) {
        transport.connect();
      } else {
        this.reconnectTimer = setTimeout(function() {
          transport.connect();
          transport.reconnectTimer = null;
        }, this.ua.configuration.ws_server_reconnection_timeout * 1000);
      }
    }
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Constants":500,"./Parser":512,"./SIPMessage":519,"./UA":523,"./sanityCheck":527,"ws":498}],523:[function(require,module,exports){
module.exports = UA;


var C = {
  // UA status codes
  STATUS_INIT: 0,
  STATUS_READY: 1,
  STATUS_USER_CLOSED: 2,
  STATUS_NOT_READY: 3,

  // UA error codes
  CONFIGURATION_ERROR: 1,
  NETWORK_ERROR: 2
};

/**
 * Expose C object.
 */
UA.C = C;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var LoggerFactory = require('./LoggerFactory');
var EventEmitter = require('./EventEmitter');
var Registrator = require('./Registrator');
var RTCSession = require('./RTCSession');
var Message = require('./Message');
var Transport = require('./Transport');
var Transactions = require('./Transactions');
var Transactions = require('./Transactions');
var Utils = require('./Utils');
var WebRTC = require('./WebRTC');
var Exceptions = require('./Exceptions');
var URI = require('./URI');
var Grammar = require('./Grammar');
var Utils = require('./Utils');



/**
 * The User-Agent class.
 * @class UA
 * @param {Object} configuration Configuration parameters.
 * @throws {Exceptions.ConfigurationError} If a configuration parameter is invalid.
 * @throws {TypeError} If no configuration is given.
 */
function UA(configuration) {
  var events = [
    'connecting',
    'connected',
    'disconnected',
    'newTransaction',
    'transactionDestroyed',
    'registered',
    'unregistered',
    'registrationFailed',
    'newRTCSession',
    'newMessage',
    'onReInvite'
  ];

  this.log = new LoggerFactory(configuration);
  this.logger = this.getLogger('ua');
  this.usedServers = [];
  this.rtcMediaHandlerOptions = {};

  this.cache = {
    credentials: {}
  };

  this.configuration = {};
  this.dynConfiguration = {};
  this.dialogs = {};

  //User actions outside any session/dialog (MESSAGE)
  this.applicants = {};

  this.sessions = {};
  this.transport = null;
  this.contact = null;
  this.status = C.STATUS_INIT;
  this.error = null;
  this.transactions = {
    nist: {},
    nict: {},
    ist: {},
    ict: {}
  };

  // Custom UA empty object for high level use
  this.data = {};

  this.transportRecoverAttempts = 0;
  this.transportRecoveryTimer = null;

  Object.defineProperties(this, {
    transactionsCount: {
      get: function() {
        var type,
          transactions = ['nist', 'nict', 'ist', 'ict'],
          count = 0;

        for (type in transactions) {
          count += Object.keys(this.transactions[transactions[type]]).length;
        }

        return count;
      }
    },

    nictTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.nict).length;
      }
    },

    nistTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.nist).length;
      }
    },

    ictTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.ict).length;
      }
    },

    istTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.ist).length;
      }
    }
  });

  /**
   * Load configuration
   */

  if (configuration === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Apply log configuration if present
  if (configuration.log) {
    if (configuration.log.hasOwnProperty('builtinEnabled')) {
      this.log.builtinEnabled = configuration.log.builtinEnabled;
    }

    if (configuration.log.hasOwnProperty('level')) {
      this.log.level = configuration.log.level;
    }

    if (configuration.log.hasOwnProperty('connector')) {
      this.log.connector = configuration.log.connector;
    }
  }

  try {
    this.loadConfig(configuration);
    this.initEvents(events);
  } catch (e) {
    this.status = C.STATUS_NOT_READY;
    this.error = C.CONFIGURATION_ERROR;
    throw e;
  }
}


UA.prototype = new EventEmitter();

//=================
//  High Level API
//=================
UA.prototype.isDebug = function() {
  return this.configuration.trace_sip === true;
};

/**
 * Registration state.
 * @param {Boolean}
 */
UA.prototype.isRegistered = function() {
  if (this._registrator && this._registrator.registered) {
    return true;
  } else {
    return false;
  }
};

/**
 * Connection state.
 * @param {Boolean}
 */
UA.prototype.isConnected = function() {
  if (this.transport) {
    return this.transport.connected;
  } else {
    return false;
  }
};

UA.prototype.transfer = function(transferTarget, sessionToTransfer, options) {
  var self = this;
  this.logger.log('transfer : ' + transferTarget + ' : options : ' + Utils.toString(options));
  transferTarget = Utils.normalizeTarget(transferTarget, this.configuration.hostport_params);
  if (!transferTarget) {
    sessionToTransfer.failed('local', null, ExSIP_C.causes.INVALID_TARGET);
    this.logger.warn("invalid transfer target");
    return;
  }

  var holdFailed = function() {
    self.logger.log("transfer : hold failed");
  };

  var holdSuccess = function() {
    self.logger.log("transfer : hold success - sending refer to transferee");
    self.sendReferBasic(sessionToTransfer, transferTarget, options);
  };

  self.logger.log("transfer : holding session to transfer");
  sessionToTransfer.hold(holdSuccess, holdFailed);
};

UA.prototype.attendedTransfer = function(transferTarget, sessionToTransfer, options) {
  var self = this;
  this.logger.log('attended transfer : ' + transferTarget + ' : options : ' + Utils.toString(options));
  transferTarget = Utils.normalizeTarget(transferTarget, this.configuration.hostport_params);
  if (!transferTarget) {
    this.logger.warn('invalid transfer target');
    sessionToTransfer.failed('local', null, ExSIP_C.causes.INVALID_TARGET);
    return;
  }


  var targetSession = self.newSession(options);
  targetSession.rtcMediaHandler.copy(sessionToTransfer.rtcMediaHandler);

  var holdTargetSuccess = function() {
    self.logger.log("transfer : hold target success - sending attended refer");
    self.sendReferAttended(sessionToTransfer, targetSession, transferTarget, options);
  };

  var holdTargetFailed = function() {
    self.logger.log("transfer : hold target failed");
  };

  var sendTargetInviteSuccess = function() {
    self.logger.log("transfer : send invite to target success - putting target on hold");
    targetSession.hold(holdTargetSuccess, holdTargetFailed);
  };

  var sendTargetInviteFailed = function(response) {
    self.logger.log("transfer : send invite to target failed - sending basic refer");
    if (response.status_code === 420) {
      self.sendReferBasic(sessionToTransfer, transferTarget, options);
    }
  };

  var holdFailed = function() {
    self.logger.log("transfer : hold failed");
  };

  var holdSuccess = function() {
    self.logger.log("transfer : hold success - sending invite to target");
    targetSession.sendInviteRequest(transferTarget, {
        extraHeaders: ["Require: replaces"]
      },
      sendTargetInviteSuccess, sendTargetInviteFailed);
  };

  self.logger.log("transfer : holding session to transfer");
  sessionToTransfer.hold(holdSuccess, holdFailed);
};

UA.prototype.sendReferAttended = function(sessionToTransfer, targetSession, transferTarget, options) {
  var referSession = this.getReferSession(sessionToTransfer, options);
  options = this.getReferOptions(sessionToTransfer, targetSession, options);
  var referTo = "<" + (transferTarget).toString() +
    "?Replaces=" + targetSession.dialog.id.call_id +
    "%3Bto-tag%3D" + targetSession.dialog.id.remote_tag +
    "%3Bfrom-tag%3D" + targetSession.dialog.id.local_tag + ">";
  options.extraHeaders.push('Refer-To: ' + referTo);
  referSession.sendReferRequest(sessionToTransfer, options);
};

UA.prototype.processRefer = function(sessionToTransfer, referRequest) {
  var self = this;
  referRequest.reply(202);
  var notifySuccess = function() {
    self.logger.log("Notify successful");
  };
  var notifyFailure = function() {
    self.logger.log("Notify failed");
  };
  sessionToTransfer.sendNotifyRequest({
    sdp: "SIP/2.0 100 Trying"
  }, notifySuccess, notifyFailure);
};

UA.prototype.sendReferBasic = function(sessionToTransfer, transferTarget, options) {
  var referSession = this.getReferSession(sessionToTransfer, options);
  options = this.getReferOptions(sessionToTransfer, sessionToTransfer, options);
  options.extraHeaders.push('Refer-To: <' + transferTarget + '>');
  this.logger.debug('refer options : ' + JSON.stringify(options));
  referSession.sendReferRequest(sessionToTransfer, options);
};

UA.prototype.getReferOptions = function(sessionToTransfer, targetDialogSession, options) {
  options = options || {};
  options.extraHeaders = options.extraHeaders || [];
  if (sessionToTransfer.supports("tdialog")) {
    options.extraHeaders.push('Require: tdialog');
    var localTag = targetDialogSession.dialog.isUAS() ? targetDialogSession.dialog.id.remote_tag : targetDialogSession.dialog.id.local_tag;
    var remoteTag = targetDialogSession.dialog.isUAS() ? targetDialogSession.dialog.id.local_tag : targetDialogSession.dialog.id.remote_tag;
    var targetDialog = targetDialogSession.dialog.id.call_id + ";local-tag=" + localTag + ";remote-tag=" + remoteTag;
    options.extraHeaders.push('Target-Dialog: ' + targetDialog);
  }
  return options;
};

UA.prototype.getReferSession = function(sessionToTransfer, options) {
  if (sessionToTransfer.supports("tdialog")) {
    return this.newSession(options);
  } else {
    this.logger.warn('tdialog not supported - sending refer in same session : ' + sessionToTransfer.id, this);
    return sessionToTransfer;
  }
};

UA.prototype.newSession = function(options) {
  var session = new RTCSession(this);
  session.initRtcMediaHandler(options);
  return session;
};

UA.prototype.getUserMedia = function(options, success, failure, force) {
  if (!force && this.localMedia) {
    return this.localMedia;
  }

  if (this.localMedia) {
    this.logger.log("stopping existing local media stream", this);
    this.localMedia.stop();
  }

  this.logger.log('options : ' + Utils.toString(options), this);
  var self = this;
  var constraints = options.mediaConstraints || {
    audio: true,
    video: true
  };
  WebRTC.getUserMedia(constraints,
    function(stream) {
      self.logger.log('got local media stream', self);
      self.localMedia = stream;
      success(stream);
    },
    function(e) {
      self.logger.error('unable to get user media');
      self.logger.error(e);
      failure(e);
    }
  );
};

/**
 * Gracefully close.
 *
 */
UA.prototype.stop = function() {
  var session, applicant,
    ua = this;

  this.logger.log('user requested closure...');

  // Remove dynamic settings.
  this.dynConfiguration = {};

  if (this.status === C.STATUS_USER_CLOSED) {
    this.logger.warn('UA already closed');
    return;
  }

  // Clear transportRecoveryTimer
  clearTimeout(this.transportRecoveryTimer);

  // Close registrator
  if (this._registrator) {
    this.logger.debug('closing registrator');
    this._registrator.close();
  }

  // If there are session wait a bit so CANCEL/BYE can be sent and their responses received.
  var num_sessions = Object.keys(this.sessions).length;

  // Run  _terminate_ on every Session
  for (session in this.sessions) {
    this.logger.log('closing session ' + session, this);
    this.sessions[session].terminate();
  }

  // Run  _close_ on every applicant
  for (applicant in this.applicants) {
    this.applicants[applicant].close();
  }

  this.status = C.STATUS_USER_CLOSED;
  // If there are no pending non-INVITE client or server transactions and no
  // sessions, then disconnect now. Otherwise wait for 2 seconds.
  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0 && num_sessions === 0) {
    ua.transport.disconnect();
  } else {
    setTimeout(function() {
      ua.transport.disconnect();
    }, 2000);
  }
};

UA.prototype.reconnect = function() {
  this.logger.debug('************** reconnect');
  this.stop();
  this.status = C.STATUS_INIT;
  this.start();
};

/**
 * Connect to the WS server if status = STATUS_INIT.
 * Resume UA after being closed.
 */
UA.prototype.start = function() {
  var server;

  this.logger.debug('user requested startup... : ', this.status);

  if (this.status === C.STATUS_INIT) {
    server = this.getNextWsServer({
      force: true
    });
    this.transport = new Transport(this, server);
    this.transport.connect();
  } else if (this.status === C.STATUS_USER_CLOSED) {
    this.logger.log('resuming');
    this.status = C.STATUS_READY;
    this.transport.connect();
  } else if (this.status === C.STATUS_READY) {
    this.logger.log('UA is in READY status, not resuming');
  } else {
    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');
  }

  // Set dynamic configuration.
  this.dynConfiguration.register = this.configuration.register;
};

/**
 * Register.
 */
UA.prototype.register = function() {
  this.dynConfiguration.register = true;
  this._registrator.register();
};

/**
 * Unregister.
 */
UA.prototype.unregister = function(options) {
  this.dynConfiguration.register = false;
  this._registrator.unregister(options);
};

/**
 * Get the Registrator instance.
 */
UA.prototype.registrator = function() {
  return this._registrator;
};

/**
 * Registration state.
 */
UA.prototype.isRegistered = function() {
  if (this._registrator.registered) {
    return true;
  } else {
    return false;
  }
};

/**
 * Connection state.
 */
UA.prototype.isConnected = function() {
  if (this.transport) {
    return this.transport.connected;
  } else {
    return false;
  }
};

/**
 * Make an outgoing call.
 *
 * -param {String} target
 * -param {Object} views
 * -param {Object} [options]
 *
 * -throws {TypeError}
 *
 */
UA.prototype.call = function(target, options) {
  var session;

  session = new RTCSession(this);
  session.connect(target, options);
  return session;
};

/**
 * Send a message.
 *
 * -param {String} target
 * -param {String} body
 * -param {Object} [options]
 *
 * -throws {TypeError}
 *
 */
UA.prototype.sendMessage = function(target, body, options) {
  var message;

  message = new Message(this);
  message.send(target, body, options);
};

/**
 * Normalice a string into a valid SIP request URI
 * -param {String} target
 * -returns {URI|undefined}
 */
UA.prototype.normalizeTarget = function(target) {
  return Utils.normalizeTarget(target, this.configuration.hostport_params);
};

UA.prototype.setRtcMediaHandlerOptions = function(rtcMediaHandlerOptions) {
  this.rtcMediaHandlerOptions = rtcMediaHandlerOptions;
};

UA.prototype.rtcConstraints = function() {
  return this.rtcMediaHandlerOptions ? this.rtcMediaHandlerOptions.RTCConstraints : false;
};

UA.prototype.reuseLocalMedia = function() {
  return this.rtcMediaHandlerOptions ? this.rtcMediaHandlerOptions.reuseLocalMedia : false;
};

//===============================
//  Private (For internal use)
//===============================

UA.prototype.saveCredentials = function(credentials) {
  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
};

UA.prototype.getCredentials = function(request) {
  var realm, credentials;

  realm = request.ruri.host;

  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
    credentials = this.cache.credentials[realm][request.ruri];
    credentials.method = request.method;
  }

  return credentials;
};

UA.prototype.getLogger = function(category, label) {
  return this.log.getLogger(category, label);
};


//==========================
// Event Handlers
//==========================

/**
 * Transport Close event.
 * @private
 * @event
 * @param {Transport} transport.
 */
UA.prototype.onTransportClosed = function(transport) {
  // Run _onTransportError_ callback on every client transaction using _transport_
  var type, idx, length,
    client_transactions = ['nict', 'ict', 'nist', 'ist'];

  transport.server.status = Transport.C.STATUS_DISCONNECTED;
  this.logger.log('connection state set to ' + Transport.C.STATUS_DISCONNECTED, this);

  length = client_transactions.length;
  for (type = 0; type < length; type++) {
    for (idx in this.transactions[client_transactions[type]]) {
      this.transactions[client_transactions[type]][idx].onTransportError();
    }
  }

  // Close sessions if GRUU is not being used
  if (!this.contact.pub_gruu) {
    this.closeSessionsOnTransportError();
  }
};

/**
 * Unrecoverable transport event.
 * Connection reattempt logic has been done and didn't success.
 * @private
 * @event
 * @param {Transport} transport.
 */
UA.prototype.onTransportError = function(transport, options) {
  options = options || {};
  if (this.status === C.STATUS_USER_CLOSED) {
    return;
  }

  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to ' + Transport.C.STATUS_ERROR, this);

  // Close sessions.
  //Mark this transport as 'down' and try the next one
  transport.server.status = Transport.C.STATUS_ERROR;

  this.closeSessionsOnTransportError();
  if (!this.error || this.error !== C.NETWORK_ERROR) {
    this.status = C.STATUS_NOT_READY;
    this.error = C.NETWORK_ERROR;
  }
  // Transport Recovery process
  this.recoverTransport(options);

  var data = Utils.merge_options({
    transport: transport,
    code: transport.lastTransportError.code,
    reason: transport.lastTransportError.reason
  }, options);
  this.emit('disconnected', this, data);
};

/**
 * Transport connection event.
 * @private
 * @event
 * @param {Transport} transport.
 */
UA.prototype.onTransportConnected = function(transport) {
  this.transport = transport;

  // Reset transport recovery counter
  this.transportRecoverAttempts = 0;

  transport.server.status = Transport.C.STATUS_READY;
  this.logger.log('connection state set to ' + Transport.C.STATUS_READY, this);

  if (this.status === C.STATUS_USER_CLOSED) {
    return;
  }

  this.status = C.STATUS_READY;
  this.error = null;
  this.emit('connected', this, {
    transport: transport
  });

  if (this.dynConfiguration.register) {
    if (this._registrator) {
      this._registrator.onTransportConnected();
    } else {
      this._registrator = new Registrator(this, transport);
      this.register();
    }
  } else if (!this._registrator) {
    this._registrator = new Registrator(this, transport);
  }
};

/**
 * Transport connecting event
 */
UA.prototype.onTransportConnecting = function(transport, attempts) {
  this.emit('connecting', this, {
    transport: transport,
    attempts: attempts
  });
};


/**
 * new Transaction
 */
UA.prototype.newTransaction = function(transaction) {
  this.transactions[transaction.type][transaction.id] = transaction;
  this.emit('newTransaction', this, {
    transaction: transaction
  });
};


/**
 * Transaction destroyed.
 */
UA.prototype.destroyTransaction = function(transaction) {
  delete this.transactions[transaction.type][transaction.id];
  this.emit('transactionDestroyed', this, {
    transaction: transaction
  });
};


//=========================
// receiveRequest
//=========================

/**
 * Request reception
 * @private
 * @param {IncomingRequest} request.
 */
UA.prototype.receiveRequest = function(request) {
  var dialog, session, message,
    method = request.method;

  // Check that Ruri points to us
  if (request.ruri.user !== this.configuration.uri.user && request.ruri.user !== this.contact.uri.user) {
    this.logger.warn('Request-URI (' + request.ruri.user + ') does not point to us (' + this.configuration.uri.user + ')', this);
    if (request.method !== ExSIP_C.ACK) {
      request.reply_sl(404);
    }
    return;
  }

  // Check request URI scheme
  if (request.ruri.scheme === ExSIP_C.SIPS) {
    request.reply_sl(416);
    return;
  }

  // Check transaction
  if (Transactions.checkTransaction(this, request)) {
    this.logger.warn('Check Transaction failed', this);
    return;
  }

  // Create the server transaction
  if (method === ExSIP_C.INVITE) {
    new Transactions.InviteServerTransaction(request, this);
  } else if (method !== ExSIP_C.ACK && method !== ExSIP_C.CANCEL) {
    new Transactions.NonInviteServerTransaction(request, this);
  }

  /* RFC3261 12.2.2
   * Requests that do not change in any way the state of a dialog may be
   * received within a dialog (for example, an OPTIONS request).
   * They are processed as if they had been received outside the dialog.
   */
  if (method === ExSIP_C.OPTIONS) {
    request.reply(200);
  } else if (method === ExSIP_C.MESSAGE) {
    if (!this.checkEvent('newMessage') || this.listeners('newMessage').length === 0) {
      request.reply(405);
      return;
    }
    message = new Message(this);
    message.init_incoming(request);
  } else if (method === ExSIP_C.INVITE) {
    if (!this.checkEvent('newRTCSession') || this.listeners('newRTCSession').length === 0) {
      request.reply(405);
      return;
    }
  }

  // Initial Request
  if (!request.to_tag) {
    switch (method) {
      case ExSIP_C.INVITE:
        if (WebRTC.isSupported) {
          this.logger.debug('INVITE received', this);
          session = new RTCSession(this);
          session.init_incoming(request);
        } else {
          this.logger.warn('INVITE received but WebRTC is not supported', this);
          request.reply(488);
        }
        break;
      case ExSIP_C.BYE:
        // Out of dialog BYE received
        request.reply(481);
        break;
      case ExSIP_C.CANCEL:
        session = this.findSession(request);
        if (session) {
          session.receiveRequest(request);
        } else {
          this.logger.warn('received CANCEL request for a non existent session', this);
        }
        break;
      case ExSIP_C.ACK:
        /* Absorb it.
         * ACK request without a corresponding Invite Transaction
         * and without To tag.
         */
        break;
      default:
        request.reply(405);
        break;
    }
  }
  // In-dialog request
  else {
    dialog = this.findDialog(request);

    if (dialog) {
      dialog.receiveRequest(request);
    } else if (method === ExSIP_C.NOTIFY) {
      session = this.findSession(request);
      if (session) {
        this.logger.log('received NOTIFY request for session : ' + session.id, this);
        session.receiveRequest(request);
      } else {
        this.logger.warn('received NOTIFY request for a non existent session', this);
        this.logger.log('request : ' + (request.call_id + "-" + request.from_tag + "-" + request.to_tag), this);
        this.logger.log('sessions : ' + Object.keys(this.sessions), this);
        request.reply(481, 'Subscription does not exist');
      }
    }
    /* RFC3261 12.2.2
     * Request with to tag, but no matching dialog found.
     * Exception: ACK for an Invite request for which a dialog has not
     * been created.
     */
    else {
      if (method !== ExSIP_C.ACK) {
        request.reply(481);
      }
    }
  }
};

//=================
// Utils
//=================

/**
 * Get the session to which the request belongs to, if any.
 * @private
 * @param {IncomingRequest} request.
 * @returns {OutgoingSession|IncomingSession|null}
 */
UA.prototype.findSession = function(request) {
  var
    sessionIDa = request.call_id + request.from_tag,
    sessionA = this.sessions[sessionIDa],
    sessionIDb = request.call_id + request.to_tag,
    sessionB = this.sessions[sessionIDb];

  if (sessionA) {
    return sessionA;
  } else if (sessionB) {
    return sessionB;
  } else {
    return null;
  }
};

/**
 * Get the dialog to which the request belongs to, if any.
 * @private
 * @param {IncomingRequest}
 * @returns {Dialog|null}
 */
UA.prototype.findDialog = function(request) {
  var
    id = request.call_id + request.from_tag + request.to_tag,
    dialog = this.dialogs[id];

  if (dialog) {
    return dialog;
  } else {
    id = request.call_id + request.to_tag + request.from_tag;
    dialog = this.dialogs[id];
    if (dialog) {
      return dialog;
    } else {
      return null;
    }
  }
};

/**
 * Retrieve the next server to which connect.
 * @private
 * @returns {Object} ws_server
 */
UA.prototype.getNextWsServer = function(options) {
  options = options || {};

  // reset if all servers have been used
  if (options.force && this.usedServers.length >= this.configuration.ws_servers.length) {
    this.usedServers = [];
  }

  var candidates = [];
  var totalWeight = 0;
  // Add only server with status ready and not already used
  for (var i = 0; i < this.configuration.ws_servers.length; i++) {
    var server = this.configuration.ws_servers[i];
    if (server.status === Transport.C.STATUS_READY && this.usedServers.indexOf(server) === -1) {
      candidates.push(server);
      totalWeight += (server.weight || 1);
    }
  }

  var weightedServers = []; //new array to hold "weighted" servers
  for (var j = 0; j < candidates.length; j++) {
    var candidate = candidates[j];
    for (var k = 0; k < (candidate.weight || 1); k++) {
      weightedServers.push(candidate);
    }
  }

  var randomNumber = Math.floor(Math.random() * totalWeight);
  var index = Math.min(randomNumber, weightedServers.length - 1);
  return weightedServers[index];
};

/**
 * Close all sessions on transport error.
 */
UA.prototype.closeSessionsOnTransportError = function() {
  var idx;

  // Run _transportError_ for every Session
  for (idx in this.sessions) {
    this.sessions[idx].onTransportError();
  }
  // Call registrator _onTransportClosed_
  this._registrator.onTransportClosed();
};

UA.prototype.loadConfig = function(configuration) {
  // Settings and default values
  var parameter, value, checked_value, hostport_params, registrar_server,
    settings = {
      /* Host address
       * Value to be set in Via sent_by and host part of Contact FQDN
       */
      via_host: this.configuration.via_host || (Utils.createRandomToken(12) + '.invalid'),

      // Password
      password: null,

      // Registration parameters
      register_expires: 600,
      register: true,
      registrar_server: null,

      // Transport related parameters
      ws_server_max_reconnection: 3,
      ws_server_reconnection_timeout: 4,

      connection_recovery_min_interval: 2,
      connection_recovery_max_interval: 30,

      use_preloaded_route: false,

      // Session parameters
      no_answer_timeout: 60,
      stun_servers: ['stun:stun.l.google.com:19302'],
      turn_servers: [],

      // Logging parameters
      trace_sip: false,

      // Hacks
      hack_via_tcp: false,
      hack_via_ws: false,
      hack_ip_in_contact: false,
      enable_datachannel: false,
      enable_ims: false,
      p_asserted_identity: null,

      // Options for Node.
      node_ws_options: {}
    };

  // Pre-Configuration

  // Check Mandatory parameters
  for (parameter in UA.configuration_check.mandatory) {
    if (!configuration.hasOwnProperty(parameter)) {
      throw new Exceptions.ConfigurationError(parameter);
    } else {
      value = configuration[parameter];
      checked_value = UA.configuration_check.mandatory[parameter].call(this, value);
      if (checked_value !== undefined) {
        settings[parameter] = checked_value;
      } else {
        throw new Exceptions.ConfigurationError(parameter, value);
      }
    }
  }

  // Check Optional parameters
  for (parameter in UA.configuration_check.optional) {
    if (configuration.hasOwnProperty(parameter)) {
      value = configuration[parameter];

      /* If the parameter value is null, empty string, undefined, empty array
       * or it's a number with NaN value, then apply its default value.
       */
      if (Utils.isEmpty(value)) {
        continue;
      }

      checked_value = UA.configuration_check.optional[parameter].call(this, value);
      if (checked_value !== undefined) {
        settings[parameter] = checked_value;
      } else {
        throw new Exceptions.ConfigurationError(parameter, value);
      }
    }
  }

  // Sanity Checks

  // Connection recovery intervals
  if (settings.connection_recovery_max_interval < settings.connection_recovery_min_interval) {
    throw new Exceptions.ConfigurationError('connection_recovery_max_interval', settings.connection_recovery_max_interval);
  }

  // Post Configuration Process

  // Allow passing 0 number as display_name.
  if (settings.display_name === 0) {
    settings.display_name = '0';
  }

  // Instance-id for GRUU
  if (!settings.instance_id) {
    settings.instance_id = this.configuration.instance_id || Utils.newUUID();
  }

  // ExSIP_id instance parameter. Static random tag of length 5
  settings.exsip_id = this.configuration.exsip_id || Utils.createRandomToken(5);

  // String containing settings.uri without scheme and user.
  hostport_params = settings.uri.clone();
  hostport_params.user = null;
  settings.hostport_params = hostport_params.toString().replace(/^sip:/i, '');

  /* Check whether authorization_user is explicitly defined.
   * Take 'settings.uri.user' value if not.
   */
  if (!settings.authorization_user) {
    settings.authorization_user = settings.uri.user;
  }

  /* If no 'registrar_server' is set use the 'uri' value without user portion. */
  if (!settings.registrar_server) {
    registrar_server = settings.uri.clone();
    registrar_server.user = null;
    settings.registrar_server = registrar_server;
  }

  // User no_answer_timeout
  settings.no_answer_timeout = settings.no_answer_timeout * 1000;

  // Via Host
  if (settings.hack_ip_in_contact) {
    settings.via_host = Utils.getRandomTestNetIP();
  }

  // Set empty Stun Server Set if explicitly passed an empty Array
  value = configuration.stun_servers;
  if (value instanceof Array && value.length === 0) {
    settings.stun_servers = [];
  }

  this.contact = this.contact || {
    pub_gruu: null,
    temp_gruu: null,
    uri: new URI('sip', Utils.createRandomToken(8), settings.via_host, null, {
      transport: 'ws'
    }),
    toString: function(options) {
      options = options || {};

      var
        anonymous = options.anonymous || null,
        outbound = options.outbound || null,
        contact = '<';

      if (anonymous) {
        contact += this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=ws';
      } else {
        contact += this.pub_gruu || this.uri.toString();
      }

      if (outbound && (anonymous ? !this.temp_gruu : !this.pub_gruu)) {
        contact += ';ob';
      }

      contact += '>';

      return contact;
    }
  };

  // Fill the value of the configuration_skeleton
  for (parameter in settings) {
    UA.configuration_skeleton[parameter].value = settings[parameter];
  }

  Object.defineProperties(this.configuration, UA.configuration_skeleton);

  // Clean UA.configuration_skeleton
  for (parameter in settings) {
    UA.configuration_skeleton[parameter].value = '';
  }

  this.logger.debug('configuration parameters after validation:');
  for (parameter in settings) {
    switch (parameter) {
      case 'uri':
      case 'registrar_server':
        this.logger.debug(' ' + parameter + ': ' + settings[parameter]);
        break;
      case 'password':
        this.logger.debug(' ' + parameter + ': ' + 'NOT SHOWN');
        break;
      default:
        this.logger.debug(' ' + parameter + ': ' + JSON.stringify(settings[parameter]));
    }
  }

  // Initialize registrator
  this._registrator = new Registrator(this);

  return;
};

UA.prototype.retry = function(nextRetry, server, callback) {
  var self = this;
  var retryCallback = function() {
    var transport = new Transport(self, server);
    if (callback) {
      callback(transport);
    }
  };

  if (nextRetry === 0) {
    retryCallback();
  } else {
    setTimeout(retryCallback, nextRetry * 1000);
  }
};

UA.prototype.recoverTransport = function(options) {
  var idx, length, k, nextRetry, count, server;

  options = options || {};
  count = this.transportRecoverAttempts;

  length = this.configuration.ws_servers.length;
  for (idx = 0; idx < length; idx++) {
    this.configuration.ws_servers[idx].status = Transport.C.STATUS_READY;
  }

  server = this.getNextWsServer();
  if (options.code === 503 && !server) {
    delete options.retryAfter;
    this.logger.log('non-failover on 503 error - skipping recoverTransport', this);
    return;
  }

  var maxTransportRecoveryAttempts = this.configuration.max_transport_recovery_attempts;
  if (typeof(maxTransportRecoveryAttempts) !== "undefined" && count >= parseInt(maxTransportRecoveryAttempts, 10)) {
    delete options.retryAfter;
    this.logger.log('recover attempts ' + count + " exceed max transport recovery attempts " + maxTransportRecoveryAttempts + " - skipping recoverTransport");
    return;
  }

  if (server) {
    this.logger.log('failover - new connection attempt with ' + server.ws_uri);
    this.retry(0, server, options.retryCallback);
    return;
  }

  if (options.retryAfter) {
    nextRetry = options.retryAfter;
  } else {
    k = Math.floor((Math.random() * Math.pow(2, count)) + 1);
    nextRetry = k * this.configuration.connection_recovery_min_interval;

    if (nextRetry > this.configuration.connection_recovery_max_interval) {
      this.logger.log('time for next connection attempt exceeds connection_recovery_max_interval, resetting counter', this);
      nextRetry = this.configuration.connection_recovery_min_interval;
      count = 0;
    }
  }

  server = this.getNextWsServer({
    force: true
  });
  this.transportRecoverAttempts = count + 1;
  this.logger.log('resetting ws server list - next connection attempt in ' + nextRetry + ' seconds to ' + server.ws_uri + ' : ' + this.transportRecoverAttempts);
  this.retry(nextRetry, server, options.retryCallback);
};

/**
 * Configuration Object skeleton.
 */
/**
 * Configuration Object skeleton.
 */
UA.configuration_skeleton = (function() {
  var idx, parameter,
    skeleton = {},
    parameters = [
      // Internal parameters
      "exsip_id",
      "ws_server_max_reconnection",
      "ws_server_reconnection_timeout",
      "hostport_params",

      // Mandatory user configurable parameters
      "uri",
      "ws_servers",

      // Optional user configurable parameters
      "authorization_user",
      "connection_recovery_max_interval",
      "connection_recovery_min_interval",
      "max_transport_recovery_attempts",
      "display_name",
      "hack_via_tcp", // false
      "hack_via_ws", // false
      "hack_ip_in_contact", //false
      "instance_id",
      "no_answer_timeout", // 30 seconds
      "node_ws_options",
      "password",
      "register_expires", // 600 seconds
      "registrar_server",
      "stun_servers",
      "trace_sip",
      "turn_servers",
      "use_preloaded_route",
      "enable_datachannel",
      "enable_ims",
      "p_asserted_identity",

      // Post-configuration generated parameters
      "via_core_value",
      "via_host"
    ];

  for (idx in parameters) {
    parameter = parameters[idx];
    skeleton[parameter] = {
      value: '',
      writable: false,
      configurable: true
    };
  }

  skeleton.register = {
    value: '',
    writable: true,
    configurable: true
  };

  return skeleton;
}());

/**
 * Configuration checker.
 */
UA.configuration_check = {
  mandatory: {

    uri: function(uri) {
      var parsed;

      if (!/^sip:/i.test(uri)) {
        uri = ExSIP_C.SIP + ':' + uri;
      }
      parsed = URI.parse(uri);

      if (!parsed) {
        return;
      } else if (!parsed.user) {
        return;
      } else {
        return parsed;
      }
    },

    ws_servers: function(ws_servers) {
      var idx, length, url;

      /* Allow defining ws_servers parameter as:
       *  String: "host"
       *  Array of Strings: ["host1", "host2"]
       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
       */
      if (typeof ws_servers === 'string') {
        ws_servers = [{
          ws_uri: ws_servers
        }];
      } else if (ws_servers instanceof Array) {
        length = ws_servers.length;
        for (idx = 0; idx < length; idx++) {
          if (typeof ws_servers[idx] === 'string') {
            ws_servers[idx] = {
              ws_uri: ws_servers[idx]
            };
          }
        }
      } else {
        return;
      }

      if (ws_servers.length === 0) {
        return false;
      }

      length = ws_servers.length;
      for (idx = 0; idx < length; idx++) {
        if (!ws_servers[idx].ws_uri) {
          this.logger.error('missing "ws_uri" attribute in ws_servers parameter');
          return;
        }
        if (ws_servers[idx].weight && !Number(ws_servers[idx].weight)) {
          this.logger.error('"weight" attribute in ws_servers parameter must be a Number');
          return;
        }

        url = Grammar.parse(ws_servers[idx].ws_uri, 'absoluteURI');

        if (url === -1) {
          this.logger.error('invalid "ws_uri" attribute in ws_servers parameter: ' + ws_servers[idx].ws_uri);
          return;
        } else if (url.scheme !== 'wss' && url.scheme !== 'ws') {
          this.logger.error('invalid URI scheme in ws_servers parameter: ' + url.scheme);
          return;
        } else {
          ws_servers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=ws;lr>';

          if (!ws_servers[idx].weight) {
            ws_servers[idx].weight = 0;
          }

          ws_servers[idx].status = 0;
          ws_servers[idx].scheme = url.scheme.toUpperCase();
        }
      }
      return ws_servers;
    }
  },

  optional: {

    authorization_user: function(authorization_user) {
      if (Grammar.parse('"' + authorization_user + '"', 'quoted_string') === -1) {
        return;
      } else {
        return authorization_user;
      }
    },

    connection_recovery_max_interval: function(connection_recovery_max_interval) {
      var value;
      if (Utils.isDecimal(connection_recovery_max_interval)) {
        value = Number(connection_recovery_max_interval);
        if (value > 0) {
          return value;
        }
      }
    },

    connection_recovery_min_interval: function(connection_recovery_min_interval) {
      var value;
      if (Utils.isDecimal(connection_recovery_min_interval)) {
        value = Number(connection_recovery_min_interval);
        if (value >= 0) {
          return value;
        }
      }
    },

    display_name: function(display_name) {
      if (Grammar.parse('"' + display_name + '"', 'display_name') === -1) {
        return;
      } else {
        return display_name;
      }
    },

    hack_via_tcp: function(hack_via_tcp) {
      if (typeof hack_via_tcp === 'boolean') {
        return hack_via_tcp;
      }
    },

    hack_via_ws: function(hack_via_ws) {
      if (typeof hack_via_ws === 'boolean') {
        return hack_via_ws;
      }
    },

    hack_ip_in_contact: function(hack_ip_in_contact) {
      if (typeof hack_ip_in_contact === 'boolean') {
        return hack_ip_in_contact;
      }
    },

    enable_ims: function(enable_ims) {
      if (typeof enable_ims === 'boolean') {
        return enable_ims;
      }
    },

    ws_server_reconnection_timeout: function(ws_server_reconnection_timeout) {
      var value;
      if (Utils.isDecimal(ws_server_reconnection_timeout)) {
        value = Number(ws_server_reconnection_timeout);
        if (value >= 0) {
          return value;
        }
      }
    },

    max_transport_recovery_attempts: function(max_transport_recovery_attempts) {
      var value;
      if (Utils.isDecimal(max_transport_recovery_attempts)) {
        value = Number(max_transport_recovery_attempts);
        if (value >= 0) {
          return value;
        }
      }
    },

    p_asserted_identity: function(p_asserted_identity) {
      return String(p_asserted_identity);
    },

    enable_datachannel: function(enable_datachannel) {
      if (typeof enable_datachannel === 'boolean') {
        return enable_datachannel;
      }
    },

    instance_id: function(instance_id) {
      if ((/^uuid:/i.test(instance_id))) {
        instance_id = instance_id.substr(5);
      }

      if (Grammar.parse(instance_id, 'uuid') === -1) {
        return;
      } else {
        return instance_id;
      }
    },

    no_answer_timeout: function(no_answer_timeout) {
      var value;
      if (Utils.isDecimal(no_answer_timeout)) {
        value = Number(no_answer_timeout);
        if (value > 0) {
          return value;
        }
      }
    },

    node_ws_options: function(node_ws_options) {
      return (typeof node_ws_options === 'object') ? node_ws_options : {};
    },

    password: function(password) {
      return String(password);
    },

    register: function(register) {
      if (typeof register === 'boolean') {
        return register;
      }
    },

    register_expires: function(register_expires) {
      var value;
      if (Utils.isDecimal(register_expires)) {
        value = Number(register_expires);
        if (value > 0) {
          return value;
        }
      }
    },

    registrar_server: function(registrar_server) {
      var parsed;

      if (!/^sip:/i.test(registrar_server)) {
        registrar_server = ExSIP_C.SIP + ':' + registrar_server;
      }
      parsed = URI.parse(registrar_server);

      if (!parsed) {
        return;
      } else if (parsed.user) {
        return;
      } else {
        return parsed;
      }
    },

    stun_servers: function(stun_servers) {
      var idx, length, stun_server;

      if (typeof stun_servers === 'string') {
        stun_servers = [stun_servers];
      } else if (!(stun_servers instanceof Array)) {
        return;
      }

      length = stun_servers.length;
      for (idx = 0; idx < length; idx++) {
        stun_server = stun_servers[idx];
        if (!(/^stuns?:/.test(stun_server))) {
          stun_server = 'stun:' + stun_server;
        }

        if (Grammar.parse(stun_server, 'stun_URI') === -1) {
          return;
        } else {
          stun_servers[idx] = stun_server;
        }
      }
      return stun_servers;
    },

    trace_sip: function(trace_sip) {
      if (typeof trace_sip === 'boolean') {
        return trace_sip;
      }
    },

    turn_servers: function(turn_servers) {
      var idx, idx2, length, length2, turn_server, url;

      if (!turn_servers instanceof Array) {
        turn_servers = [turn_servers];
      }

      length = turn_servers.length;
      for (idx = 0; idx < length; idx++) {
        turn_server = turn_servers[idx];

        // Backward compatibility:
        //Allow defining the turn_server 'urls' with the 'server' property.
        if (turn_server.server) {
          turn_server.urls = [turn_server.server];
        }

        // Backward compatibility:
        //Allow defining the turn_server 'credential' with the 'password' property.
        if (turn_server.password) {
          turn_server.credential = [turn_server.password];
        }

        if (!turn_server.urls || !turn_server.username || !turn_server.credential) {
          return;
        }

        if (!(turn_server.urls instanceof Array)) {
          turn_server.urls = [turn_server.urls];
        }

        length2 = turn_server.urls.length;
        for (idx2 = 0; idx2 < length2; idx2++) {
          url = turn_server.urls[idx2];

          if (!(/^turns?:/.test(url))) {
            url = 'turn:' + url;
          }

          if (Grammar.parse(url, 'turn_URI') === -1) {
            return;
          }
        }
      }
      return turn_servers;
    },

    use_preloaded_route: function(use_preloaded_route) {
      if (typeof use_preloaded_route === 'boolean') {
        return use_preloaded_route;
      }
    }
  }
};
},{"./Constants":500,"./EventEmitter":504,"./Exceptions":506,"./Grammar":507,"./LoggerFactory":509,"./Message":510,"./RTCSession":513,"./Registrator":517,"./Transactions":521,"./Transport":522,"./URI":524,"./Utils":525,"./WebRTC":526}],524:[function(require,module,exports){
module.exports = URI;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var Utils = require('./Utils');
var Grammar = require('./Grammar');


/**
 * -param {String} [scheme]
 * -param {String} [user]
 * -param {String} host
 * -param {String} [port]
 * -param {Object} [parameters]
 * -param {Object} [headers]
 *
 */
function URI(scheme, user, host, port, parameters, headers) {
  var param, header;

  // Checks
  if(!host) {
    throw new TypeError('missing or invalid "host" parameter');
  }

  // Initialize parameters
  scheme = scheme || ExSIP_C.SIP;
  this.parameters = {};
  this.headers = {};

  for (param in parameters) {
    this.setParam(param, parameters[param]);
  }

  for (header in headers) {
    this.setHeader(header, headers[header]);
  }

  Object.defineProperties(this, {
    scheme: {
      get: function(){ return scheme; },
      set: function(value){
        scheme = value.toLowerCase();
      }
    },

    user: {
      get: function(){ return user; },
      set: function(value){
        user = value;
      }
    },

    host: {
      get: function(){ return host; },
      set: function(value){
        host = value.toLowerCase();
      }
    },

    port: {
      get: function(){ return port; },
      set: function(value){
        port = value === 0 ? value : (parseInt(value,10) || null);
      }
    }
  });
}


URI.prototype = {
  setParam: function(key, value) {
    if(key) {
      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
    }
  },

  getParam: function(key) {
    if(key) {
      return this.parameters[key.toLowerCase()];
    }
  },

  hasParam: function(key) {
    if(key) {
      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
    }
  },

  deleteParam: function(parameter) {
    var value;
    parameter = parameter.toLowerCase();
    if (this.parameters.hasOwnProperty(parameter)) {
      value = this.parameters[parameter];
      delete this.parameters[parameter];
      return value;
    }
  },

  clearParams: function() {
    this.parameters = {};
  },

  setHeader: function(name, value) {
    this.headers[Utils.headerize(name)] = (value instanceof Array) ? value : [value];
  },

  getHeader: function(name) {
    if(name) {
      return this.headers[Utils.headerize(name)];
    }
  },

  hasHeader: function(name) {
    if(name) {
      return (this.headers.hasOwnProperty(Utils.headerize(name)) && true) || false;
    }
  },

  deleteHeader: function(header) {
    var value;
    header = Utils.headerize(header);
    if(this.headers.hasOwnProperty(header)) {
      value = this.headers[header];
      delete this.headers[header];
      return value;
    }
  },

  clearHeaders: function() {
    this.headers = {};
  },

  isPhoneNumber: function() {
    return this.user && this.user.match(/^\+?\d+$/) !== null;
  },

  clone: function() {
    return new URI(
      this.scheme,
      this.user,
      this.host,
      this.port,
      JSON.parse(JSON.stringify(this.parameters)),
      JSON.parse(JSON.stringify(this.headers)));
  },

  toString: function(){
    var header, parameter, idx, uri,
      headers = [];

    uri  = this.scheme + ':';
    if (this.user) {
      uri += Utils.escapeUser(this.user) + '@';
    }
    uri += this.host;
    if (this.port || this.port === 0) {
      uri += ':' + this.port;
    }

    for (parameter in this.parameters) {
      uri += ';' + parameter;

      if (this.parameters[parameter] !== null) {
        uri += '='+ this.parameters[parameter];
      }
    }

    for(header in this.headers) {
      for(idx in this.headers[header]) {
        headers.push(header + '=' + this.headers[header][idx]);
      }
    }

    if (headers.length > 0) {
      uri += '?' + headers.join('&');
    }

    return uri;
  },

  toAor: function(show_port){
      var aor;

      aor  = this.scheme + ':';
      if (this.user) {
        aor += Utils.escapeUser(this.user) + '@';
      }
      aor += this.host;
      if (show_port && (this.port || this.port === 0)) {
        aor += ':' + this.port;
      }

      return aor;
  }
};


/**
  * Parse the given string and returns a ExSIP.URI instance or undefined if
  * it is an invalid URI.
  */
URI.parse = function(uri) {
  uri = Grammar.parse(uri,'SIP_URI');

  if (uri !== -1) {
    return uri;
  } else {
    return undefined;
  }
};
},{"./Constants":500,"./Grammar":507,"./Utils":525}],525:[function(require,module,exports){
var Utils = {};

module.exports = Utils;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var URI = require('./URI');
var Grammar = require('./Grammar');

Utils.inArray = function(array, el) {
  for (var i = array.length; i--;) {
    if (array[i] === el) {
      return true;
    }
  }
  return false;
};

Utils.isEqArrays = function(arr1, arr2) {
  if (arr1 === null && arr2 !== null) {
    return false;
  }
  if (arr1 !== null && arr2 === null) {
    return false;
  }
  if (arr1 === null && arr2 === null) {
    return true;
  }
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (var i = arr1.length; i--;) {
    if (!this.inArray(arr2, arr1[i])) {
      return false;
    }
  }
  return true;
};

/**
 * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
 * @param obj1
 * @param obj2
 * @returns obj3 a new object based on obj1 and obj2
 */
Utils.merge_options = function(obj1, obj2) {
  var obj3 = {};
  for (var attrname1 in obj1) {
    obj3[attrname1] = obj1[attrname1];
  }
  for (var attrname2 in obj2) {
    obj3[attrname2] = obj2[attrname2];
  }
  return obj3;
};

Utils.containsHeader = function(headers, name) {
  for (var i = 0; i < headers.length; i++) {
    if (headers[i].indexOf(name) !== -1) {
      return true;
    }
  }
  return false;
};

Utils.str_utf8_length = function(string) {
  return unescape(encodeURIComponent(string)).length;
};

Utils.toString = function(object) {
  var seen = [];

  return JSON.stringify(object, function(key, val) {
    if (typeof val === "object") {
      if (seen.indexOf(val) >= 0) {
        return;
      }
      seen.push(val);
    }
    return val;
  });
};

Utils.isFunction = function(fn) {
  if (fn !== undefined) {
    return (Object.prototype.toString.call(fn) === '[object Function]') ? true : false;
  } else {
    return false;
  }
};

Utils.isDecimal = function(num) {
  return !isNaN(num) && (parseFloat(num) === parseInt(num, 10));
};

Utils.getHeadersFromQuery = function(query) {
  var headers = [];
  var queryParts = query.split("&");
  for (var i = 0; i < queryParts.length; i++) {
    var parameters = queryParts[i].split("=");
    headers.push(parameters[0] + ": " + decodeURIComponent(parameters[1]));
  }
  return headers;
};

Utils.stripSip = function(address) {
  var match = address.match(/<sip\:(.*)\>/);
  return match ? match[1] : address;
};

Utils.isEmpty = function(value) {
  if (value === null || value === "" || value === undefined || (value instanceof Array && value.length === 0) || (typeof(value) === 'number' && isNaN(value))) {
    return true;
  }
};

Utils.getAllowedMethods = function(ua) {
  var event,
    allowed = ExSIP_C.ALLOWED_METHODS.toString();

  for (event in ExSIP_C.EVENT_METHODS) {
    if (ua.checkEvent(event) && ua.listeners(event).length > 0) {
      allowed += ',' + ExSIP_C.EVENT_METHODS[event];
    }
  }

  return allowed;
};

Utils.createRandomToken = function(size, base) {
  var i, r,
    token = '';

  base = base || 32;

  for (i = 0; i < size; i++) {
    r = Math.random() * base | 0;
    token += r.toString(base);
  }
  return token;
};

Utils.newTag = function() {
  return Utils.createRandomToken(10);
};

// http://stackoverflow.com/users/109538/broofa
Utils.newUUID = function() {
  var UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0,
      v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });

  return UUID;
};

Utils.hostType = function(host) {
  if (!host) {
    return;
  } else {
    host = Grammar.parse(host, 'host');
    if (host !== -1) {
      return host.host_type;
    }
  }
};

/**
 * Normalize SIP URI.
 * NOTE: It does not allow a SIP URI without username.
 * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
 * Detects the domain part (if given) and properly hex-escapes the user portion.
 * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
 */
Utils.normalizeTarget = function(target, domain) {
  var uri, target_array, target_user, target_domain;

  // If no target is given then raise an error.
  if (!target) {
    return;
    // If a URI instance is given then return it.
  } else if (target instanceof URI) {
    return target;

    // If a string is given split it by '@':
    // - Last fragment is the desired domain.
    // - Otherwise append the given domain argument.
  } else if (typeof target === 'string') {
    target_array = target.split('@');

    switch (target_array.length) {
      case 1:
        if (!domain) {
          return;
        }
        target_user = target;
        target_domain = domain;
        break;
      case 2:
        target_user = target_array[0];
        target_domain = target_array[1];
        break;
      default:
        target_user = target_array.slice(0, target_array.length - 1).join('@');
        target_domain = target_array[target_array.length - 1];
    }

    // Remove the URI scheme (if present).
    target_user = target_user.replace(/^(sips?|tel):/i, '');

    // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
    if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
      target_user = target_user.replace(/[\-\.\(\)]/g, '');
    }

    // Build the complete SIP URI.
    target = ExSIP_C.SIP + ':' + Utils.escapeUser(target_user) + '@' + target_domain;

    // Finally parse the resulting URI.
    if ((uri = URI.parse(target))) {
      return uri;
    } else {
      return;
    }
  } else {
    return;
  }
};

/**
 * Hex-escape a SIP URI user.
 */
Utils.escapeUser = function(user) {
  // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
  return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
};

Utils.headerize = function(string) {
  var exceptions = {
      'Call-Id': 'Call-ID',
      'Cseq': 'CSeq',
      'Www-Authenticate': 'WWW-Authenticate'
    },
    name = string.toLowerCase().replace(/_/g, '-').split('-'),
    hname = '',
    parts = name.length,
    part;

  for (part = 0; part < parts; part++) {
    if (part !== 0) {
      hname += '-';
    }
    hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
  }
  if (exceptions[hname]) {
    hname = exceptions[hname];
  }
  return hname;
};

Utils.sipErrorCause = function(status_code) {
  var cause;

  for (cause in ExSIP_C.SIP_ERROR_CAUSES) {
    if (ExSIP_C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
      return ExSIP_C.causes[cause];
    }
  }

  return ExSIP_C.causes.SIP_FAILURE_CODE;
};

/**
 * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
 */
Utils.getRandomTestNetIP = function() {
  function getOctet(from, to) {
    return Math.floor(Math.random() * (to - from + 1) + from);
  }
  return '192.0.2.' + getOctet(1, 254);
};

// MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
Utils.calculateMD5 = function(string) {
  function rotateLeft(lValue, iShiftBits) {
    return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
  }

  function addUnsigned(lX, lY) {
    var lX4, lY4, lX8, lY8, lResult;
    lX8 = (lX & 0x80000000);
    lY8 = (lY & 0x80000000);
    lX4 = (lX & 0x40000000);
    lY4 = (lY & 0x40000000);
    lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
    if (lX4 & lY4) {
      return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
    }
    if (lX4 | lY4) {
      if (lResult & 0x40000000) {
        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
      } else {
        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
      }
    } else {
      return (lResult ^ lX8 ^ lY8);
    }
  }

  function doF(x, y, z) {
    return (x & y) | ((~x) & z);
  }

  function doG(x, y, z) {
    return (x & z) | (y & (~z));
  }

  function doH(x, y, z) {
    return (x ^ y ^ z);
  }

  function doI(x, y, z) {
    return (y ^ (x | (~z)));
  }

  function doFF(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doF(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function doGG(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doG(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function doHH(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doH(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function doII(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doI(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function convertToWordArray(string) {
    var lWordCount;
    var lMessageLength = string.length;
    var lNumberOfWords_temp1 = lMessageLength + 8;
    var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
    var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
    var lWordArray = new Array(lNumberOfWords - 1);
    var lBytePosition = 0;
    var lByteCount = 0;
    while (lByteCount < lMessageLength) {
      lWordCount = (lByteCount - (lByteCount % 4)) / 4;
      lBytePosition = (lByteCount % 4) * 8;
      lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
      lByteCount++;
    }
    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
    lBytePosition = (lByteCount % 4) * 8;
    lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
    lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
    return lWordArray;
  }

  function wordToHex(lValue) {
    var wordToHexValue = "",
      wordToHexValue_temp = "",
      lByte, lCount;
    for (lCount = 0; lCount <= 3; lCount++) {
      lByte = (lValue >>> (lCount * 8)) & 255;
      wordToHexValue_temp = "0" + lByte.toString(16);
      wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
    }
    return wordToHexValue;
  }

  function utf8Encode(string) {
    string = string.replace(/\r\n/g, "\n");
    var utftext = "";

    for (var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);

      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if ((c > 127) && (c < 2048)) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
      } else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
      }
    }
    return utftext;
  }

  var x = [];
  var k, AA, BB, CC, DD, a, b, c, d;
  var S11 = 7,
    S12 = 12,
    S13 = 17,
    S14 = 22;
  var S21 = 5,
    S22 = 9,
    S23 = 14,
    S24 = 20;
  var S31 = 4,
    S32 = 11,
    S33 = 16,
    S34 = 23;
  var S41 = 6,
    S42 = 10,
    S43 = 15,
    S44 = 21;

  string = utf8Encode(string);

  x = convertToWordArray(string);

  a = 0x67452301;
  b = 0xEFCDAB89;
  c = 0x98BADCFE;
  d = 0x10325476;

  for (k = 0; k < x.length; k += 16) {
    AA = a;
    BB = b;
    CC = c;
    DD = d;
    a = doFF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
    d = doFF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
    c = doFF(c, d, a, b, x[k + 2], S13, 0x242070DB);
    b = doFF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
    a = doFF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
    d = doFF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
    c = doFF(c, d, a, b, x[k + 6], S13, 0xA8304613);
    b = doFF(b, c, d, a, x[k + 7], S14, 0xFD469501);
    a = doFF(a, b, c, d, x[k + 8], S11, 0x698098D8);
    d = doFF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
    c = doFF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
    b = doFF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
    a = doFF(a, b, c, d, x[k + 12], S11, 0x6B901122);
    d = doFF(d, a, b, c, x[k + 13], S12, 0xFD987193);
    c = doFF(c, d, a, b, x[k + 14], S13, 0xA679438E);
    b = doFF(b, c, d, a, x[k + 15], S14, 0x49B40821);
    a = doGG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
    d = doGG(d, a, b, c, x[k + 6], S22, 0xC040B340);
    c = doGG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
    b = doGG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
    a = doGG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
    d = doGG(d, a, b, c, x[k + 10], S22, 0x2441453);
    c = doGG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
    b = doGG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
    a = doGG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
    d = doGG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
    c = doGG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
    b = doGG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
    a = doGG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
    d = doGG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
    c = doGG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
    b = doGG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
    a = doHH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
    d = doHH(d, a, b, c, x[k + 8], S32, 0x8771F681);
    c = doHH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
    b = doHH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
    a = doHH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
    d = doHH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
    c = doHH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
    b = doHH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
    a = doHH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
    d = doHH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
    c = doHH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
    b = doHH(b, c, d, a, x[k + 6], S34, 0x4881D05);
    a = doHH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
    d = doHH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
    c = doHH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
    b = doHH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
    a = doII(a, b, c, d, x[k + 0], S41, 0xF4292244);
    d = doII(d, a, b, c, x[k + 7], S42, 0x432AFF97);
    c = doII(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
    b = doII(b, c, d, a, x[k + 5], S44, 0xFC93A039);
    a = doII(a, b, c, d, x[k + 12], S41, 0x655B59C3);
    d = doII(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
    c = doII(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
    b = doII(b, c, d, a, x[k + 1], S44, 0x85845DD1);
    a = doII(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
    d = doII(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
    c = doII(c, d, a, b, x[k + 6], S43, 0xA3014314);
    b = doII(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
    a = doII(a, b, c, d, x[k + 4], S41, 0xF7537E82);
    d = doII(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
    c = doII(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
    b = doII(b, c, d, a, x[k + 9], S44, 0xEB86D391);
    a = addUnsigned(a, AA);
    b = addUnsigned(b, BB);
    c = addUnsigned(c, CC);
    d = addUnsigned(d, DD);
  }

  var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);

  return temp.toLowerCase();
};
},{"./Constants":500,"./Grammar":507,"./URI":524}],526:[function(require,module,exports){
var WebRTC = {};

module.exports = WebRTC;

var ExSIP_C = require('./Constants');
var Utils = require('./Utils');

// getUserMedia
if (typeof navigator !== 'undefined' && navigator.webkitGetUserMedia) {
  WebRTC.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
}
else if (typeof navigator !== 'undefined' && navigator.mozGetUserMedia) {
  WebRTC.getUserMedia = navigator.mozGetUserMedia.bind(navigator);
}
else if (typeof navigator !== 'undefined' && navigator.getUserMedia) {
  WebRTC.getUserMedia = navigator.getUserMedia.bind(navigator);
}

// RTCPeerConnection
if (typeof webkitRTCPeerConnection !== 'undefined') {
  WebRTC.RTCPeerConnection = webkitRTCPeerConnection;
}
else if (typeof mozRTCPeerConnection !== 'undefined') {
  WebRTC.RTCPeerConnection = mozRTCPeerConnection;
}
else if (typeof RTCPeerConnection !== 'undefined') {
  WebRTC.RTCPeerConnection = RTCPeerConnection;
}
else {
  console.log("WebRTC.RTCPeerConnection undefined");
  WebRTC.RTCPeerConnection = function(options, constraints){
    this.options = options;
    this.constraints = constraints;
  };
}

// RTCIceCandidate
if (typeof RTCIceCandidate !== 'undefined') {
  WebRTC.RTCIceCandidate = RTCIceCandidate;
}
else {
  console.log("WebRTC.RTCIceCandidate undefined");
  WebRTC.RTCIceCandidate = function(){};
}

// RTCSessionDescription
if (typeof webkitRTCSessionDescription !== 'undefined') {
  WebRTC.RTCSessionDescription = webkitRTCSessionDescription;
}
else if (typeof mozRTCSessionDescription !== 'undefined') {
  WebRTC.RTCSessionDescription = mozRTCSessionDescription;
}
else if (typeof RTCSessionDescription !== 'undefined') {
  WebRTC.RTCSessionDescription = RTCSessionDescription;
}
else {
  console.log("WebRTC.RTCSessionDescription undefined");
  WebRTC.RTCSessionDescription = function(options){
    options = options || {};
    this.sdp = options.sdp;
    this.type = options.type;
  };
}

WebRTC.RTCSessionDescription.prototype.getSdp = function(options){
  options = options || {};
  var sdp = this.sdp;
  if(options.additionalSdp) {
    sdp += options.additionalSdp;
  }
  return sdp;
};
WebRTC.RTCSessionDescription.prototype.getUnsupportedMedias = function(){
  var slideMedias = this.getSlidesMedias();
  var inactiveApplicationMedias = this.getApplicationMedias('0 RTP/SAVPF');
  var unsupportedMedias = slideMedias.concat(inactiveApplicationMedias);
  return unsupportedMedias;
};
WebRTC.RTCSessionDescription.prototype.removeUnsupportedMedia = function(){
  var unsupportedMedias = this.getUnsupportedMedias();
  for(var i = 0; i < unsupportedMedias.length; i++) {
    this.sdp = this.sdp.replace(unsupportedMedias[i], '');
    console.warn('removing unsupported media from sdp : '+unsupportedMedias[i]);
  }
  return unsupportedMedias.join('');
};
WebRTC.RTCSessionDescription.prototype.getSlidesMedias = function(){
  var slideMedia = this.getVideoMedias('a=content:slides');
  return slideMedia;
};
WebRTC.RTCSessionDescription.prototype.getVideoMedias = function(filter){
  return this.getMedias('video', filter);
};
WebRTC.RTCSessionDescription.prototype.getApplicationMedias = function(filter){
  return this.getMedias('application', filter);
};
WebRTC.RTCSessionDescription.prototype.getMedias = function(type, filter){
  var regex = new RegExp("(m="+type+"(?:(?!m=)[\\s\\S])*)", "mig");
  var match;
  var results = [];
  while((match = regex.exec(this.sdp)) !== null) {
    var media = match.pop();
    if(!filter || media.indexOf(filter) !== -1) {
      results.push(media);
    }
  }
  return results;
};
WebRTC.RTCSessionDescription.prototype.getAudioIcePwd = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=ice-pwd:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoIcePwd = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=ice-pwd:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioIceUfrag = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=ice-ufrag:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoIceUfrag = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=ice-ufrag:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getCandidates = function(media){
  var regex = new RegExp("a=candidate:(.*)", "ig");
  var matches;
  var result = [];
  while ((matches = regex.exec(media)) !== null)
  {
    result.push(matches[matches.length-1]);
  }
  return result;
};
WebRTC.RTCSessionDescription.prototype.getAudioCandidates = function(){
  var audio = this.getAudio();
  return audio ? this.getCandidates(audio) : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoCandidates = function(){
  var video = this.getVideo();
  return video ? this.getCandidates(video) : null;
};
WebRTC.RTCSessionDescription.prototype.getConnection = function(){
  var match = this.sdp.match(/v=(?:(?!m=)[\s\S])*c=(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudio = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideo = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioConnection = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*c=(.*)/mi);
  return match !== null ? match[match.length-1] : this.getConnection();
};
WebRTC.RTCSessionDescription.prototype.getVideoConnection = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*c=(.*)/mi);
  return match !== null ? match[match.length-1] : this.getConnection();
};
WebRTC.RTCSessionDescription.prototype.hasVideo = function(){
  return this.sdp.match(/m=video/) !== null;
};
WebRTC.RTCSessionDescription.prototype.hasAudio = function(){
  return this.sdp.match(/m=audio/) !== null;
};
WebRTC.RTCSessionDescription.prototype.videoPort = function(){
  var match = this.sdp.match(/m=video\s(\d*)\s/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.audioPort = function(){
  var match = this.sdp.match(/m=audio\s(\d*)\s/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioMedia = function(){
  var match = this.sdp.match(/m=audio\s(.*)/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoMedia = function(){
  var match = this.sdp.match(/m=video\s(.*)/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioCodecs = function(){
  var audioMedia = this.getAudioMedia();
  return this.getCodecs(audioMedia);
};
WebRTC.RTCSessionDescription.prototype.getVideoCodecs = function(){
  var videoMedia = this.getVideoMedia();
  return this.getCodecs(videoMedia);
};
WebRTC.RTCSessionDescription.prototype.getCodecs = function(media){
  if(!media) {
    return null;
  }
  var mediaParts = media.split(" ");
  return mediaParts.splice(2);
};
WebRTC.RTCSessionDescription.prototype.getAudioCodecRtpmap = function(codec){
  var regex = new RegExp("m=audio(?:(?!m=)[\\s\\S])*a=rtpmap:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoCodecRtpmap = function(codec){
  var regex = new RegExp("m=video(?:(?!m=)[\\s\\S])*a=rtpmap:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioCodecFmtp = function(codec){
  var regex = new RegExp("m=audio(?:(?!m=)[\\s\\S])*a=fmtp:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoCodecFmtp = function(codec){
  var regex = new RegExp("m=video(?:(?!m=)[\\s\\S])*a=fmtp:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioFingerprint = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=fingerprint:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoFingerprint = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=fingerprint:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioRtcp = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=rtcp:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoRtcp = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=rtcp:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.removeVideoFingerprint = function(){
  if(this.getVideoFingerprint()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(a=fingerprint:.*\r\n)/mi, "$1");
  }
};
WebRTC.RTCSessionDescription.prototype.removeAudioFingerprint = function(){
  if(this.getAudioFingerprint()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(a=fingerprint:.*\r\n)/mi, "$1");
  }
};
WebRTC.RTCSessionDescription.prototype.hasActiveVideo = function(){
  var videoPort = this.videoPort() || 0;
  var videoConnection = this.getVideoConnection() || "";
  return this.hasVideo() && videoPort > 0 && videoConnection.indexOf('0.0.0.0') === -1;
};
WebRTC.RTCSessionDescription.prototype.hasActiveAudio = function(){
  var audioPort = this.audioPort() || 0;
  var audioConnection = this.getAudioConnection() || "";
  return this.hasAudio() && audioPort > 0 && audioConnection.indexOf('0.0.0.0') === -1;
};
WebRTC.RTCSessionDescription.prototype.getVideoBandwidth = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*b=.*:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.setVideoBandwidth = function(videoBandwidth){
  if(this.getVideoBandwidth()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(b=.*)/mi, "$1b=AS:" + videoBandwidth);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\nb=AS:" + videoBandwidth);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoMode = function(mode){
  if(this.getVideoMode()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(a=(sendrecv|sendonly|recvonly|inactive))/mi, "$1a=" + mode);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\na=" + mode);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoPort = function(port){
  this.sdp = this.sdp.replace(/(m=video\s)(\d*)(\s)/i, "$1"+port+"$3");
};
WebRTC.RTCSessionDescription.prototype.getVideoMode = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=(sendrecv|sendonly|recvonly|inactive)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.setAudioMode = function(mode){
  if(this.getAudioMode()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(a=(sendrecv|sendonly|recvonly|inactive))/mi, "$1a=" + mode);
  } else {
    this.sdp = this.sdp.replace(/(m=audio.*(:?(?!m=)[\s\S])*(c=IN\s+IP4.*)?)/, "$1\r\na=" + mode);
  }
};
WebRTC.RTCSessionDescription.prototype.setAudioPort = function(port){
  this.sdp = this.sdp.replace(/(m=audio\s)(\d*)(\s)/i, "$1"+port+"$3");
};
WebRTC.RTCSessionDescription.prototype.setAudioConnection = function(audioConnection){
  if(this.getAudioConnection()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(c=.*)/mi, "$1c=" + audioConnection);
  } else {
    this.sdp = this.sdp.replace(/(m=audio.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\nc=" + audioConnection);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoConnection = function(videoConnection){
  if(this.getVideoConnection()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(c=.*)/mi, "$1c=" + videoConnection);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\nc=" + videoConnection);
  }
};
WebRTC.RTCSessionDescription.prototype.setAudioRtcp = function(audioRtcp){
  if(this.getAudioRtcp()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(a=rtcp:.*)/mi, "$1a=rtcp:" + audioRtcp);
  } else {
    this.sdp = this.sdp.replace(/(m=audio.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\na=rtcp:" + audioRtcp);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoRtcp = function(videoRtcp){
  if(this.getVideoRtcp()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(a=rtcp:.*)/mi, "$1a=rtcp:" + videoRtcp);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\na=rtcp:" + videoRtcp);
  }
};
WebRTC.RTCSessionDescription.prototype.getAudioMode = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=(sendrecv|sendonly|recvonly|inactive)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.isActive = function(){
  if(this.hasAudio() && this.audioPort() !== "0" && this.getAudioMode() !== ExSIP_C.INACTIVE) {
    return true;
  }
  if(this.hasVideo() && this.videoPort() !== "0" && this.getVideoMode() !== ExSIP_C.INACTIVE) {
    return true;
  }
  return false;
};
WebRTC.RTCSessionDescription.prototype.mediaChanges = function(otherSdp){
  var mediaChanges = [];
  if(this.hasAudio() !== otherSdp.hasAudio()) {
    mediaChanges.push("audio has changed");
  }
  if(this.hasVideo() !== otherSdp.hasVideo()) {
    mediaChanges.push("video has changed");
  }
  if(this.audioPort() !== otherSdp.audioPort()) {
    mediaChanges.push("audio port has changed : "+this.audioPort()+" - " + otherSdp.audioPort());
  }
  if(this.videoPort() !== otherSdp.videoPort()) {
    mediaChanges.push("video port has changed : "+this.videoPort()+" - " + otherSdp.videoPort());
  }
  if(this.getAudioConnection() !== otherSdp.getAudioConnection()) {
    mediaChanges.push("audio connection has changed : "+this.getAudioConnection()+" - " + otherSdp.getAudioConnection());
  }
  if(this.getVideoConnection() !== otherSdp.getVideoConnection()) {
    mediaChanges.push("video connection has changed : "+this.getVideoConnection()+" - " + otherSdp.getVideoConnection());
  }
  var audioCodecs = this.getAudioCodecs();
  if(!Utils.isEqArrays(audioCodecs, otherSdp.getAudioCodecs())) {
    mediaChanges.push("audio codecs has changed : "+audioCodecs+" - " + otherSdp.getAudioCodecs());
  }
  var videoCodecs = this.getVideoCodecs();
  if(!Utils.isEqArrays(videoCodecs, otherSdp.getVideoCodecs())) {
    mediaChanges.push("video codecs has changed : "+videoCodecs+" - " + otherSdp.getVideoCodecs());
  }

  if(audioCodecs) {
    for(var i = 0; i < audioCodecs.length; i++) {
      if(this.getAudioCodecRtpmap(audioCodecs[i]) !== otherSdp.getAudioCodecRtpmap(audioCodecs[i])) {
        mediaChanges.push("audio codec rtpmap for "+audioCodecs[i]+" has changed : "+this.getAudioCodecRtpmap(audioCodecs[i])+" - " + otherSdp.getAudioCodecRtpmap(audioCodecs[i]));
      }
//      if(this.getAudioCodecFmtp(audioCodecs[i]) !== otherSdp.getAudioCodecFmtp(audioCodecs[i])) {
//        mediaChanges.push("audio codec fmtp for "+audioCodecs[i]+" has changed : "+this.getAudioCodecFmtp(audioCodecs[i])+" - " + otherSdp.getAudioCodecFmtp(audioCodecs[i]));
//      }
    }
  }
  if(videoCodecs) {
    for(var j = 0; j < videoCodecs.length; j++) {
      if(this.getVideoCodecRtpmap(videoCodecs[j]) !== otherSdp.getVideoCodecRtpmap(videoCodecs[j])) {
        mediaChanges.push("video codec rtpmap for "+videoCodecs[j]+" has changed : "+this.getVideoCodecRtpmap(videoCodecs[j])+" - " + otherSdp.getVideoCodecRtpmap(videoCodecs[j]));
      }
//      if(this.getVideoCodecFmtp(videoCodecs[j]) !== otherSdp.getVideoCodecFmtp(videoCodecs[j])) {
//        mediaChanges.push("video codec fmtp for "+videoCodecs[j]+" has changed : "+this.getVideoCodecFmtp(videoCodecs[j])+" - " + otherSdp.getVideoCodecFmtp(videoCodecs[j]));
//      }
    }
  }

  return mediaChanges;
};

// New syntax for getting streams in Chrome M26.
if (WebRTC.RTCPeerConnection && WebRTC.RTCPeerConnection.prototype) {
  if (! WebRTC.RTCPeerConnection.prototype.getLocalStreams) {
    WebRTC.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this.localStreams;
    };
    WebRTC.RTCPeerConnection.prototype.getRemoteStreams = function() {
      return this.remoteStreams;
    };
  }
  WebRTC.RTCPeerConnection.prototype.isIceCandidateReady = function(candidate) {
    // if(mozRTCPeerConnection && !candidate) {
    //   return true;
    // }
    // if(!mozRTCPeerConnection && candidate) {
    //   return true;
    // }
    return candidate;
  };
}

// isSupported attribute.
if (WebRTC.getUserMedia && WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
  WebRTC.isSupported = true;
}
else {
  WebRTC.isSupported = false;
}

},{"./Constants":500,"./Utils":525}],527:[function(require,module,exports){
module.exports = sanityCheck;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var SIPMessage = require('./SIPMessage');
var Utils = require('./Utils');


var logger,
  message, ua, transport,
  requests = [],
  responses = [],
  all = [];


requests.push(rfc3261_8_2_2_1);
requests.push(rfc3261_16_3_4);
requests.push(rfc3261_18_3_request);
requests.push(rfc3261_8_2_2_2);

responses.push(rfc3261_8_1_3_3);
responses.push(rfc3261_18_3_response);

all.push(minimumHeaders);


function sanityCheck(m, u, t) {
  var len, pass;

  message = m;
  ua = u;
  transport = t;

  logger = ua.getLogger('ExSIP.sanitycheck');

  len = all.length;
  while(len--) {
    pass = all[len](message);
    if(pass === false) {
      return false;
    }
  }

  if(message instanceof SIPMessage.IncomingRequest) {
    len = requests.length;
    while(len--) {
      pass = requests[len](message);
      if(pass === false) {
        return false;
      }
    }
  }

  else if(message instanceof SIPMessage.IncomingResponse) {
    len = responses.length;
    while(len--) {
      pass = responses[len](message);
      if(pass === false) {
        return false;
      }
    }
  }

  //Everything is OK
  return true;
}


/*
 * Sanity Check for incoming Messages
 *
 * Requests:
 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
 *  - _rfc3261_16_3_4_ Receive a Request already sent by us
 *   Does not look at via sent-by but at exsip_id, which is inserted as
 *   a prefix in all initial requests generated by the ua
 *  - _rfc3261_18_3_request_ Body Content-Length
 *  - _rfc3261_8_2_2_2_ Merged Requests
 *
 * Responses:
 *  - _rfc3261_8_1_3_3_ Multiple Via headers
 *  - _rfc3261_18_3_response_ Body Content-Length
 *
 * All:
 *  - Minimum headers in a SIP message
 */

// Sanity Check functions for requests
function rfc3261_8_2_2_1() {
  if(message.s('to').uri.scheme !== 'sip') {
    logger.warn('Scheme ('+message.s('to').uri.scheme+') is not sip. Dropping the request', ua);
    reply(416);
    return false;
  }
}

function rfc3261_16_3_4() {
  if(!message.to_tag) {
    if(message.call_id.substr(0, 5) === ua.configuration.exsip_id) {
      logger.warn('Call_id ('+message.call_id+') is same as exsip ('+ua.configuration.exsip_id+'). Dropping the request', ua);
      reply(482);
      return false;
    }
  }
}

function rfc3261_18_3_request() {
  var len = Utils.str_utf8_length(message.body),
  contentLength = message.getHeader('content-length');

  if(len < contentLength) {
    logger.warn('Message body length ('+len+') is lower than the value in Content-Length header field ('+contentLength+'). Dropping the request', ua);
    reply(400);
    return false;
  }
}

function rfc3261_8_2_2_2() {
  var tr, idx,
    fromTag = message.from_tag,
    call_id = message.call_id,
    cseq = message.cseq;

  // Accept any in-dialog request.
  if(message.to_tag) {
    return;
  }

  // INVITE request.
  if (message.method === ExSIP_C.INVITE) {
    // If the branch matches the key of any IST then assume it is a retransmission
    // and ignore the INVITE.
    // TODO: we should reply the last response.
    if (ua.transactions.ist[message.via_branch]) {
      return false;
    }
    // Otherwise check whether it is a merged request.
    else {
      for(idx in ua.transactions.ist) {
        tr = ua.transactions.ist[idx];
        if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
          reply(482);
          return false;
        }
      }
    }
  }
  // Non INVITE request.
  else {
    // If the branch matches the key of any NIST then assume it is a retransmission
    // and ignore the request.
    // TODO: we should reply the last response.
    if (ua.transactions.nist[message.via_branch]) {
      return false;
    }
    // Otherwise check whether it is a merged request.
    else {
      for(idx in ua.transactions.nist) {
        tr = ua.transactions.nist[idx];
        if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
          reply(482);
          return false;
        }
      }
    }
  }
}

// Sanity Check functions for responses
function rfc3261_8_1_3_3() {
  if(message.getHeaders('via').length > 1) {
    logger.warn('More than one Via header field present in the response. Dropping the response');
    return false;
  }
}

function rfc3261_18_3_response() {
  var
    len = Utils.str_utf8_length(message.body),
    contentLength = message.getHeader('content-length');

    if(len < contentLength) {
      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');
      return false;
    }
}

// Sanity Check functions for requests and responses
function minimumHeaders() {
  var
    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
    idx = mandatoryHeaders.length;

  while(idx--) {
    if(!message.hasHeader(mandatoryHeaders[idx])) {
      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
      return false;
    }
  }
}

// Reply
function reply(status_code) {
  var to,
    response = "SIP/2.0 " + status_code + " " + ExSIP_C.REASON_PHRASE[status_code] + "\r\n",
    vias = message.getHeaders('via'),
    length = vias.length,
    idx = 0;

  for(idx; idx < length; idx++) {
    response += "Via: " + vias[idx] + "\r\n";
  }

  to = message.getHeader('To');

  if(!message.to_tag) {
    to += ';tag=' + Utils.newTag();
  }

  response += "To: " + to + "\r\n";
  response += "From: " + message.getHeader('From') + "\r\n";
  response += "Call-ID: " + message.call_id + "\r\n";
  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
  response += "\r\n";

  transport.send(response);
}
},{"./Constants":500,"./SIPMessage":519,"./Utils":525}],528:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],529:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],530:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],531:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":530,"./bdsft":532,"./constants":535,"./cookieconfig":536,"./cookieprop":537,"./dateformat":540,"./debug":541,"./element":542,"./eventbus":543,"./factory":544,"./icon":545,"./loader":546,"./popup":547,"./prop":548,"./urlconfig":550,"./utils":551,"./visibleprop":552,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],532:[function(require,module,exports){
module.exports=require(24)
},{"./app":531,"./binding":533,"./classesbinding":534,"./databinder":539,"./stylesmanager":549,"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":576}],533:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":532,"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],534:[function(require,module,exports){
module.exports=require(26)
},{"./binding":533,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],535:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],536:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":532,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":576,"jquery.cookie":575}],537:[function(require,module,exports){
module.exports=require(29)
},{"./constants":535,"./prop":548,"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":576,"jquery.cookie":575}],538:[function(require,module,exports){
module.exports=require(30)
},{"./constants":535,"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":557}],539:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":560}],540:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],541:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":528,"./bdsft":532,"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":553,"stacktrace-js":578}],542:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],543:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":532,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":560}],544:[function(require,module,exports){
module.exports=require(36)
},{"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":576}],545:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],546:[function(require,module,exports){
module.exports=require(38)
},{"../":531,"./constants":535,"./factory":544,"./stylesmanager":549,"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":556}],547:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":576}],548:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":577}],549:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":529,"./constants":535,"./css":538,"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],550:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":528,"./bdsft":532,"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],551:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":530,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":576}],552:[function(require,module,exports){
module.exports=require(44)
},{"./constants":535,"./prop":548,"./utils":551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],553:[function(require,module,exports){
module.exports=require(45)
},{"./debug":554,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],554:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":555}],555:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],556:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],557:[function(require,module,exports){
module.exports=require(49)
},{"./filters":558,"./utils":559,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],558:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],559:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],560:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":561,"es5-ext/object/valid-callable":570}],561:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":562,"es5-ext/object/is-callable":565,"es5-ext/object/normalize-options":569,"es5-ext/string/#/contains":572}],562:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":563,"./shim":564,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],563:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],564:[function(require,module,exports){
module.exports=require(56)
},{"../keys":566,"../valid-value":571,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],565:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],566:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":567,"./shim":568,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],567:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],568:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],569:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],570:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],571:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],572:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":573,"./shim":574,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],573:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],574:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],575:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":576}],576:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],577:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],578:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],579:[function(require,module,exports){
module.exports = {model: require('./lib/models/sound')};
},{"./lib/models/sound":582}],580:[function(require,module,exports){
module.exports = {
    volumeClick: 1,
    volumeDTMF: 1,
    volumeRingtone: 1
}

},{}],581:[function(require,module,exports){
module.exports = {"click":"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","dtmf-0":"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","dtmf-1":"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","dtmf-2":"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","dtmf-3":"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","dtmf-4":"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","dtmf-5":"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","dtmf-6":"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","dtmf-7":"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","dtmf-8":"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","dtmf-9":"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","dtmf-busy":"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","dtmf-pound":"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","dtmf-ringback":"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","dtmf-star":"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","ringtone":"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"}
},{}],582:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Sound, {
  media: require('../../js/media'),
  config: require('../../js/config')
});

var utils = require('webrtc-core').utils;

function Sound(eventbus, debug) {
  var self = {};

  var soundOut;
  var soundOutDTMF;
  var audioRingtone;

  self.init = function() {
    soundOut = utils.createElement('<audio>', {volume: self.volumeClick});
    soundOutDTMF = utils.createElement('<audio>', {volume: self.volumeDTMF});
    audioRingtone = utils.createElement('<audio>', {volume: self.volumeRingtone});
  };

  self.listeners = function() {
    eventbus.on(["disconnected", "endCall", "ended", "resumed", "started", "failed"], function(e) {
      self.pause();
    });
    eventbus.on("progress", function(e) {
      self.playDtmfRingback();
    });
    eventbus.on('newDTMF', function(e) {
      var digit = e.data.tone;
      debug.log('DTMF sent : ' + digit);
      if (!digit) {
        return;
      }
      var file = null;
      if (digit === "*") {
        file = "star";
      } else if (digit === "#") {
        file = "pound";
      } else {
        file = digit;
      }
      self.playDtmfTone(file);
    });    
  };

  self.muteDTMF = function(mute) {
    soundOutDTMF[0].muted = mute;
  };

  self.pause = function() {
    soundOut.trigger('pause');
    soundOutDTMF.trigger('pause');
    audioRingtone.trigger('pause');
  };

  self.playDtmfRingback = function() {
    self.playDtmf("dtmf-ringback", {
      loop: true
    });
  };

  self.playRingtone = function() {
    self.playTone(audioRingtone, 'ringtone', {
      loop: true
    });
  };

  self.playDtmfTone = function(tone) {
    self.playDtmf("dtmf-" + tone);
  };

  self.playClick = function() {
    self.play("click");
  };

  self.play = function(media, options) {
    self.playTone(soundOut, media, options);
  };

  self.playTone = function(audioSource, media, options) {
    // avoid restarting same playing audio
    if (audioSource.attr("src") === media && !audioSource[0].paused) {
      return;
    }
    options = options || {};
    if(!self.medias[media]) {
      console.error(media + ' not found for sound in ', Object.keys(self.medias))
      return;
    }
    audioSource.attr("src", 'data:audio/ogg;base64,'+self.medias[media]);
    if (options.loop) {
      audioSource.attr('loop', 'true');
    } else {
      audioSource.removeAttr('loop');
    }
    audioSource.trigger('play');
  };

  self.playDtmf = function(media, options) {
    self.playTone(soundOutDTMF, media, options);
  };

  return self;
}

},{"../../js/config":580,"../../js/media":581,"webrtc-core":586}],583:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],584:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],585:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],586:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":585,"./bdsft":587,"./constants":590,"./cookieconfig":591,"./cookieprop":592,"./dateformat":595,"./debug":596,"./element":597,"./eventbus":598,"./factory":599,"./icon":600,"./loader":601,"./popup":602,"./prop":603,"./urlconfig":605,"./utils":606,"./visibleprop":607,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],587:[function(require,module,exports){
module.exports=require(24)
},{"./app":586,"./binding":588,"./classesbinding":589,"./databinder":594,"./stylesmanager":604,"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":631}],588:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":587,"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],589:[function(require,module,exports){
module.exports=require(26)
},{"./binding":588,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],590:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],591:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":587,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":631,"jquery.cookie":630}],592:[function(require,module,exports){
module.exports=require(29)
},{"./constants":590,"./prop":603,"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":631,"jquery.cookie":630}],593:[function(require,module,exports){
module.exports=require(30)
},{"./constants":590,"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":612}],594:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":615}],595:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],596:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":583,"./bdsft":587,"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":608,"stacktrace-js":633}],597:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],598:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":587,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":615}],599:[function(require,module,exports){
module.exports=require(36)
},{"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":631}],600:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],601:[function(require,module,exports){
module.exports=require(38)
},{"../":586,"./constants":590,"./factory":599,"./stylesmanager":604,"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":611}],602:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":631}],603:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":632}],604:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":584,"./constants":590,"./css":593,"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],605:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":583,"./bdsft":587,"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],606:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":585,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":631}],607:[function(require,module,exports){
module.exports=require(44)
},{"./constants":590,"./prop":603,"./utils":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],608:[function(require,module,exports){
module.exports=require(45)
},{"./debug":609,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],609:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":610}],610:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],611:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],612:[function(require,module,exports){
module.exports=require(49)
},{"./filters":613,"./utils":614,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],613:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],614:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],615:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":616,"es5-ext/object/valid-callable":625}],616:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":617,"es5-ext/object/is-callable":620,"es5-ext/object/normalize-options":624,"es5-ext/string/#/contains":627}],617:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":618,"./shim":619,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],618:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],619:[function(require,module,exports){
module.exports=require(56)
},{"../keys":621,"../valid-value":626,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],620:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],621:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":622,"./shim":623,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],622:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],623:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],624:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],625:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],626:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],627:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":628,"./shim":629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],628:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],629:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],630:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":631}],631:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],632:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],633:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],634:[function(require,module,exports){
module.exports = {view: require('./lib/views/stats'), model: require('./lib/models/stats'), constants: require('./lib/constants')};
},{"./lib/constants":639,"./lib/models/stats":640,"./lib/views/stats":641}],635:[function(require,module,exports){
module.exports = {
    enableCallStats: true
};
},{}],636:[function(require,module,exports){
module.exports = Stats
  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.


// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


function Stats(callback) {
  var self = {};

  /**
   * SsrcInfoManager stores the ssrc stream info extracted from SDP.
   */
  var SsrcInfoManager = (function() {
    'use strict';

    /**
     * @constructor
     */
    function SsrcInfoManager() {
      /**
       * Map from ssrc id to an object containing all the stream properties.
       * @type {!Object.<string, !Object.<string>>}
       * @private
       */
      this.streamInfoContainer_ = {};

      /**
       * The string separating attibutes in an SDP.
       * @type {string}
       * @const
       * @private
       */
      this.ATTRIBUTE_SEPARATOR_ = /[\r,\n]/;

      /**
       * The regex separating fields within an ssrc description.
       * @type {RegExp}
       * @const
       * @private
       */
      this.FIELD_SEPARATOR_REGEX_ = / .*:/;

      /**
       * The prefix string of an ssrc description.
       * @type {string}
       * @const
       * @private
       */
      this.SSRC_ATTRIBUTE_PREFIX_ = 'a=ssrc:';

      /**
       * The className of the ssrc info parent element.
       * @type {string}
       * @const
       * @private
       */
      this.SSRC_INFO_BLOCK_CLASS_ = 'ssrc-info-block';
    }

    SsrcInfoManager.prototype = {
      /**
       * Extracts the stream information from |sdp| and saves it.
       * For example:
       *     a=ssrc:1234 msid:abcd
       *     a=ssrc:1234 label:hello
       *
       * @param {string} sdp The SDP string.
       */
      addSsrcStreamInfo: function(sdp) {
        var attributes = sdp.split(this.ATTRIBUTE_SEPARATOR_);
        for (var i = 0; i < attributes.length; ++i) {
          // Check if this is a ssrc attribute.
          if (attributes[i].indexOf(this.SSRC_ATTRIBUTE_PREFIX_) != 0)
            continue;

          var nextFieldIndex = attributes[i].search(this.FIELD_SEPARATOR_REGEX_);

          if (nextFieldIndex == -1)
            continue;

          var ssrc = attributes[i].substring(this.SSRC_ATTRIBUTE_PREFIX_.length,
            nextFieldIndex);
          if (!this.streamInfoContainer_[ssrc])
            this.streamInfoContainer_[ssrc] = {};

          // Make |rest| starting at the next field.
          var rest = attributes[i].substring(nextFieldIndex + 1);
          var name, value;
          while (rest.length > 0) {
            nextFieldIndex = rest.search(this.FIELD_SEPARATOR_REGEX_);
            if (nextFieldIndex == -1)
              nextFieldIndex = rest.length;

            // The field name is the string before the colon.
            name = rest.substring(0, rest.indexOf(':'));
            // The field value is from after the colon to the next field.
            value = rest.substring(rest.indexOf(':') + 1, nextFieldIndex);
            this.streamInfoContainer_[ssrc][name] = value;

            // Move |rest| to the start of the next field.
            rest = rest.substring(nextFieldIndex + 1);
          }
        }
      },

      /**
       * @param {string} sdp The ssrc id.
       * @return {!Object.<string>} The object containing the ssrc infomation.
       */
      getStreamInfo: function(ssrc) {
        return this.streamInfoContainer_[ssrc];
      },

      /**
       * Populate the ssrc information into |parentElement|, each field as a
       * DIV element.
       *
       * @param {!Element} parentElement The parent element for the ssrc info.
       * @param {string} ssrc The ssrc id.
       */
      populateSsrcInfo: function(parentElement, ssrc) {
        if (!this.streamInfoContainer_[ssrc])
          return;

        parentElement.className = this.SSRC_INFO_BLOCK_CLASS_;

        var fieldElement;
        for (var property in this.streamInfoContainer_[ssrc]) {
          fieldElement = document.createElement('div');
          parentElement.appendChild(fieldElement);
          fieldElement.textContent =
            property + ':' + this.streamInfoContainer_[ssrc][property];
        }
      }
    };

    return SsrcInfoManager;
  })();

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.

  //
  // This file contains helper methods to draw the stats timeline graphs.
  // Each graph represents a series of stats report for a PeerConnection,
  // e.g. 1234-0-ssrc-abcd123-bytesSent is the graph for the series of bytesSent
  // for ssrc-abcd123 of PeerConnection 0 in process 1234.
  // The graphs are drawn as CANVAS, grouped per report type per PeerConnection.
  // Each group has an expand/collapse button and is collapsed initially.
  //

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.

  /**
   * A TimelineDataSeries collects an ordered series of (time, value) pairs,
   * and converts them to graph points.  It also keeps track of its color and
   * current visibility state.
   */
  var TimelineDataSeries = (function() {
    'use strict';

    /**
     * @constructor
     */
    function TimelineDataSeries() {
      // List of DataPoints in chronological order.
      this.dataPoints_ = [];

      // Default color.  Should always be overridden prior to display.
      this.color_ = 'red';
      // Whether or not the data series should be drawn.
      this.isVisible_ = true;

      this.cacheStartTime_ = null;
      this.cacheStepSize_ = 0;
      this.cacheValues_ = [];
    }

    TimelineDataSeries.prototype = {
      /**
       * Adds a DataPoint to |this| with the specified time and value.
       * DataPoints are assumed to be received in chronological order.
       */
      addPoint: function(timeTicks, value) {
        var time = new Date(timeTicks);
        this.dataPoints_.push(new DataPoint(time, value));
      },

      isVisible: function() {
        return this.isVisible_;
      },

      show: function(isVisible) {
        this.isVisible_ = isVisible;
      },

      getColor: function() {
        return this.color_;
      },

      setColor: function(color) {
        this.color_ = color;
      },

      getAvg: function() {
        var sum = 0;
        for (var i = 0; i < this.dataPoints_.length; i++) {
          sum += this.dataPoints_[i].value;
        }
        return sum / this.dataPoints_.length;
      },
      /**
       * Returns a list containing the values of the data series at |count|
       * points, starting at |startTime|, and |stepSize| milliseconds apart.
       * Caches values, so showing/hiding individual data series is fast.
       */
      getValues: function(startTime, stepSize, count) {
        // Use cached values, if we can.
        if (this.cacheStartTime_ == startTime &&
          this.cacheStepSize_ == stepSize &&
          this.cacheValues_.length == count) {
          return this.cacheValues_;
        }

        // Do all the work.
        this.cacheValues_ = this.getValuesInternal_(startTime, stepSize, count);
        this.cacheStartTime_ = startTime;
        this.cacheStepSize_ = stepSize;

        return this.cacheValues_;
      },

      /**
       * Returns the cached |values| in the specified time period.
       */
      getValuesInternal_: function(startTime, stepSize, count) {
        var values = [];
        var nextPoint = 0;
        var currentValue = 0;
        var time = startTime;
        for (var i = 0; i < count; ++i) {
          while (nextPoint < this.dataPoints_.length &&
            this.dataPoints_[nextPoint].time < time) {
            currentValue = this.dataPoints_[nextPoint].value;
            ++nextPoint;
          }
          values[i] = currentValue;
          time += stepSize;
        }
        return values;
      }
    };

    /**
     * A single point in a data series.  Each point has a time, in the form of
     * milliseconds since the Unix epoch, and a numeric value.
     * @constructor
     */
    function DataPoint(time, value) {
      this.time = time;
      this.value = value;
    }

    return TimelineDataSeries;
  })();

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.

  /**
   * A TimelineGraphView displays a timeline graph on a canvas element.
   */
  var TimelineGraphView = (function() {
    'use strict';

    // Default starting scale factor, in terms of milliseconds per pixel.
    var DEFAULT_SCALE = 2000;

    // Maximum number of labels placed vertically along the sides of the graph.
    var MAX_VERTICAL_LABELS = 6;

    // Vertical spacing between labels and between the graph and labels.
    var LABEL_VERTICAL_SPACING = 4;
    // Horizontal spacing between vertically placed labels and the edges of the
    // graph.
    var LABEL_HORIZONTAL_SPACING = 3;
    // Horizintal spacing between two horitonally placed labels along the bottom
    // of the graph.
    var LABEL_LABEL_HORIZONTAL_SPACING = 25;

    // Length of ticks, in pixels, next to y-axis labels.  The x-axis only has
    // one set of labels, so it can use lines instead.
    var Y_AXIS_TICK_LENGTH = 10;

    var GRID_COLOR = '#CCC';
    var TEXT_COLOR = '#000';
    var BACKGROUND_COLOR = '#FFF';

    /**
     * @constructor
     */
    function TimelineGraphView(divId, canvasId) {
      this.scrollbar_ = {
        position_: 0,
        range_: 0
      };

      this.graphDiv_ = $('[id="' + divId + '"]')[0];
      this.canvas_ = $('[id="' + canvasId + '"]')[0];

      // Set the range and scale of the graph.  Times are in milliseconds since
      // the Unix epoch.

      // All measurements we have must be after this time.
      this.startTime_ = 0;
      // The current rightmost position of the graph is always at most this.
      this.endTime_ = 1;

      this.graph_ = null;

      // Initialize the scrollbar.
      this.updateScrollbarRange_(true);
    }

    TimelineGraphView.prototype = {
      // Returns the total length of the graph, in pixels.
      getLength_: function() {
        var timeRange = this.endTime_ - this.startTime_;
        // Math.floor is used to ignore the last partial area, of length less
        // than DEFAULT_SCALE.
        return Math.floor(timeRange / DEFAULT_SCALE);
      },

      /**
       * Returns true if the graph is scrolled all the way to the right.
       */
      graphScrolledToRightEdge_: function() {
        return this.scrollbar_.position_ == this.scrollbar_.range_;
      },

      /**
       * Update the range of the scrollbar.  If |resetPosition| is true, also
       * sets the slider to point at the rightmost position and triggers a
       * repaint.
       */
      updateScrollbarRange_: function(resetPosition) {
        var scrollbarRange = this.getLength_() - this.canvas_ && this.canvas_.width || 0;
        if (scrollbarRange < 0)
          scrollbarRange = 0;

        // If we've decreased the range to less than the current scroll position,
        // we need to move the scroll position.
        if (this.scrollbar_.position_ > scrollbarRange)
          resetPosition = true;

        this.scrollbar_.range_ = scrollbarRange;
        if (resetPosition) {
          this.scrollbar_.position_ = scrollbarRange;
          this.repaint();
        }
      },

      /**
       * Sets the date range displayed on the graph, switches to the default
       * scale factor, and moves the scrollbar all the way to the right.
       */
      setDateRange: function(startDate, endDate) {
        this.startTime_ = startDate.getTime();
        this.endTime_ = endDate.getTime();

        // Safety check.
        if (this.endTime_ <= this.startTime_)
          this.startTime_ = this.endTime_ - 1;

        this.updateScrollbarRange_(true);
      },

      /**
       * Updates the end time at the right of the graph to be the current time.
       * Specifically, updates the scrollbar's range, and if the scrollbar is
       * all the way to the right, keeps it all the way to the right.  Otherwise,
       * leaves the view as-is and doesn't redraw anything.
       */
      updateEndDate: function() {
        this.endTime_ = (new Date()).getTime();
        this.updateScrollbarRange_(this.graphScrolledToRightEdge_());
      },

      getStartDate: function() {
        return new Date(this.startTime_);
      },

      /**
       * Replaces the current TimelineDataSeries with |dataSeries|.
       */
      setDataSeries: function(dataSeries) {
        // Simply recreates the Graph.
        this.graph_ = new Graph();
        for (var i = 0; i < dataSeries.length; ++i)
          this.graph_.addDataSeries(dataSeries[i]);
        this.repaint();
      },

      /**
       * Adds |dataSeries| to the current graph.
       */
      addDataSeries: function(dataSeries) {
        if (!this.graph_)
          this.graph_ = new Graph();
        this.graph_.addDataSeries(dataSeries);
        this.repaint();
      },

      /**
       * Draws the graph on |canvas_|.
       */
      repaint: function() {
        if(!this.canvas_) {
          return;
        }
        this.repaintTimerRunning_ = false;

        var width = this.canvas_.width;
        var height = this.canvas_.height;
        var context = this.canvas_.getContext('2d');

        // Clear the canvas.
        context.fillStyle = BACKGROUND_COLOR;
        context.fillRect(0, 0, width, height);

        // Try to get font height in pixels.  Needed for layout.
        var fontHeightString = context.font.match(/([0-9]+)px/)[1];
        var fontHeight = parseInt(fontHeightString);

        // Safety check, to avoid drawing anything too ugly.
        if (fontHeightString.length == 0 || fontHeight <= 0 ||
          fontHeight * 4 > height || width < 50) {
          return;
        }

        // Save current transformation matrix so we can restore it later.
        context.save();

        // The center of an HTML canvas pixel is technically at (0.5, 0.5).  This
        // makes near straight lines look bad, due to anti-aliasing.  This
        // translation reduces the problem a little.
        context.translate(0.5, 0.5);

        // Figure out what time values to display.
        var position = this.scrollbar_.position_;
        // If the entire time range is being displayed, align the right edge of
        // the graph to the end of the time range.
        if (this.scrollbar_.range_ == 0)
          position = this.getLength_() - this.canvas_.width;
        var visibleStartTime = this.startTime_ + position * DEFAULT_SCALE;

        // Make space at the bottom of the graph for the time labels, and then
        // draw the labels.
        var textHeight = height;
        height -= fontHeight + LABEL_VERTICAL_SPACING;
        this.drawTimeLabels(context, width, height, textHeight, visibleStartTime);

        // Draw outline of the main graph area.
        context.strokeStyle = GRID_COLOR;
        context.strokeRect(0, 0, width - 1, height - 1);

        if (this.graph_) {
          // Layout graph and have them draw their tick marks.
          this.graph_.layout(
            width, height, fontHeight, visibleStartTime, DEFAULT_SCALE);
          this.graph_.drawTicks(context);

          // Draw the lines of all graphs, and then draw their labels.
          this.graph_.drawLines(context);
          this.graph_.drawLabels(context);
        }

        // Restore original transformation matrix.
        context.restore();
      },

      /**
       * Draw time labels below the graph.  Takes in start time as an argument
       * since it may not be |startTime_|, when we're displaying the entire
       * time range.
       */
      drawTimeLabels: function(context, width, height, textHeight, startTime) {
        // Text for a time string to use in determining how far apart
        // to place text labels.
        var sampleText = (new Date(startTime)).toLocaleTimeString();

        // The desired spacing for text labels.
        var targetSpacing = context.measureText(sampleText).width +
          LABEL_LABEL_HORIZONTAL_SPACING;

        // The allowed time step values between adjacent labels.  Anything much
        // over a couple minutes isn't terribly realistic, given how much memory
        // we use, and how slow a lot of the net-internals code is.
        var timeStepValues = [
          1000, // 1 second
          1000 * 5,
          1000 * 30,
          1000 * 60, // 1 minute
          1000 * 60 * 5,
          1000 * 60 * 30,
          1000 * 60 * 60, // 1 hour
          1000 * 60 * 60 * 5
        ];

        // Find smallest time step value that gives us at least |targetSpacing|,
        // if any.
        var timeStep = null;
        for (var i = 0; i < timeStepValues.length; ++i) {
          if (timeStepValues[i] / DEFAULT_SCALE >= targetSpacing) {
            timeStep = timeStepValues[i];
            break;
          }
        }

        // If no such value, give up.
        if (!timeStep)
          return;

        // Find the time for the first label.  This time is a perfect multiple of
        // timeStep because of how UTC times work.
        var time = Math.ceil(startTime / timeStep) * timeStep;

        context.textBaseline = 'bottom';
        context.textAlign = 'center';
        context.fillStyle = TEXT_COLOR;
        context.strokeStyle = GRID_COLOR;

        // Draw labels and vertical grid lines.
        while (true) {
          var x = Math.round((time - startTime) / DEFAULT_SCALE);
          if (x >= width)
            break;
          var text = (new Date(time)).toLocaleTimeString();
          context.fillText(text, x, textHeight);
          context.beginPath();
          context.lineTo(x, 0);
          context.lineTo(x, height);
          context.stroke();
          time += timeStep;
        }
      },

      getDataSeriesCount: function() {
        if (this.graph_)
          return this.graph_.dataSeries_.length;
        return 0;
      },

      hasDataSeries: function(dataSeries) {
        if (this.graph_)
          return this.graph_.hasDataSeries(dataSeries);
        return false;
      },

    };

    /**
     * A Graph is responsible for drawing all the TimelineDataSeries that have
     * the same data type.  Graphs are responsible for scaling the values, laying
     * out labels, and drawing both labels and lines for its data series.
     */
    var Graph = (function() {
      /**
       * @constructor
       */
      function Graph() {
        this.dataSeries_ = [];

        // Cached properties of the graph, set in layout.
        this.width_ = 0;
        this.height_ = 0;
        this.fontHeight_ = 0;
        this.startTime_ = 0;
        this.scale_ = 0;

        // At least the highest value in the displayed range of the graph.
        // Used for scaling and setting labels.  Set in layoutLabels.
        this.max_ = 0;

        // Cached text of equally spaced labels.  Set in layoutLabels.
        this.labels_ = [];
      }

      /**
       * A Label is the label at a particular position along the y-axis.
       * @constructor
       */
      function Label(height, text) {
        this.height = height;
        this.text = text;
      }

      Graph.prototype = {
        addDataSeries: function(dataSeries) {
          this.dataSeries_.push(dataSeries);
        },

        hasDataSeries: function(dataSeries) {
          for (var i = 0; i < this.dataSeries_.length; ++i) {
            if (this.dataSeries_[i] == dataSeries)
              return true;
          }
          return false;
        },

        /**
         * Returns a list of all the values that should be displayed for a given
         * data series, using the current graph layout.
         */
        getValues: function(dataSeries) {
          if (!dataSeries.isVisible())
            return null;
          return dataSeries.getValues(this.startTime_, this.scale_, this.width_);
        },

        /**
         * Updates the graph's layout.  In particular, both the max value and
         * label positions are updated.  Must be called before calling any of the
         * drawing functions.
         */
        layout: function(width, height, fontHeight, startTime, scale) {
          this.width_ = width;
          this.height_ = height;
          this.fontHeight_ = fontHeight;
          this.startTime_ = startTime;
          this.scale_ = scale;

          // Find largest value.
          var max = 0;
          for (var i = 0; i < this.dataSeries_.length; ++i) {
            var values = this.getValues(this.dataSeries_[i]);
            if (!values)
              continue;
            for (var j = 0; j < values.length; ++j) {
              if (values[j] > max)
                max = values[j];
            }
          }

          this.layoutLabels_(max);
        },

        /**
         * Lays out labels and sets |max_|, taking the time units into
         * consideration.  |maxValue| is the actual maximum value, and
         * |max_| will be set to the value of the largest label, which
         * will be at least |maxValue|.
         */
        layoutLabels_: function(maxValue) {
          if (maxValue < 1024) {
            this.layoutLabelsBasic_(maxValue, 0);
            return;
          }

          // Find appropriate units to use.
          var units = ['', 'm', 'M', 'G', 'T', 'P'];
          // Units to use for labels.  0 is '1', 1 is K, etc.
          // We start with 1, and work our way up.
          var unit = 1;
          maxValue /= 1024;
          while (units[unit + 1] && maxValue >= 1024) {
            maxValue /= 1024;
            ++unit;
          }

          // Calculate labels.
          this.layoutLabelsBasic_(maxValue, 1);

          // Append units to labels.
          for (var i = 0; i < this.labels_.length; ++i)
            this.labels_[i] += ' ' + units[unit];

          // Convert |max_| back to unit '1'.
          this.max_ *= Math.pow(1024, unit);
        },

        /**
         * Same as layoutLabels_, but ignores units.  |maxDecimalDigits| is the
         * maximum number of decimal digits allowed.  The minimum allowed
         * difference between two adjacent labels is 10^-|maxDecimalDigits|.
         */
        layoutLabelsBasic_: function(maxValue, maxDecimalDigits) {
          this.labels_ = [];
          // No labels if |maxValue| is 0.
          if (maxValue == 0) {
            this.max_ = maxValue;
            return;
          }

          // The maximum number of equally spaced labels allowed.  |fontHeight_|
          // is doubled because the top two labels are both drawn in the same
          // gap.
          var minLabelSpacing = 2 * this.fontHeight_ + LABEL_VERTICAL_SPACING;

          // The + 1 is for the top label.
          var maxLabels = 1 + this.height_ / minLabelSpacing;
          if (maxLabels < 2) {
            maxLabels = 2;
          } else if (maxLabels > MAX_VERTICAL_LABELS) {
            maxLabels = MAX_VERTICAL_LABELS;
          }

          // Initial try for step size between conecutive labels.
          var stepSize = Math.pow(10, -maxDecimalDigits);
          // Number of digits to the right of the decimal of |stepSize|.
          // Used for formating label strings.
          var stepSizeDecimalDigits = maxDecimalDigits;

          // Pick a reasonable step size.
          while (true) {
            // If we use a step size of |stepSize| between labels, we'll need:
            //
            // Math.ceil(maxValue / stepSize) + 1
            //
            // labels.  The + 1 is because we need labels at both at 0 and at
            // the top of the graph.

            // Check if we can use steps of size |stepSize|.
            if (Math.ceil(maxValue / stepSize) + 1 <= maxLabels)
              break;
            // Check |stepSize| * 2.
            if (Math.ceil(maxValue / (stepSize * 2)) + 1 <= maxLabels) {
              stepSize *= 2;
              break;
            }
            // Check |stepSize| * 5.
            if (Math.ceil(maxValue / (stepSize * 5)) + 1 <= maxLabels) {
              stepSize *= 5;
              break;
            }
            stepSize *= 10;
            if (stepSizeDecimalDigits > 0)
              --stepSizeDecimalDigits;
          }

          // Set the max so it's an exact multiple of the chosen step size.
          this.max_ = Math.ceil(maxValue / stepSize) * stepSize;

          // Create labels.
          for (var label = this.max_; label >= 0; label -= stepSize)
            this.labels_.push(label.toFixed(stepSizeDecimalDigits));
        },

        /**
         * Draws tick marks for each of the labels in |labels_|.
         */
        drawTicks: function(context) {
          var x1;
          var x2;
          x1 = this.width_ - 1;
          x2 = this.width_ - 1 - Y_AXIS_TICK_LENGTH;

          context.fillStyle = GRID_COLOR;
          context.beginPath();
          for (var i = 1; i < this.labels_.length - 1; ++i) {
            // The rounding is needed to avoid ugly 2-pixel wide anti-aliased
            // lines.
            var y = Math.round(this.height_ * i / (this.labels_.length - 1));
            context.moveTo(x1, y);
            context.lineTo(x2, y);
          }
          context.stroke();
        },

        /**
         * Draws a graph line for each of the data series.
         */
        drawLines: function(context) {
          // Factor by which to scale all values to convert them to a number from
          // 0 to height - 1.
          var scale = 0;
          var bottom = this.height_ - 1;
          if (this.max_)
            scale = bottom / this.max_;

          // Draw in reverse order, so earlier data series are drawn on top of
          // subsequent ones.
          for (var i = this.dataSeries_.length - 1; i >= 0; --i) {
            var values = this.getValues(this.dataSeries_[i]);
            if (!values)
              continue;
            context.strokeStyle = this.dataSeries_[i].getColor();
            context.beginPath();
            for (var x = 0; x < values.length; ++x) {
              // The rounding is needed to avoid ugly 2-pixel wide anti-aliased
              // horizontal lines.
              context.lineTo(x, bottom - Math.round(values[x] * scale));
            }
            context.stroke();
          }
        },

        /**
         * Draw labels in |labels_|.
         */
        drawLabels: function(context) {
          if (this.labels_.length == 0)
            return;
          var x = this.width_ - LABEL_HORIZONTAL_SPACING;

          // Set up the context.
          context.fillStyle = TEXT_COLOR;
          context.textAlign = 'right';

          // Draw top label, which is the only one that appears below its tick
          // mark.
          context.textBaseline = 'top';
          context.fillText(this.labels_[0], x, 0);

          // Draw all the other labels.
          context.textBaseline = 'bottom';
          var step = (this.height_ - 1) / (this.labels_.length - 1);
          for (var i = 1; i < this.labels_.length; ++i)
            context.fillText(this.labels_[i], x, step * i);
        }
      };

      return Graph;
    })();

    return TimelineGraphView;
  })();

  /**
   * Maintains the stats table.
   * @param {SsrcInfoManager} ssrcInfoManager The source of the ssrc info.
   */
  var StatsTable = (function(ssrcInfoManager) {
    'use strict';

    /**
     * @param {SsrcInfoManager} ssrcInfoManager The source of the ssrc info.
     * @constructor
     */
    function StatsTable(ssrcInfoManager) {
      /**
       * @type {SsrcInfoManager}
       * @private
       */
      this.ssrcInfoManager_ = ssrcInfoManager;
    }

    StatsTable.prototype = {
      /**
       * Adds |report| to the stats table of |peerConnectionElement|.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @param {!Object} report The object containing stats, which is the object
       *     containing timestamp and values, which is an array of strings, whose
       *     even index entry is the name of the stat, and the odd index entry is
       *     the value.
       */
      addStatsReport: function(peerConnectionElement, reportType, reportId, report) {
        var statsTable = this.ensureStatsTable_(peerConnectionElement, report);

        if (report.stats) {
          this.addStatsToTable_(peerConnectionElement, reportType, reportId, statsTable,
            report.stats.timestamp, report.stats.values);
        }
      },

      /**
       * Ensure the DIV container for the stats tables is created as a child of
       * |peerConnectionElement|.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @return {!Element} The stats table container.
       * @private
       */
      ensureStatsTableContainer_: function(peerConnectionElement) {
        var containerId = peerConnectionElement.id + '-table-container';
        var container = $('[id="' + containerId + '"]')[0];
        if (!container) {
          container = document.createElement('div');
          container.id = containerId;
          container.className = 'stats-table-container';
          peerConnectionElement.appendChild(container);
        }
        return container;
      },

      /**
       * Ensure the stats table for track specified by |report| of PeerConnection
       * |peerConnectionElement| is created.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @param {!Object} report The object containing stats, which is the object
       *     containing timestamp and values, which is an array of strings, whose
       *     even index entry is the name of the stat, and the odd index entry is
       *     the value.
       * @return {!Element} The stats table element.
       * @private
       */
      ensureStatsTable_: function(peerConnectionElement, report) {
        var tableId = peerConnectionElement.id + '-table-' + report.type + '-' + report.id;
        var table = $(document.getElementById(tableId))[0];
        if (!table) {
          var container = this.ensureStatsTableContainer_(peerConnectionElement);
          table = document.createElement('table');
          container.appendChild(table);
          table.id = tableId;
          table.border = 1;

          table.innerHTML = '<tr><th colspan=2></th></tr>';
          table.rows[0].cells[0].textContent =
            'Statistics ' + report.type + '-' + report.id;
          if (report.type == 'ssrc') {
            table.insertRow(1);
            table.rows[1].innerHTML = '<td colspan=2></td>';
            this.ssrcInfoManager_.populateSsrcInfo(
              table.rows[1].cells[0], report.id);
          }
        }
        return table;
      },

      /**
       * Update |statsTable| with |time| and |statsData|.
       *
       * @param {!Element} statsTable Which table to update.
       * @param {number} time The number of miliseconds since epoch.
       * @param {Array.<string>} statsData An array of stats name and value pairs.
       * @private
       */
      addStatsToTable_: function(peerConnectionElement, reportType, reportId, statsTable, time, statsData) {
        var date = Date(time);

        callback.onAddStats(peerConnectionElement, reportType, reportId, statsData);
      },

      /**
       * Update the value column of the stats row of |rowName| to |value|.
       * A new row is created is this is the first report of this stats.
       *
       * @param {!Element} statsTable Which table to update.
       * @param {string} rowName The name of the row to update.
       * @param {string} value The new value to set.
       * @private
       */
      updateStatsTableRow_: function(statsTable, rowName, value) {
        var trId = statsTable.id + '-' + rowName;
        var trElement = $('[id="' + trId + '"]')[0];
        if (!trElement) {
          trElement = document.createElement('tr');
          trElement.id = trId;
          statsTable.firstChild.appendChild(trElement);
          trElement.innerHTML = '<td>' + rowName + '</td><td></td>';
        }
        trElement.cells[1].textContent = value;
      }
    };

    return StatsTable;
  })();

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.


  /**
   * The data of a peer connection update.
   * @param {number} pid The id of the renderer.
   * @param {number} lid The id of the peer conneciton inside a renderer.
   * @param {string} type The type of the update.
   * @param {string} value The details of the update.
   * @constructor
   */
  var PeerConnectionUpdateEntry = function(pid, lid, type, value) {
    /**
     * @type {number}
     */
    this.pid = pid;

    /**
     * @type {number}
     */
    this.lid = lid;

    /**
     * @type {string}
     */
    this.type = type;

    /**
     * @type {string}
     */
    this.value = value;
  };


  /**
   * Maintains the peer connection update log table.
   */
  var PeerConnectionUpdateTable = (function() {
    'use strict';

    /**
     * @constructor
     */
    function PeerConnectionUpdateTable() {
      /**
       * @type {string}
       * @const
       * @private
       */
      this.UPDATE_LOG_ID_SUFFIX_ = '-update-log';

      /**
       * @type {string}
       * @const
       * @private
       */
      this.UPDATE_LOG_CONTAINER_CLASS_ = 'update-log-container';

      /**
       * @type {string}
       * @const
       * @private
       */
      this.UPDATE_LOG_TABLE_CLASS_ = 'update-log-table';
    }

    PeerConnectionUpdateTable.prototype = {
      /**
       * Adds the update to the update table as a new row. The type of the update
       * is set to the summary of the cell; clicking the cell will reveal or hide
       * the details as the content of a TextArea element.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @param {!PeerConnectionUpdateEntry} update The update to add.
       */
      addPeerConnectionUpdate: function(peerConnectionElement, update) {
        var tableElement = this.ensureUpdateContainer_(peerConnectionElement);

        var row = document.createElement('tr');
        tableElement.firstChild.appendChild(row);

        row.innerHTML = '<td>' + (new Date()).toLocaleString() + '</td>';

        if (update.value.length == 0) {
          row.innerHTML += '<td>' + update.type + '</td>';
          return;
        }

        row.innerHTML += '<td><details><summary>' + update.type +
          '</summary></details></td>';

        var valueContainer = document.createElement('pre');
        var details = row.cells[1].childNodes[0];
        details.appendChild(valueContainer);
        valueContainer.textContent = update.value;
      },

      /**
       * Makes sure the update log table of the peer connection is created.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @return {!Element} The log table element.
       * @private
       */
      ensureUpdateContainer_: function(peerConnectionElement) {
        var tableId = peerConnectionElement.id + this.UPDATE_LOG_ID_SUFFIX_;
        var tableElement = $('[id="' + tableId + '"]')[0];
        if (!tableElement) {
          var tableContainer = document.createElement('div');
          tableContainer.className = this.UPDATE_LOG_CONTAINER_CLASS_;
          peerConnectionElement.appendChild(tableContainer);

          tableElement = document.createElement('table');
          tableElement.className = this.UPDATE_LOG_TABLE_CLASS_;
          tableElement.id = tableId;
          tableElement.border = 1;
          tableContainer.appendChild(tableElement);
          tableElement.innerHTML = '<tr><th>Time</th>' +
            '<th class="update-log-header-event">Event</th></tr>';
        }
        return tableElement;
      }
    };

    return PeerConnectionUpdateTable;
  })();

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.


  /**
   * Provides the UI to start and stop RTP recording, forwards the start/stop
   * commands to Chrome, and updates the UI based on dump updates.
   *
   * @param {Element} containerElement The parent element of the dump creation UI.
   */
  var DumpCreator = (function() {
    /**
     * @param {Element} containerElement The parent element of the dump creation
     *     UI.
     * @constructor
     */
    function DumpCreator(containerElement) {
      /**
       * True if the RTP packets are being recorded.
       * @type {bool}
       * @private
       */
      this.recording_ = false;

      /**
       * @type {!Object.<string>}
       * @private
       * @const
       */
      this.StatusStrings_ = {
          NOT_STARTED: 'not started.',
          RECORDING: 'recording...',
        },

        /**
         * The status of dump creation.
         * @type {string}
         * @private
         */
        this.status_ = this.StatusStrings_.NOT_STARTED;

      /**
       * The root element of the dump creation UI.
       * @type {Element}
       * @private
       */
      this.root_ = document.createElement('details');

      this.root_.className = 'peer-connection-dump-root';
      containerElement.appendChild(this.root_);
      var summary = document.createElement('summary');
      this.root_.appendChild(summary);
      summary.textContent = 'Create Dump';
      var content = document.createElement('pre');
      this.root_.appendChild(content);
      content.innerHTML = '<button></button> Status: <span></span>';
      content.getElementsByTagName('button')[0].addEventListener(
        'click', this.onToggled_.bind(this));

      this.updateDisplay_();
    }

    DumpCreator.prototype = {
      /**
       * Handles the event of toggling the dump recording state.
       *
       * @private
       */
      onToggled_: function() {
        if (this.recording_) {
          this.recording_ = false;
          this.status_ = this.StatusStrings_.NOT_STARTED;
          chrome.send('stopRtpRecording');
        } else {
          this.recording_ = true;
          this.status_ = this.StatusStrings_.RECORDING;
          chrome.send('startRtpRecording');
        }
        this.updateDisplay_();
      },

      /**
       * Updates the UI based on the recording status.
       *
       * @private
       */
      updateDisplay_: function() {
        if (this.recording_) {
          this.root_.getElementsByTagName('button')[0].textContent =
            'Stop Recording RTP Packets';
        } else {
          this.root_.getElementsByTagName('button')[0].textContent =
            'Start Recording RTP Packets';
        }

        this.root_.getElementsByTagName('span')[0].textContent = this.status_;
      },

      /**
       * Set the status to the content of the update.
       * @param {!Object} update
       */
      onUpdate: function(update) {
        if (this.recording_) {
          this.status_ = JSON.stringify(update);
          this.updateDisplay_();
        }
      },
    };
    return DumpCreator;
  })();

  var peerConnectionsListElem = null;
  var dumpCreator = null;
  var ssrcInfoManager = new SsrcInfoManager();
  var peerConnectionUpdateTable = new PeerConnectionUpdateTable();
  var statsTable = new StatsTable(ssrcInfoManager);

  var STATS_GRAPH_CONTAINER_HEADING_CLASS = 'stats-graph-container-heading';

  // Specifies which stats should be drawn on the 'bweCompound' graph and how.
  var bweCompoundGraphConfig = {
    googAvailableSendBandwidth: {
      color: 'red'
    },
    googTargetEncBitrateCorrected: {
      color: 'purple'
    },
    googActualEncBitrate: {
      color: 'orange'
    },
    googRetransmitBitrate: {
      color: 'blue'
    },
    googTransmitBitrate: {
      color: 'green'
    },
  };

  // Converts the last entry of |srcDataSeries| from the total amount to the
  // amount per second.
  var totalToPerSecond = function(srcDataSeries) {
    var length = srcDataSeries.dataPoints_.length;
    if (length >= 2) {
      var lastDataPoint = srcDataSeries.dataPoints_[length - 1];
      var secondLastDataPoint = srcDataSeries.dataPoints_[length - 2];
      return Math.round((lastDataPoint.value - secondLastDataPoint.value) * 1000 /
        (lastDataPoint.time - secondLastDataPoint.time));
    }

    return 0;
  };

  // Converts the value of total bytes to bits per second.
  var totalBytesToBitsPerSecond = function(srcDataSeries) {
    return totalToPerSecond(srcDataSeries) * 8;
  };

  // Converts the value of total bytes to kilo bits per second.
  var totalKiloBytesToBitsPerSecond = function(srcDataSeries) {
    return totalBytesToBitsPerSecond(srcDataSeries) / 1000;
  };

  var packetsLostPercentage = function(srcDataSeries, peerConnectionElement, reportType, reportId) {
    var packetsLost = self.getLastValue(peerConnectionElement, reportType, reportId, "packetsLost");
    var packetsReceived = self.getLastValue(peerConnectionElement, reportType, reportId, "packetsReceived");
    if (packetsLost != null && packetsReceived != null) {
      return Math.round((packetsLost * 100 / (packetsReceived + packetsLost)) * 100) / 100;
    } else {
      return null;
    }

  };

  // Converts the value of total bytes to bits per second.
  self.getLastValue = function getLastValue(peerConnectionElement, reportType, reportId, label) {
    return getLastValueAt(peerConnectionElement, reportType, reportId, label, 1);
  }

  function getLastValueAt(peerConnectionElement, reportType, reportId, label, index) {
    var srcDataSeries = getDataSeries(peerConnectionElement.id, reportType, reportId, label);
    if (srcDataSeries) {
      return srcDataSeries.dataPoints_[srcDataSeries.dataPoints_.length - index].value;
    }
    return null;
  }

  self.getAvgValue = function getAvgValue(peerConnectionElement, reportType, reportId, label) {
    var srcDataSeries = getDataSeries(peerConnectionElement.id, reportType, reportId, label);
    return srcDataSeries ? srcDataSeries.getAvg() : null;
  }

  function getDataSeries(peerConnectionId, reportType, reportId, label) {
    var dataSeriesId = self.dataSeriesId(peerConnectionId, reportType, reportId, label);
    return dataSeries[dataSeriesId];
  }

  function getDataSeriesByLabel(peerConnectionId, type, label) {
    var keys = Object.keys(dataSeries);
    var results = [];
    var regex = new RegExp(peerConnectionId + ".*" + type + ".*" + label);
    for (i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (regex.test(key)) {
        var obj = {};
        results.push(dataSeries[key]);
      }
    }
    return results;
  }

  function getValueBefore(peerConnectionElement, reportType, reportId, label, timestamp) {
    var dataSeriesId = self.dataSeriesId(peerConnectionElement.id, reportType, reportId, label);
    var srcDataSeries = dataSeries[dataSeriesId];
    if (srcDataSeries) {
      for (i = srcDataSeries.dataPoints_.length - 1; i >= 0; i--) {
        if (srcDataSeries.dataPoints_[i].time < timestamp) {
          return srcDataSeries.dataPoints_[i].value;
        }
      }
      return srcDataSeries.dataPoints_[0].value;
    }
    return null;
  }


  self.dataSeriesId = function dataSeriesId(peerConnectionId, reportType, reportId, label) {
    return peerConnectionId + '-' + reportType + '-' + reportId + '-' + label;
  }

  self.graphViewId = function graphViewId(peerConnectionElement, reportType, reportId, graphType) {
    return peerConnectionElement.id + '-' + reportType + '-' + reportId + '-' + graphType;
  }

  self.matchesType = function matchesType(label, type, statsData) {
    if (type == "video" && isVideoStats(statsData)) {
      return true;
    } else if (type == "audio" && isAudioStats(statsData)) {
      if (label == "googJitterReceived" && !containsLabel(statsData, "audioOutputLevel")) {
        return false;
      }
      return true;
    }
    return false;
  }

  function isVideoStats(statsData) {
    return containsLabel(statsData, "googFrameHeightSent") || containsLabel(statsData, "googFrameHeightReceived");
  }

  function isAudioStats(statsData) {
    return containsLabel(statsData, "audioInputLevel") || containsLabel(statsData, "audioOutputLevel");
  }

  function getStatsDataType(label, statsData) {
    if (isVideoStats(statsData)) {
      return "video";
    } else if (isAudioStats(statsData)) {
      if (label == "googJitterReceived" && !containsLabel(statsData, "audioOutputLevel")) {
        return null;
      }
      return "audio";
    }
    return null;
  }

  function containsLabel(statsData, label) {
    for (var i = 0; i < statsData.length - 1; i = i + 2) {
      if (statsData[i] == label) {
        return true;
      }
    }
    return false;
  }

  // Specifies which stats should be converted before drawn and how.
  // |convertedName| is the name of the converted value, |convertFunction|
  // is the function used to calculate the new converted value based on the
  // original dataSeries.
  var dataConversionConfig = {
    packetsSent: {
      convertedName: 'packetsSentPerSecond',
      convertFunction: totalToPerSecond,
    },
    bytesSent: {
      convertedName: 'kiloBitsSentPerSecond',
      convertFunction: totalKiloBytesToBitsPerSecond,
    },
    packetsReceived: {
      convertedName: 'packetsReceivedPerSecond',
      convertFunction: totalToPerSecond,
    },
    bytesReceived: {
      convertedName: 'kiloBitsReceivedPerSecond',
      convertFunction: totalKiloBytesToBitsPerSecond,
    },
    packetsLost: {
      convertedName: 'packetsLostPer',
      convertFunction: packetsLostPercentage,
    },
    // This is due to a bug of wrong units reported for googTargetEncBitrate.
    // TODO (jiayl): remove this when the unit bug is fixed.
    googTargetEncBitrate: {
      convertedName: 'googTargetEncBitrateCorrected',
      convertFunction: function(srcDataSeries) {
        var length = srcDataSeries.dataPoints_.length;
        var lastDataPoint = srcDataSeries.dataPoints_[length - 1];
        if (lastDataPoint.value < 5000)
          return lastDataPoint.value * 1000;
        return lastDataPoint.value;
      }
    }
  };

  var graphViews = {};
  var dataSeries = {};

  function updateGraph(peerConnectionElement, reportType, reportId, singleReport, label) {
    var graphType = bweCompoundGraphConfig[label] ? 'bweCompound' : label;
    var graphViewId = self.graphViewId(peerConnectionElement, reportType, reportId, graphType);

    if (!graphViews[graphViewId]) {
      var statsType = getStatsDataType(label, singleReport.values);
      graphViews[graphViewId] = createStatsGraphView(peerConnectionElement,
        reportType, reportId,
        graphType, statsType);
      var date = new Date(singleReport.timestamp);
      graphViews[graphViewId].setDateRange(date, date);
    }
    // Adds the new dataSeries to the graphView. We have to do it here to cover
    // both the simple and compound graph cases.
    var dataSeriesId = self.dataSeriesId(peerConnectionElement.id, reportType, reportId, label);
    if (!graphViews[graphViewId].hasDataSeries(dataSeries[dataSeriesId]))
      graphViews[graphViewId].addDataSeries(dataSeries[dataSeriesId]);
    graphViews[graphViewId].updateEndDate();

  }

  // Adds the stats report |singleReport| to the timeline graph for the given
  // |peerConnectionElement| and |reportName|.
  function drawSingleReport(
    peerConnectionElement, reportType, reportId, singleReport) {
    if (!singleReport || !singleReport.values)
      return;

    for (var i = 0; i < singleReport.values.length - 1; i = i + 2) {
      var rawLabel = singleReport.values[i];
      var rawValue = parseInt(singleReport.values[i + 1]);
      if (isNaN(rawValue))
        continue;

      var rawDataSeriesId = self.dataSeriesId(peerConnectionElement.id, reportType, reportId, rawLabel);

      var finalDataSeriesId = rawDataSeriesId;
      var finalLabel = rawLabel;
      var finalValue = rawValue;
      // We need to convert the value if dataConversionConfig[rawLabel] exists.
      if (dataConversionConfig[rawLabel]) {
        // Updates the original dataSeries before the conversion.
        addDataSeriesPoint(rawDataSeriesId, singleReport.timestamp,
          rawLabel, rawValue);

        // Convert to another value to draw on graph, using the original
        // dataSeries as input.
        finalValue = dataConversionConfig[rawLabel].convertFunction(
          dataSeries[rawDataSeriesId], peerConnectionElement, reportType, reportId);
        finalLabel = dataConversionConfig[rawLabel].convertedName;
        finalDataSeriesId = self.dataSeriesId(peerConnectionElement.id, reportType, reportId, finalLabel);
      }

      // Updates the final dataSeries to draw.
      addDataSeriesPoint(
        finalDataSeriesId, singleReport.timestamp, finalLabel, finalValue);

      // Updates the graph.
      updateGraph(peerConnectionElement, reportType, reportId, singleReport, rawLabel);
      if (finalLabel != rawLabel) {
        updateGraph(peerConnectionElement, reportType, reportId, singleReport, finalLabel)
      }
    }
  }

  // Makes sure the TimelineDataSeries with id |dataSeriesId| is created,
  // and adds the new data point to it.
  function addDataSeriesPoint(dataSeriesId, time, label, value) {
    if (!dataSeries[dataSeriesId]) {
      dataSeries[dataSeriesId] = new TimelineDataSeries();
      if (bweCompoundGraphConfig[label]) {
        dataSeries[dataSeriesId].setColor(
          bweCompoundGraphConfig[label].color);
      }
    }
    // Restrain packetsLost to 0 as first value might be -1
    if (label == "packetsLost" && value < 0) {
      value = 0;
    }
    dataSeries[dataSeriesId].addPoint(time, value);
  }

  // Ensures a div container to hold all stats graphs for one track is created as
  // a child of |peerConnectionElement|.
  function ensureStatsGraphTopContainer(
    peerConnectionElement, reportType, reportId) {
    var containerId = peerConnectionElement.id + '-' +
      reportType + '-' + reportId + '-graph-container';
    var container = $('[id="' + containerId + '"]')[0];
    if (!container) {
      container = document.createElement('div');
      container.id = containerId;
      container.className = 'stats-graph-container';

      peerConnectionElement.appendChild(container);
    }
    return container;
  }

  // Creates the container elements holding a timeline graph
  // and the TimelineGraphView object.
  function createStatsGraphView(
    peerConnectionElement, reportType, reportId, statsName, statsType) {
    var topContainer = ensureStatsGraphTopContainer(peerConnectionElement,
      reportType, reportId);

    var graphViewId = peerConnectionElement.id + '-' +
      reportType + '-' + reportId + '-' + statsName;
    var divId = graphViewId + '-div';
    var canvasId = graphViewId + '-canvas';
    var container = document.createElement("div");
    container.className = 'stats-graph-sub-container ' + statsName + '-' + statsType;

    topContainer.appendChild(container);
    container.innerHTML = '<div>' + statsName + '</div>' +
      '<div id=' + divId + '><canvas id=' + canvasId + '></canvas></div>';
    if (statsName == 'bweCompound') {
      container.insertBefore(
        createBweCompoundLegend(
          peerConnectionElement, reportType + '-' + reportId),
        $('[id="' + divId + '"]')[0]);
    }
    return new TimelineGraphView(divId, canvasId);
  }

  // Creates the legend section for the bweCompound graph.
  // Returns the legend element.
  function createBweCompoundLegend(peerConnectionElement, reportName) {
    var legend = document.createElement('div');
    for (var prop in bweCompoundGraphConfig) {
      var div = document.createElement('div');
      legend.appendChild(div);
      div.innerHTML = '<input type=checkbox checked></input>' + prop;
      div.style.color = bweCompoundGraphConfig[prop].color;
      div.dataSeriesId = peerConnectionElement.id + '-' + reportName + '-' + prop;
      div.graphViewId =
        peerConnectionElement.id + '-' + reportName + '-bweCompound';
      div.firstChild.addEventListener('click', function(event) {
        var target = dataSeries[event.target.parentNode.dataSeriesId];
        target.show(event.target.checked);
        graphViews[event.target.parentNode.graphViewId].repaint();
      });
    }
    return legend;
  }

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.

  // function initialize() {
  //   //    peerConnectionsListElem = $('#'+'peer-connections-list');
  //   //    dumpCreator = new DumpCreator(peerConnectionsListElem);
  //   //chrome.send('getAllUpdates');

  //   // Requests stats from all peer connections every second.
  //   //    window.setInterval(function() {
  //   //        if (peerConnectionsListElem.getElementsByTagName('li').length > 0)
  //   //            chrome.send('getAllStats');
  //   //    }, 1000);
  // }
  // document.addEventListener('DOMContentLoaded', initialize);


  /**
   * A helper function for getting a peer connection element id.
   *
   * @param {!Object.<string, number>} data The object containing the pid and lid
   *     of the peer connection.
   * @return {string} The peer connection element id.
   */
  function getPeerConnectionId(data) {
    return data.pid + '-' + data.lid;
  }


  /**
   * Extracts ssrc info from a setLocal/setRemoteDescription update.
   *
   * @param {!PeerConnectionUpdateEntry} data The peer connection update data.
   */
  function extractSsrcInfo(data) {
    if (data.type == 'setLocalDescription' ||
      data.type == 'setRemoteDescription') {
      ssrcInfoManager.addSsrcStreamInfo(data.value);
    }
  }


  /**
   * Browser message handlers.
   */


  /**
   * Removes all information about a peer connection.
   *
   * @param {!Object.<string, number>} data The object containing the pid and lid
   *     of a peer connection.
   */
  function removePeerConnection(data) {
    var element = $('[id="' + getPeerConnectionId(data) + '"]')[0];
    if (element)
      peerConnectionsListElem.removeChild(element);
  }


  /**
   * Adds a peer connection.
   *
   * @param {!Object} data The object containing the pid, lid, url, servers, and
   *     constraints of a peer connection.
   */
  function addPeerConnection(data) {
    var peerConnectionElement = $('[id="' + getPeerConnectionId(data) + '"]')[0];
    if (!peerConnectionElement) {
      peerConnectionElement = document.createElement('li');
      peerConnectionsListElem.appendChild(peerConnectionElement);
      peerConnectionElement.id = getPeerConnectionId(data);
    }
    peerConnectionElement.innerHTML =
      '<h3>PeerConnection ' + peerConnectionElement.id + '</h3>' +
      '<div>' + data.url + ' ' + data.servers + ' ' + data.constraints +
      '</div>';

    // Clicking the heading can expand or collapse the peer connection item.
    peerConnectionElement.firstChild.title = 'Click to collapse or expand';
    peerConnectionElement.firstChild.addEventListener('click', function(e) {
      if (e.target.parentElement.className == '')
        e.target.parentElement.className = 'peer-connection-hidden';
      else
        e.target.parentElement.className = '';
    });
    return peerConnectionElement;
  }


  /**
   * Adds a peer connection update.
   *
   * @param {!PeerConnectionUpdateEntry} data The peer connection update data.
   */
  function updatePeerConnection(data) {
    var peerConnectionElement = $('[id="' + getPeerConnectionId(data) + '"]')[0];
    peerConnectionUpdateTable.addPeerConnectionUpdate(
      peerConnectionElement, data);
    extractSsrcInfo(data);
  }


  /**
   * Adds the information of all peer connections created so far.
   *
   * @param {Array.<!Object>} data An array of the information of all peer
   *     connections. Each array item contains pid, lid, url, servers,
   *     constraints, and an array of updates as the log.
   */
  function updateAllPeerConnections(data) {
    for (var i = 0; i < data.length; ++i) {
      var peerConnection = addPeerConnection(data[i]);

      var log = data[i].log;
      for (var j = 0; j < log.length; ++j) {
        peerConnectionUpdateTable.addPeerConnectionUpdate(
          peerConnection, log[j]);
        extractSsrcInfo(log[j]);
      }
    }
  }


  /**
   * Handles the report of stats.
   *
   * @param {!Object} data The object containing pid, lid, and reports, where
   *     reports is an array of stats reports. Each report contains id, type,
   *     and stats, where stats is the object containing timestamp and values,
   *     which is an array of strings, whose even index entry is the name of the
   *     stat, and the odd index entry is the value.
   */
  self.addStats = function addStats(data) {
    var peerConnectionElements = getPeerConnectionElement(data);
    if (!peerConnectionElements || !peerConnectionElements.length) {
      return;
    }

    //    console.log("addStats : "+ExSIP.Utils.toString(data));
    for (var j = 0; j < peerConnectionElements.length; j++) {
      var peerConnectionElement = peerConnectionElements[j];
      for (var i = 0; i < data.reports.length; ++i) {
        var report = data.reports[i];
        drawSingleReport(peerConnectionElement, report.type, report.id, report.stats);
        statsTable.addStatsReport(peerConnectionElement, report.type, report.id, report);

        if (isVideoStats(report.stats.values)) {
          var oneMinAgo = new Date(new Date().getTime() - 1000 * 60);
          var videoPacketsLost = self.getLastValue(peerConnectionElement, report.type, report.id, "packetsLost");
          var packetsSent = self.getLastValue(peerConnectionElement, report.type, report.id, "packetsReceived");
          if (videoPacketsLost != null && packetsSent != null) {
            var videoPacketsLostOneMinAgo = getValueBefore(peerConnectionElement, report.type, report.id, "packetsLost", oneMinAgo);
            var packetsSentOneMinAgo = getValueBefore(peerConnectionElement, report.type, report.id, "packetsReceived", oneMinAgo);
            var quality = ((videoPacketsLost - videoPacketsLostOneMinAgo) / (packetsSent - packetsSentOneMinAgo)) * 100
            if (quality < 10) {
              $("#quality1").fadeIn(10);
              $("#quality2, #quality3, #quality4").fadeOut(10);
            } else if (quality > 10 && quality < 20) {
              $("#quality2").fadeIn(10);
              $("#quality1, #quality3, #quality4").fadeOut(10);
            } else if (quality > 20 && quality < 100) {
              $("#quality3").fadeIn(10);
              $("#quality1, #quality2, #quality4").fadeOut(10);
            } else if (quality > 100 && quality < 1000) {
              $("#quality4").fadeIn(10);
              $("#quality1, #quality2, #quality3").fadeOut(10);
            }
          }
        }
      }
    }


  }

  function getPeerConnectionElement(data) {
    return $('[id="' + getPeerConnectionId(data) + '"]');
  }

  /**
   * Delegates to dumpCreator to update the recording status.
   * @param {!Object.<string>} update Key-value pairs describing the status of the
   *     RTP recording.
   */
  function updateDumpStatus(update) {
    dumpCreator.onUpdate(update);
  }

  return self;
}
},{}],637:[function(require,module,exports){
module.exports = {"stats":".bdsft-webrtc .stats{position:absolute;top:10px;width:auto;top:auto;bottom:40px;right:0;left:auto;background-color:#292929;border-radius:0;border:1px solid #3c3c3c;box-shadow:none;color:#999;z-index:200;padding:5px}.bdsft-webrtc .stats .table{width:auto;border-spacing:5px}.bdsft-webrtc .stats .statsVideo{position:absolute;white-space:pre-wrap;color:#0082ff;left:10px;font-family:arial;font-size:18px;text-decoration:none}.bdsft-webrtc .stats .statsAudio{position:absolute;white-space:pre-wrap;color:#0082ff;left:260px;float:left;font-family:arial;font-size:18px;text-decoration:none}.bdsft-webrtc .stats a{color:#2ba6cb}.bdsft-webrtc .stats .spacer{height:15px}.bdsft-webrtc .stats .statsDelay{display:none}.bdsft-webrtc .stats .videoKiloBitsSentPerSecondRow,.bdsft-webrtc .stats .audioKiloBitsSentPerSecondRow,.bdsft-webrtc .stats .videoKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats .audioKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats .videoPacketsLostRow,.bdsft-webrtc .stats .videoPacketsLostPerRow,.bdsft-webrtc .stats .audioPacketsLostRow,.bdsft-webrtc .stats .audioPacketsLostPerRow,.bdsft-webrtc .stats .videoGoogFrameRateSentRow,.bdsft-webrtc .stats .videoGoogFrameRateReceivedRow,.bdsft-webrtc .stats .audioAudioInputLevelRow,.bdsft-webrtc .stats .audioAudioOutputLevelRow,.bdsft-webrtc .stats .videoGoogFrameWidthReceivedRow,.bdsft-webrtc .stats .videoGoogFrameHeightReceivedRow,.bdsft-webrtc .stats .videoGoogFrameWidthSentRow,.bdsft-webrtc .stats .videoGoogFrameHeightSentRow,.bdsft-webrtc .stats .audioGoogRttRow,.bdsft-webrtc .stats .audioGoogJitterReceivedRow,.bdsft-webrtc .stats .videoStats,.bdsft-webrtc .stats .audioStats,.bdsft-webrtc .stats[class*=\"hasAudio\"] .noStats,.bdsft-webrtc .stats[class*=\"hasVideo\"] .noStats,.bdsft-webrtc .stats [class*=\"avg\"]{display:none}.bdsft-webrtc .stats.hasVideoKiloBitsSentPerSecond .videoKiloBitsSentPerSecondRow,.bdsft-webrtc .stats.hasAudioKiloBitsSentPerSecond .audioKiloBitsSentPerSecondRow,.bdsft-webrtc .stats.hasVideoKiloBitsReceivedPerSecond .videoKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats.hasAudioKiloBitsReceivedPerSecond .audioKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats.hasVideoPacketsLost .videoPacketsLostRow,.bdsft-webrtc .stats.hasVideoPacketsLostPer .videoPacketsLostPerRow,.bdsft-webrtc .stats.hasVideoPacketsLostPer .videoPacketsLostRow,.bdsft-webrtc .stats.hasAudioPacketsLost .audioPacketsLostRow,.bdsft-webrtc .stats.hasAudioPacketsLostPer .audioPacketsLostPerRow,.bdsft-webrtc .stats.hasAudioPacketsLostPer .audioPacketsLostRow,.bdsft-webrtc .stats.hasVideoGoogFrameRateSent .videoGoogFrameRateSentRow,.bdsft-webrtc .stats.hasVideoGoogFrameRateReceived .videoGoogFrameRateReceivedRow,.bdsft-webrtc .stats.hasAudioAudioInputLevel .audioAudioInputLevelRow,.bdsft-webrtc .stats.hasAudioAudioOutputLevel .audioAudioOutputLevelRow,.bdsft-webrtc .stats.hasVideoGoogFrameWidthReceived .videoGoogFrameWidthReceivedRow,.bdsft-webrtc .stats.hasVideoGoogFrameHeightReceived .videoGoogFrameHeightReceivedRow,.bdsft-webrtc .stats.hasVideoGoogFrameWidthSent .videoGoogFrameWidthSentRow,.bdsft-webrtc .stats.hasVideoGoogFrameHeightSent .videoGoogFrameHeightSentRow,.bdsft-webrtc .stats.hasAudioGoogRtt .audioGoogRttRow,.bdsft-webrtc .stats.hasAudioGoogJitterReceived .audioGoogJitterReceivedRow,.bdsft-webrtc .stats.hasAvgVideoKiloBitsSentPerSecond .avgVideoKiloBitsSentPerSecondRow,.bdsft-webrtc .stats.hasAvgAudioKiloBitsSentPerSecond .avgAudioKiloBitsSentPerSecondRow,.bdsft-webrtc .stats.hasAvgVideoKiloBitsReceivedPerSecond .avgVideoKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats.hasAvgAudioKiloBitsReceivedPerSecond .avgAudioKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats.hasAvgVideoPacketsLost .avgVideoPacketsLostRow,.bdsft-webrtc .stats.hasAvgVideoPacketsLostPer .avgVideoPacketsLostPerRow,.bdsft-webrtc .stats.hasAvgVideoPacketsLostPer .avgVideoPacketsLostRow,.bdsft-webrtc .stats.hasAvgAudioPacketsLost .avgAudioPacketsLostRow,.bdsft-webrtc .stats.hasAvgAudioPacketsLostPer .avgAudioPacketsLostPerRow,.bdsft-webrtc .stats.hasAvgAudioPacketsLostPer .avgAudioPacketsLostRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameRateSent .avgVideoGoogFrameRateSentRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameRateReceived .avgVideoGoogFrameRateReceivedRow,.bdsft-webrtc .stats.hasAvgAudioAudioInputLevel .avgAudioAudioInputLevelRow,.bdsft-webrtc .stats.hasAvgAudioAudioOutputLevel .avgAudioAudioOutputLevelRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameWidthReceived .avgVideoGoogFrameWidthReceivedRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameHeightReceived .avgVideoGoogFrameHeightReceivedRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameWidthSent .avgVideoGoogFrameWidthSentRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameHeightSent .avgVideoGoogFrameHeightSentRow,.bdsft-webrtc .stats.hasAvgAudioGoogRtt .avgAudioGoogRttRow,.bdsft-webrtc .stats.hasAvgAudioGoogJitterReceived .avgAudioGoogJitterReceivedRow{display:block}.bdsft-webrtc .stats[class*=\"hasAudio\"] .audioStats,.bdsft-webrtc .stats[class*=\"hasVideo\"] .videoStats{display:table-cell;width:220px}.bdsft-webrtc .stats.videoKiloBitsSentPerSecond .kiloBitsSentPerSecond-video,.bdsft-webrtc .stats.audioKiloBitsSentPerSecond .kiloBitsSentPerSecond-audio,.bdsft-webrtc .stats.videoKiloBitsReceivedPerSecond .kiloBitsReceivedPerSecond-video,.bdsft-webrtc .stats.audioKiloBitsReceivedPerSecond .kiloBitsReceivedPerSecond-audio,.bdsft-webrtc .stats.videoPacketsLost [id*=\"send-graph-container\"] .packetsLost-video,.bdsft-webrtc .stats.videoPacketsLostPer [id*=\"send-graph-container\"] .packetsLostPer-video,.bdsft-webrtc .stats.audioPacketsLost [id*=\"send-graph-container\"] .packetsLost-audio,.bdsft-webrtc .stats.audioPacketsLostPer [id*=\"send-graph-container\"] .packetsLostPer-audio,.bdsft-webrtc .stats.videoGoogFrameRateSent .googFrameRateSent-video,.bdsft-webrtc .stats.videoGoogFrameRateReceived .googFrameRateReceived-video,.bdsft-webrtc .stats.audioAudioOutputLevel .audioOutputLevel-audio,.bdsft-webrtc .stats.audioAudioInputLevel .audioInputLevel-audio,.bdsft-webrtc .stats.videoGoogFrameWidthReceived .googFrameWidthReceived-video,.bdsft-webrtc .stats.videoGoogFrameHeightReceived .googFrameHeightReceived-video,.bdsft-webrtc .stats.videoGoogFrameWidthSent .googFrameWidthSent-video,.bdsft-webrtc .stats.videoGoogFrameHeightSent .googFrameHeightSent-video,.bdsft-webrtc .stats.audioGoogRtt .googRtt-audio,.bdsft-webrtc .stats.audioGoogJitterReceived .googJitterReceived-audio{display:block}.bdsft-webrtc .stats.audioOnly{top:45px;bottom:auto}.bdsft-webrtc .stats-table-container,.bdsft-webrtc .stats-graph-sub-container{display:none}.bdsft-webrtc .statsVar{color:<%= statsColor %>}.bdsft-webrtc .stats-graph-sub-container canvas{width:100%}.bdsft-webrtc .stats.enableCallStats.stats-shown{transition:all 1s linear;opacity:1;z-index:100}.bdsft-webrtc .stats.enableCallStats:not(.stats-shown){transition:all 1s linear;opacity:0;z-index:-1}"}
},{}],638:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // stats.jade compiled template
    templatizer["stats"] = function tmpl_stats() {
        return '<div class="bdsft-webrtc"><div class="stats fadeable popup classes"><div class="statsContainer"></div><div class="noStats">There are no Stats yet</div><div class="table fixed"><div class="cell videoStats"> \nVideo Stats<div class="videoKiloBitsSentPerSecondRow">Bitrate out: <a href="javascript:;" data-type="video" data-var="kiloBitsSentPerSecond" class="statsVar videoKiloBitsSentPerSecond"></a> kb/s<div class="avgVideoKiloBitsSentPerSecond"></div></div><div class="videoKiloBitsReceivedPerSecondRow">Bitrate in: <a href="javascript:;" data-type="video" data-var="kiloBitsReceivedPerSecond" class="statsVar videoKiloBitsReceivedPerSecond"></a> kb/s<div class="avgVideoKiloBitsReceivedPerSecond"></div></div><div class="videoPacketsLostRow">Lost: <a href="javascript:;" data-type="video" data-var="packetsLost" class="statsVar videoPacketsLost"></a> packets (<a href="javascript:;" data-type="video" data-var="packetsLostPer" class="statsVar videoPacketsLostPer"></a> %)<div class="avgVideoPacketsLost"></div><div class="avgVideoPacketsLostPer"></div></div><div class="videoGoogFrameRateSentRow">Frame rate out: <a href="javascript:;" data-type="video" data-var="googFrameRateSent" class="statsVar videoGoogFrameRateSent"></a> in: <a href="javascript:;" data-type="video" data-var="googFrameRateReceived" class="statsVar videoGoogFrameRateReceived"></a><div class="avgVideoGoogFrameRateSent"></div><div class="avgVideoGoogFrameRateReceived"></div></div><div class="spacer"></div><div class="videoGoogFrameWidthReceivedRow">Resolution</div><div class="videoGoogFrameWidthReceivedRow">In: <span data-type="video" data-var="googFrameWidthReceived" class="statsVar videoGoogFrameWidthReceived"></span> x <span data-type="video" data-var="googFrameHeightReceived" class="statsVar videoGoogFrameHeightReceived"></span> Out: <span data-type="video" data-var="googFrameWidthSent" class="statsVar videoGoogFrameWidthSent"></span> x <span data-type="video" data-var="googFrameHeightSent" class="statsVar videoGoogFrameHeightSent"></span><div class="avgVideoGoogFrameWidthReceived"></div><div class="avgVideoGoogFrameHeightReceived"></div><div class="avgVideoGoogFrameWidthSent"></div><div class="avgVideoGoogFrameHeightSent"></div></div></div><div class="cell audioStats"> \nAudio Stats<div class="audioKiloBitsSentPerSecondRow">Bitrate out: <a href="javascript:;" data-type="audio" data-var="kiloBitsSentPerSecond" class="statsVar audioKiloBitsSentPerSecond"></a> kb/s<div class="avgAudioKiloBitsSentPerSecond"></div></div><div class="audioKiloBitsReceivedPerSecondRow">Bitrate in: <a href="javascript:;" data-type="audio" data-var="kiloBitsReceivedPerSecond" class="statsVar audioKiloBitsReceivedPerSecond"></a> kb/s<div class="avgAudioKiloBitsReceivedPerSecond"></div></div><div class="audioPacketsLostPerRow">Lost: <a href="javascript:;" data-type="audio" data-var="packetsLost" class="statsVar audioPacketsLost"></a> packets (<a href="javascript:;" data-type="audio" data-var="packetsLostPer" class="statsVar audioPacketsLostPer"></a> %)<div class="avgAudioPacketsLost"></div><div class="avgAudioPacketsLostPer"></div></div><div class="audioAudioInputLevelRow">Audio Level out: <a href="javascript:;" data-type="audio" data-var="audioInputLevel" class="statsVar audioAudioInputLevel"></a> in: <a href="javascript:;" data-type="audio" data-var="audioOutputLevel" class="statsVar audioAudioOutputLevel"></a><div class="avgAudioAudioInputLevel"></div><div class="avgAudioAudioOutputLevel"></div></div><div class="spacer"></div><div class="cell audioGoogJitterReceivedRow">Link</div><div class="audioGoogJitterReceivedRow"><span class="statsDelay">Delay: <a href="javascript:;" data-type="audio" data-var="googRtt" class="statsVar audioGoogRtt"></a></span> Jitter: <a href="javascript:;" data-type="audio" data-var="googJitterReceived" class="statsVar audioGoogJitterReceived"></a><div class="avgAudioGoogRtt"></div><div class="avgAudioGoogJitterReceived"></div></div></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],639:[function(require,module,exports){
var Utils = require('webrtc-core').utils;
var C = {};
module.exports = C;

C.keys = ['videoKiloBitsSentPerSecond', 'audioKiloBitsSentPerSecond',
    'videoKiloBitsReceivedPerSecond', 'audioKiloBitsReceivedPerSecond', 'videoPacketsLost', 'videoPacketsLostPer',
    'audioPacketsLost', 'audioPacketsLostPer', 'videoGoogFrameRateSent', 'videoGoogFrameRateReceived', 'audioAudioInputLevel',
    'audioAudioOutputLevel', 'videoGoogFrameWidthReceived', 'videoGoogFrameHeightReceived', 'videoGoogFrameWidthSent', 'videoGoogFrameHeightSent',
    'audioGoogRtt', 'audioGoogJitterReceived'];

C.keysAvg = C.keys.map(function(key){ return Utils.camelize('avg ' + key)});
C.hasKeys = C.keys.map(function(key){ return Utils.camelize('has ' + key)});
C.hasKeysAvg = C.keysAvg.map(function(key){ return Utils.camelize('has ' + key)});
C.STYLES = {
  statsColor: '#999999'
}
},{"webrtc-core":645}],640:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Stats, {
  config: require('../../js/config.js')
});

var Utils = require('webrtc-core').utils;
var constants = require('../constants');

function Stats(eventbus, debug, sipstack, urlconfig) {
  var self = {};

  self.statsMod = require('../../js/stats')(self);

  self.props = ['classes', 'visible', 'statsContainerId', 'statSelected'].concat(constants.keys).concat(constants.keysAvg)
  .concat(constants.hasKeys).concat(constants.hasKeysAvg);

  self.bindings = {
    'classes': {
      stats: ['visible', 'enableCallStats', 'statSelected'].concat(constants.hasKeys).concat(constants.hasKeysAvg),
      urlconfig: 'view'
    }
  }

  var intervalId = null;

  var isSupported = function(){
    return Utils.isChrome() && Utils.majorVersion() >= 25
  };

  self.init = function() {
    // disable call stats if not supported
    if(!isSupported()) {
      self.enableCallStats = false;
    } else {
      self.enableCallStats = urlconfig.enableCallStats || self.enableCallStats;
    }
  };

  self.select = function(stat) {
    self.statSelected = stat;
  };

  var getElement = function(type, name, isAvg) {
    return self[Utils.camelize((isAvg ? 'Avg ' : '') + type + ' ' + name)];
  };

  self.getReportById = function(reports, id) {
    for (var i = 0; i < reports.length; i++) {
      if (reports[i].id === id) {
        return reports[i];
      }
    }
    return null;
  };

  self.processStats = function() {
    if(!sipstack.activeSession) {
      stop();
      return;
    }

    var peerConnection = sipstack.activeSession.rtcMediaHandler.peerConnection;

    peerConnection.getStats(function(stats) {
      var results = stats.result();
      var reports = [];
      for (var i = 0; i < results.length; ++i) {
        var res = results[i];
        var report = self.getReportById(reports, res.id);
        if (!report) {
          report = {};
          report.type = res.type;
          report.id = res.id;
        }

        var names = res.names();
        var values = [];
        for (var j = 0; j < names.length; j++) {
          var name = names[j];
          if (!name) {
            continue;
          }
          var value = res.stat(name);
          values.push(name);
          values.push(value);
        }
        var valueObj = {};
        valueObj.timestamp = res.timestamp;
        valueObj.values = values;
        report.stats = valueObj;
        reports.push(report);
      }
      var data = {
        "lid": 1,
        "pid": sipstack.getSessionId(),
        "reports": reports
      };
      self.statsMod.addStats(data);
    });
  };

  self.getDataSerie = function(type, label, sessionId) {
    var dataSeries = getDataSeriesByLabel(sessionId || sipstack.getSessionId(), type, label);
    var result;
    for (var i = 0; i < dataSeries.length; i++) {
      var dataSerie = dataSeries[i];
      if (!result || dataSerie.getAvg() > result.getAvg()) {
        result = dataSerie;
      }
    }
    return result;
  };

  self.setAllAvg = function(stats) {
    for(var i = 0; i < constants.keysAvg.length; i++) {
      var key = constants.keysAvg[i];
      self[key] = stats[key];
    };
  };

  self.getAll = function() {
    return Utils.pick(self, constants.keys);
  };

  self.getAllAvg = function() {
    return Utils.pick(self, constants.keysAvg);
  };

  self.getStatValues = function(type, label, sessionId) {
    var dataSerie = this.getDataSerie(type, label, sessionId);
    return dataSerie ? dataSerie.dataPoints_.map(function(e) {
      return e.value;
    }) : null;
  };

  self.getStatAvg = function(type, label, sessionId) {
    var dataSerie = this.getDataSerie(type, label, sessionId);
    return dataSerie ? dataSerie.getAvg() : null;
  };

  self.getValue = function(type, name) {
    return getElement(type, name);
  };

  self.getAvg = function(type, name) {
    return Math.round(getElement(type, name, true) * 100) / 100.0;
  };

  self.onAddStats = function(peerConnectionElement, reportType, reportId, statsData) {
    self.props.forEach(function(prop) {
      var match = prop.match(/(audio|video)(.*)/);
      if (!match) {
        return;
      }
      var label = Utils.lowercaseFirstLetter(match[2]);
      var type = match[1];
      if (self.statsMod.matchesType(label, type, statsData)) {
        var value = self.statsMod.getLastValue(peerConnectionElement, reportType, reportId, label);
        if (value != null) {
          self[prop] = value;
          var avg = self.statsMod.getAvgValue(peerConnectionElement, reportType, reportId, label);
          self[Utils.camelize('avg '+ prop)] = Math.round(avg * 100) / 100.0;
        } else {}
      }
    });
  };

  var start = function() {
    if (!intervalId && self.enableCallStats && Utils.isChrome()) {
      intervalId = setInterval(function() {
        self.processStats();
      }, 1000);
    }
  };

  var stop = function() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
  };

  self.listeners = function(databinder) {
    databinder.onModelPropChange(constants.keys.concat(constants.keysAvg), function(value, name) {
      value = value+'';
      self[Utils.camelize('has '+name)] = value !== '' && value !== 'undefined' && value !== 'undefinedxundefined' && value !== 'NaN';
    });
    eventbus.on("ended", function(e) {
      stop();
    });
    eventbus.on("started", function(e) {
      self.statsContainerId = sipstack.getSessionId() + '-1';
      start();
    });
  };

  return self;
}
},{"../../js/config.js":635,"../../js/stats":636,"../constants":639,"webrtc-core":645}],641:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(StatsView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  constants: require('../constants')
});

var Utils = require('webrtc-core').utils;
var constants = require('../constants');

function StatsView(eventbus, stats) {
  var self = {};

  self.model = stats;
  
  self.bindings = {
    'statsContainerId': {
      stats: 'statsContainerId'
    }
  }

  self.elements = ['statsVar', 'statsContainer'].concat(constants.keys).concat(constants.keysAvg);

  self.updateStatsContainerId = function(value){
    self.statsContainer && self.statsContainer.attr('id', value);
  };

  self.listeners = function() {
    self.statsVar.click(function() {
      var selected = Utils.camelize(Utils.getElement(this).attr('data-type') + ' ' + Utils.getElement(this).attr('data-var'));
      stats.select(selected);
    });
    eventbus.on('started', function(){
      self.statsContainer && self.statsContainer.text('');
    });
  };

  return self;
}
},{"../../js/styles":637,"../../js/templates":638,"../constants":639,"webrtc-core":645}],642:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],643:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],644:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],645:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":644,"./bdsft":646,"./constants":649,"./cookieconfig":650,"./cookieprop":651,"./dateformat":654,"./debug":655,"./element":656,"./eventbus":657,"./factory":658,"./icon":659,"./loader":660,"./popup":661,"./prop":662,"./urlconfig":664,"./utils":665,"./visibleprop":666,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],646:[function(require,module,exports){
module.exports=require(24)
},{"./app":645,"./binding":647,"./classesbinding":648,"./databinder":653,"./stylesmanager":663,"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":690}],647:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":646,"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],648:[function(require,module,exports){
module.exports=require(26)
},{"./binding":647,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],649:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],650:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":646,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":690,"jquery.cookie":689}],651:[function(require,module,exports){
module.exports=require(29)
},{"./constants":649,"./prop":662,"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":690,"jquery.cookie":689}],652:[function(require,module,exports){
module.exports=require(30)
},{"./constants":649,"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":671}],653:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":674}],654:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],655:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":642,"./bdsft":646,"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":667,"stacktrace-js":692}],656:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],657:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":646,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":674}],658:[function(require,module,exports){
module.exports=require(36)
},{"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":690}],659:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],660:[function(require,module,exports){
module.exports=require(38)
},{"../":645,"./constants":649,"./factory":658,"./stylesmanager":663,"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":670}],661:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":690}],662:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":691}],663:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":643,"./constants":649,"./css":652,"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],664:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":642,"./bdsft":646,"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],665:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":644,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":690}],666:[function(require,module,exports){
module.exports=require(44)
},{"./constants":649,"./prop":662,"./utils":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],667:[function(require,module,exports){
module.exports=require(45)
},{"./debug":668,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],668:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":669}],669:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],670:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],671:[function(require,module,exports){
module.exports=require(49)
},{"./filters":672,"./utils":673,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],672:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],673:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],674:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":675,"es5-ext/object/valid-callable":684}],675:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":676,"es5-ext/object/is-callable":679,"es5-ext/object/normalize-options":683,"es5-ext/string/#/contains":686}],676:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":677,"./shim":678,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],677:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],678:[function(require,module,exports){
module.exports=require(56)
},{"../keys":680,"../valid-value":685,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],679:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],680:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":681,"./shim":682,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],681:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],682:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],683:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],684:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],685:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],686:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":687,"./shim":688,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],687:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],688:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],689:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":690}],690:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],691:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],692:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],693:[function(require,module,exports){
module.exports = {view: require('./lib/views/timer'), model: require('./lib/models/timer')};
},{"./lib/models/timer":698,"./lib/views/timer":699}],694:[function(require,module,exports){
module.exports = {
    enableCallTimer: true
};
},{}],695:[function(require,module,exports){
module.exports = {"timer":".bdsft-webrtc .timer{position:absolute;top:3px;left:0;width:100%;text-align:center;font-family:arial;font-size:16px;top:11px;color:#fff}.bdsft-webrtc .timer .text{text-align:center}.bdsft-webrtc .timer{color:<%= timerColor %>}.bdsft-webrtc .timer.audioOnly{position:relative;margin-right:10px}.bdsft-webrtc .timer.enableCallTimer.started{transition:all 1s linear;opacity:1;z-index:20}.bdsft-webrtc .timer:not(.started){transition:all 1s linear;opacity:0;z-index:-1}"}
},{}],696:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // timer.jade compiled template
    templatizer["timer"] = function tmpl_timer() {
        return '<div class="bdsft-webrtc"><div class="timer fadeable classes"><div class="text"></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],697:[function(require,module,exports){
var C = {
  STYLES: {
    timerColor: '#FFFFFF'
  }
};

module.exports = C;
},{}],698:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Timer, {
  config: require('../../js/config.js')
});

var Utils = require('webrtc-core').utils;

function Timer(eventbus, debug, urlconfig, sipstack) {
  var self = {};

  self.callTimer = null;
  self.startTime = null;

  self.props = ['text', 'classes'];

  self.bindings = {
    classes: {
        timer: 'enableCallTimer',
        sipstack: 'callState',
        urlconfig: 'view'
    },
    enableCallTimer: {
      urlconfig: 'enableCallTimer'
    }
  }

  self.init = function() {
    self.updateText();
  };

  self.listeners = function() {
    eventbus.on("started", function(e) {
      if (e.data && !e.data.isReconnect) {
        self.start();
      }
    });
    eventbus.on(["disconnected", "ended"], function(e) {
      self.stop();
    });
  };

  self.start = function() {
    if (self.callTimer) {
      debug.log('timer ' + self.callTimer + ' already running');
      return;
    }

    var timer = self.runningTimer();
    timer();
    self.callTimer = setInterval(timer, 1000);
    debug.debug("started timer interval");
  };

  self.stop = function() {
    // Don't stop if there are active sessions still
    if(sipstack.sessions.length) {
      return;
    }
    self.startTime = null;
    clearInterval(self.callTimer);
    debug.debug("cleared timer interval");
    self.callTimer = null;
    self.updateText();
  };

  self.getSeconds = function() {
    return Math.round((new Date().getTime() - (self.startTime || new Date().getTime())) / 1000);
  };

  self.updateText = function() {
    var secs = self.getSeconds();
    self.text = Utils.format(secs);
  };

  // Display the timer on the screen
  self.runningTimer = function() {
    self.startTime = new Date().getTime();
    return function() {
      var secs = self.getSeconds();
      if (urlconfig.maxCallLength && secs >= urlconfig.maxCallLength) {
        eventbus.endCall();
        return;
      }
      self.updateText();
    };
  }

  return self;
}
},{"../../js/config.js":694,"webrtc-core":703}],699:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(TimerView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  constants: require('../constants')
});

function TimerView(timer) {
  var self = {};

  self.model = timer;
  
  self.elements = ['text'];

  return self;
}
},{"../../js/styles":695,"../../js/templates":696,"../constants":697,"webrtc-core":703}],700:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],701:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],702:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],703:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":702,"./bdsft":704,"./constants":707,"./cookieconfig":708,"./cookieprop":709,"./dateformat":712,"./debug":713,"./element":714,"./eventbus":715,"./factory":716,"./icon":717,"./loader":718,"./popup":719,"./prop":720,"./urlconfig":722,"./utils":723,"./visibleprop":724,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],704:[function(require,module,exports){
module.exports=require(24)
},{"./app":703,"./binding":705,"./classesbinding":706,"./databinder":711,"./stylesmanager":721,"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":748}],705:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":704,"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],706:[function(require,module,exports){
module.exports=require(26)
},{"./binding":705,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],707:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],708:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":704,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":748,"jquery.cookie":747}],709:[function(require,module,exports){
module.exports=require(29)
},{"./constants":707,"./prop":720,"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":748,"jquery.cookie":747}],710:[function(require,module,exports){
module.exports=require(30)
},{"./constants":707,"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":729}],711:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":732}],712:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],713:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":700,"./bdsft":704,"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":725,"stacktrace-js":750}],714:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],715:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":704,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":732}],716:[function(require,module,exports){
module.exports=require(36)
},{"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":748}],717:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],718:[function(require,module,exports){
module.exports=require(38)
},{"../":703,"./constants":707,"./factory":716,"./stylesmanager":721,"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":728}],719:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":748}],720:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":749}],721:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":701,"./constants":707,"./css":710,"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],722:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":700,"./bdsft":704,"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],723:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":702,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":748}],724:[function(require,module,exports){
module.exports=require(44)
},{"./constants":707,"./prop":720,"./utils":723,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],725:[function(require,module,exports){
module.exports=require(45)
},{"./debug":726,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],726:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":727}],727:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],728:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],729:[function(require,module,exports){
module.exports=require(49)
},{"./filters":730,"./utils":731,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],730:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],731:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],732:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":733,"es5-ext/object/valid-callable":742}],733:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":734,"es5-ext/object/is-callable":737,"es5-ext/object/normalize-options":741,"es5-ext/string/#/contains":744}],734:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":735,"./shim":736,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],735:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],736:[function(require,module,exports){
module.exports=require(56)
},{"../keys":738,"../valid-value":743,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],737:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],738:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":739,"./shim":740,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],739:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],740:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],741:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],742:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],743:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],744:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":745,"./shim":746,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],745:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],746:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],747:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":748}],748:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],749:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],750:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],751:[function(require,module,exports){
module.exports = {view: require('./lib/views/transfer'), model: require('./lib/models/transfer')};
},{"./lib/models/transfer":755,"./lib/views/transfer":756}],752:[function(require,module,exports){
module.exports = {
    enableTransfer: true
};
},{}],753:[function(require,module,exports){
module.exports = {"transfer":".bdsft-webrtc .transferPopup{color:#fff}.bdsft-webrtc .transferPopup .target{width:200px;line-height:30px;margin:5px;margin-left:0}.bdsft-webrtc .transferPopup .actions{padding:10px}.bdsft-webrtc .transferPopup .actions button{margin-right:10px}.bdsft-webrtc .transferPopup .reject{color:#f00}.bdsft-webrtc .transferPopup.enableTransfer.started.transfer-shown{transition:all 1s linear;opacity:1;z-index:100}.bdsft-webrtc .transferPopup.enableTransfer:not(.transfer-shown){transition:all 1s linear;opacity:0;z-index:-1}"}
},{}],754:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // transfer.jade compiled template
    templatizer["transfer"] = function tmpl_transfer() {
        return '<div class="bdsft-webrtc"><div class="transferPopup fadeable popup classes centered"><div class="title">Transfer</div><div><input type="text" placeholder="To Target" class="target"/></div><div class="actions"><button type="button" class="accept button">Transfer</button><button type="button" class="reject button">Cancel</button></div></div></div>';
    };

    // transfercontrol.jade compiled template
    templatizer["transfercontrol"] = function tmpl_transfercontrol() {
        return '<div class="bdsft-webrtc"><div class="cell cell-transfer"><div class="transfer icon fadeable"><a href="" title="Transfer" class="icon-transfer"></a></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],755:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Transfer, {
  config: require('../../js/config.js')
});

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function Transfer(sipstack, callcontrol, urlconfig) {
  var self = {};

  self.props = ['classes', 'target', 'visible'];

  self.bindings = {
    classes: {
        transfer: ['visible', 'enableTransfer'],
        sipstack: 'callState'
    },
    enableTransfer: {
      urlconfig: 'enableTransfer'
    }
  }

  self.transfer = function() {
    var target = self.target;
    target = callcontrol.validateDestination(target);
    if (target) {
      self.visible = false;
      sipstack.transfer(target, false);
    }
  };

  return self;
}
},{"../../js/config.js":752,"webrtc-core":253}],756:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(TransferView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function TransferView(sound, transfer) {
  var self = {};

  self.model = transfer;
  

  self.elements = ['accept', 'reject', 'target'];

  self.listeners = function(databinder) {
    databinder.onModelPropChange('visible', function(visible){
      visible && self.target.focus();
    });
    self.accept.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      transfer.transfer();
    });

    self.reject.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      transfer.visible = false;
    });
  };

  return self;
}
},{"../../js/styles":753,"../../js/templates":754,"webrtc-core":253}],757:[function(require,module,exports){
module.exports = {view: require('./lib/views/video'), model: require('./lib/models/video')};
},{"./lib/models/video":762,"./lib/views/video":763}],758:[function(require,module,exports){
module.exports = {
	enableSelfView: true,
    selfViewLocation: "bl",
    selfViewSize: "1x",
	displayResolution: "640x480"
}

},{}],759:[function(require,module,exports){
module.exports = {"videobg":"PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxOC4xLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMTY1LjkgNjEyIDQ2MC4zIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMTY1LjkgNjEyIDQ2MC4zIiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCgkgPGRlZnM+DQoJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMCUiIHkyPSIxMDAlIj4NCgkJCTxzdG9wIG9mZnNldD0iMCUiICAgc3R5bGU9InN0b3AtY29sb3I6IzAwMDAwMCIvPg0KCQkJPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjojNDk0OTQ5Ii8+DQoJCTwvbGluZWFyR3JhZGllbnQ+DQoJPC9kZWZzPg0KCTxyZWN0IHk9IjE2NS45IiBmaWxsPSJ1cmwoI1NWR0lEXzFfKSIgd2lkdGg9IjYxMiIgaGVpZ2h0PSI0NjAuMyIvPg0KCTxnPg0KCQk8Zz4NCgkJCTxwYXRoIGZpbGw9IiMyODI4MjgiIGQ9Ik00MzIuNywzMTkuMnYxNTMuNWMwLDMuOS0xLjgsNi44LTUuNCw4LjRjLTEuMywwLjctMi41LDEtMy40LDFjLTIuNywwLTQuOC0xLTYuNC0zbC01Ni45LTU2Ljl2MjMuOA0KCQkJCWMwLDExLjItNCwyMC44LTEyLjEsMjguN2MtOC4xLDcuOS0xNy44LDExLjgtMjksMTEuOGgtOTkuNWMtMTEuMiwwLTIwLjgtMy45LTI4LjctMTEuOGMtNy45LTcuOS0xMS44LTE3LjUtMTEuOC0yOC43VjM0Ng0KCQkJCWMwLTExLjIsMy45LTIwLjgsMTEuOC0yOC43YzcuOS03LjksMTcuNS0xMS44LDI4LjctMTEuOGg5OS41YzExLjIsMCwyMC44LDMuOSwyOSwxMS44YzguMSw3LjksMTIuMSwxNy41LDEyLjEsMjguN3YyMy44DQoJCQkJbDU2LjktNTYuOWMxLjYtMiwzLjgtMyw2LjQtM2MxLDAsMi4xLDAuMywzLjQsMUM0MzAuOCwzMTIuNSw0MzIuNywzMTUuMyw0MzIuNywzMTkuMnoiLz4NCgkJPC9nPg0KCTwvZz4NCjwvc3ZnPg0K"}
},{}],760:[function(require,module,exports){
module.exports = {"video":".bdsft-webrtc .video{position:relative;top:0;left:0;width:100%;height:auto;box-shadow:0 0 1px rgba(0,0,0,0.05)}.bdsft-webrtc .video .remote{display:none;position:absolute;top:0;left:0;width:100%;height:100%;backface-visibility:hidden;box-shadow:0 0 10px #000}.bdsft-webrtc .video .localVideo{position:absolute;top:auto;left:0;bottom:0;right:auto;width:25%;height:25%;background-color:transparent}.bdsft-webrtc .video .localVideo video{border-radius:0;box-shadow:none;background:#292929;border:1px solid #3c3c3c;cursor:move;width:100%;height:100%;position:absolute}.bdsft-webrtc .video .localVideo .inner{margin:5px;position:absolute;top:0;bottom:0;right:0;left:0}.bdsft-webrtc .video._960x720 .content,.bdsft-webrtc .video._640x480 .content,.bdsft-webrtc .video._320x240 .content{padding-bottom:75%}.bdsft-webrtc .video._1920x1080 .content,.bdsft-webrtc .video._1280x720 .content,.bdsft-webrtc .video._640x360 .content,.bdsft-webrtc .video._320x180 .content,.bdsft-webrtc .video.hd .content{padding-bottom:56.25%}.bdsft-webrtc .video._960x720{width:960px}.bdsft-webrtc .video._640x360,.bdsft-webrtc .video._640x480{width:640px}.bdsft-webrtc .video._320x180,.bdsft-webrtc .video._320x240{width:320px}.bdsft-webrtc .video._1280x720,.bdsft-webrtc .video.hd{width:1280px}.bdsft-webrtc .video._1920x1080{width:1920px}.bdsft-webrtc .video.fullscreen-shown{padding-bottom:0;bottom:40px;position:absolute;height:auto!important;width:100%}.bdsft-webrtc .video.started .remote{display:inline;box-shadow:0 0 1px rgba(0,0,0,0.1)}.bdsft-webrtc .video.bl .localVideo{top:auto;bottom:0;left:0;right:auto}.bdsft-webrtc .video.tl .localVideo{top:0;bottom:auto;left:0;right:auto}.bdsft-webrtc .video.tr .localVideo{top:0;bottom:auto;left:auto!important;right:0}.bdsft-webrtc .video.br .localVideo{top:auto;bottom:0;left:auto!important;right:0}.bdsft-webrtc .video._1x .localVideo{width:25%;height:25%}.bdsft-webrtc .video._2x .localVideo{width:50%;height:50%}.bdsft-webrtc .video.audioOnly{display:none!important}.bdsft-webrtc .video.enableSelfView:not(.video-hidden) .localVideo{transition:all 1s linear;opacity:1;z-index:20}.bdsft-webrtc .video.enableSelfView.video-hidden .localVideo{transition:all 1s linear;opacity:0;z-index:-1}.bdsft-webrtc :-webkit-full-screen .remote{z-index:1}.bdsft-webrtc :-webkit-full-screen .localVideo{z-index:2}.bdsft-webrtc :-webkit-full-screen .remote,.bdsft-webrtc :-webkit-full-screen .localVideo{border:0;border-radius:0}.bdsft-webrtc .video{background:url('data:image/svg+xml;base64,<%= videobg %>') no-repeat left center;background-size:cover}"}
},{}],761:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // video.jade compiled template
    templatizer["video"] = function tmpl_video() {
        return '<div class="bdsft-webrtc"><div class="video classes"><div class="content"><video autoplay="autoplay" class="remote"></video><div class="localVideo fadeable"><div class="inner"><video autoplay="autoplay" muted="true" class="local"></video></div></div></div></div></div>';
    };

    // videocontrol.jade compiled template
    templatizer["videocontrol"] = function tmpl_videocontrol() {
        return '<div class="bdsft-webrtc"><div class="video classes"><div class="content"><video autoplay="autoplay" class="remote"></video><div class="localVideo fadeable"><div class="inner"><video autoplay="autoplay" muted="true" class="local"></video></div></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],762:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Video, {
  config: require('../../js/config.js')
});

var Constants = require('webrtc-core').constants
function Video(eventbus, debug, urlconfig, cookieconfig, sipstack, fullscreen) {
  var self = {};

  self.props = ['localStream', 'remoteStream', 'classes', 'visible'];

  self.bindings = {
    'classes': {
      video: ['visible', 'displayResolution', 'enableSelfView', 'selfViewLocation', 'selfViewSize'],
      fullscreen: 'visible',
      sipstack: 'callState',
      urlconfig: ['view', 'hd'],
      cookieconfig: ['hd']
    },
    displayResolution: {
      cookieconfig: 'displayResolution'
    },
    enableSelfView: {
      cookieconfig: 'enableSelfView',
      urlconfig: 'enableSelfView'
    }
  }

  self.validateUserMediaResolution = function(videoWidth, videoHeight) {
    var encodingWidth = sipstack.encodingResolutionWidth();
    var encodingHeight = sipstack.encodingResolutionHeight();
    debug.debug("validating video resolution " + videoWidth + "," + videoHeight + " to match selected encoding " + encodingWidth + "," + encodingHeight);
    if (!videoWidth && !videoHeight) {
      return;
    }

    if (encodingWidth !== videoWidth || encodingHeight !== videoHeight) {
      var msg = "Video resolution " + videoWidth + "," + videoHeight + " does not match selected encoding " + encodingWidth + "," + encodingHeight;
      debug.debug(msg);
    }
  };

  self.listeners = function() {
    eventbus.on("userMediaUpdated", function(e) {
      self.updateStreams([e && e.localStream], []);
    });
    eventbus.on(["iceconnected", "icecompleted"], function(e) {
      self.updateSessionStreams(e.sender);
    });
  };

  self.isMediaFlowing = function(streams) {
    if (!streams || streams.length === 0) {
      return false;
    }
    var tracks = streams.map(function(stream) {
      return stream && stream.getTracks && stream.getTracks();
    });
    if (!tracks) {
      return false;
    }
    tracks = [].concat.apply([], tracks);
    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] && tracks[i].readyState !== 'live') {
        debug.info('track is NOT live : ' + JSON.stringify(tracks[i]));
        return false;
      }
    }
    return true;
  };

  self.hasStream = function(streams) {
    return streams && streams.length > 0 && typeof(streams[0]) !== 'undefined' && !streams[0].ended;
  };

  self.updateSessionStreams = function(session) {
    session = session || sipstack.activeSession;
    if (session) {
      debug.debug("updating session streams : " + session.id);
      self.updateStreams(session.getLocalStreams(), session.getRemoteStreams());
    }
  };

  self.updateStreams = function(localStreams, remoteStreams) {
    debug.debug("updating video streams");
    self.setVideoStream('localStream', localStreams);
    self.setVideoStream('remoteStream', remoteStreams);
  };

  self.setVideoStream = function(localOrRemote, streams) {
    debug.log("setVideoStream : " + localOrRemote + " : " +JSON.stringify(streams));
    var mediaFlowing = self.isMediaFlowing(streams);
    if (!mediaFlowing) {
      debug.info('media is NOT flowing');
    }

    if (self.hasStream(streams)) {
      self[localOrRemote] = streams[0];
    } else {
      self[localOrRemote] = null;
    }
  };

  return self;
}
},{"../../js/config.js":758,"webrtc-core":767}],763:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(VideoView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  image: require('../../js/images')
});

// require('jquery-ui/draggable');

function VideoView(eventbus, debug, video, sipstack) {
  var self = {}; 

  self.model = video;

  self.elements = ['local', 'remote'];

  self.init = function() {
    // Allow some windows to be draggable, required jQuery.UI
    // TODO - allow draggable window
    // if (configuration.enableWindowDrag) {
    //   self.localVideo.draggable && self.localVideo.draggable({
    //     snap: ".remoteVideo,.videoBar",
    //     containment: ".main",
    //     snapTolerance: 200,
    //     stop: function(event, ui) {
    //       settings.updateViewPositions();
    //     }
    //   });
    // }
  };

  self.listeners = function(databinder) {
    // TODO - implement without dependency on history
    // self.view.bind("click", function(e) {
    //   eventbus.viewChanged({visible: false, viewName: 'history'})
    // });
    databinder.onModelPropChange('localStream', function(stream){
      self.playOrEnd(self.localEl(), stream);
    });
    databinder.onModelPropChange('remoteStream', function(stream){
      self.playOrEnd(self.remoteEl(), stream);
    });
    self.local.bind("playing", function() {
      video.validateUserMediaResolution(self.localWidth(), self.localHeight());
    });
    eventbus.on("ended", function(e) {
      debug.debug('ending remote video');
      self.end(self.remoteEl());
      if(!sipstack.enableConnectLocalMedia) {
        debug.debug('ending local video');
        self.end(self.localEl());
      } 
    });
  };

  self.playOrEnd = function(videoEl, stream) {
    if(stream) {
      self.play(videoEl, stream);
    } else {
      self.end(videoEl);
    }
  };

  self.play = function(videoEl, stream) {
    if (videoEl && videoEl.mozSrcObject !== undefined) {
      videoEl.mozSrcObject = stream;
      videoEl.play();
    } else {
      var src = (window.URL && window.URL.createObjectURL(stream)) || stream;
      debug.debug('src : ' + src);
      videoEl.src = src;
    }
  };

  self.end = function(videoEl) {
    if (videoEl.mozSrcObject !== undefined) {
      videoEl.mozSrcObject = null;
    } else {
      videoEl.src = "";
    }
  };

  self.isVideoActive = function(videoEl) {
    return !(videoEl.readyState <= HTMLMediaElement.HAVE_CURRENT_DATA || videoEl.paused || videoEl.currentTime <= 0);
  };

  self.localEl = function() {
    return self.local[0];
  };

  self.remoteEl = function() {
    return self.remote[0];
  };

  self.localWidth = function() {
    return self.local[0].videoWidth;
  };

  self.localHeight = function() {
    return self.local[0].videoHeight;
  };

  return self;
}
},{"../../js/images":759,"../../js/styles":760,"../../js/templates":761,"webrtc-core":767}],764:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],765:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],766:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],767:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":766,"./bdsft":768,"./constants":771,"./cookieconfig":772,"./cookieprop":773,"./dateformat":776,"./debug":777,"./element":778,"./eventbus":779,"./factory":780,"./icon":781,"./loader":782,"./popup":783,"./prop":784,"./urlconfig":786,"./utils":787,"./visibleprop":788,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],768:[function(require,module,exports){
module.exports=require(24)
},{"./app":767,"./binding":769,"./classesbinding":770,"./databinder":775,"./stylesmanager":785,"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":812}],769:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":768,"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],770:[function(require,module,exports){
module.exports=require(26)
},{"./binding":769,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],771:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],772:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":768,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":812,"jquery.cookie":811}],773:[function(require,module,exports){
module.exports=require(29)
},{"./constants":771,"./prop":784,"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":812,"jquery.cookie":811}],774:[function(require,module,exports){
module.exports=require(30)
},{"./constants":771,"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":793}],775:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":796}],776:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],777:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":764,"./bdsft":768,"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":789,"stacktrace-js":814}],778:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],779:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":768,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":796}],780:[function(require,module,exports){
module.exports=require(36)
},{"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":812}],781:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],782:[function(require,module,exports){
module.exports=require(38)
},{"../":767,"./constants":771,"./factory":780,"./stylesmanager":785,"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":792}],783:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":812}],784:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":813}],785:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":765,"./constants":771,"./css":774,"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],786:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":764,"./bdsft":768,"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],787:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":766,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":812}],788:[function(require,module,exports){
module.exports=require(44)
},{"./constants":771,"./prop":784,"./utils":787,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],789:[function(require,module,exports){
module.exports=require(45)
},{"./debug":790,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],790:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":791}],791:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],792:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],793:[function(require,module,exports){
module.exports=require(49)
},{"./filters":794,"./utils":795,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],794:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],795:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],796:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":797,"es5-ext/object/valid-callable":806}],797:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":798,"es5-ext/object/is-callable":801,"es5-ext/object/normalize-options":805,"es5-ext/string/#/contains":808}],798:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":799,"./shim":800,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],799:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],800:[function(require,module,exports){
module.exports=require(56)
},{"../keys":802,"../valid-value":807,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],801:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],802:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":803,"./shim":804,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],803:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],804:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],805:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],806:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],807:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],808:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":809,"./shim":810,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],809:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],810:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],811:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":812}],812:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],813:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],814:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}],815:[function(require,module,exports){
module.exports = {view: require('./lib/views/videobar'), model: require('./lib/models/videobar')};
},{"./lib/models/videobar":819,"./lib/views/videobar":820}],816:[function(require,module,exports){
module.exports = {
    enableHold: true
};
},{}],817:[function(require,module,exports){
module.exports = {"videobar":".bdsft-webrtc .videoBar{position:relative;top:0;left:0;width:100%;height:40px;background:#000;background-image:-ms-linear-gradient(center top,#404040,#000);background-image:linear-gradient(to bottom,#404040,#000);background-image:-webkit-linear-gradient(#404040,#000);background-image:-moz-linear-gradient(top,#404040,#000);border-radius:4px;border:2px solid #ddd;box-shadow:0 0 10px #000;margin-top:5px;background-image:none;border-radius:0;border:0;box-shadow:none;margin-top:0;background:#292929;border-top:1px solid #3c3c3c}.bdsft-webrtc .videoBar .icon{margin:0 2.5px;position:absolute}.bdsft-webrtc .videoBar .table{height:100%;margin:6px;margin:0}.bdsft-webrtc .videoBar .cell{position:relative;top:0;left:0;width:35px;width:36px}.bdsft-webrtc .videoBar .cell .icon{width:100%;text-align:center;margin-top:10px;margin-right:0;margin-left:0}.bdsft-webrtc .videoBar .cell .icon a{margin:0}.bdsft-webrtc .videoBar .cell:first-child{padding:0}.bdsft-webrtc .videoBar span{color:#808080}.bdsft-webrtc .videoBar .unmuteAudio{margin-top:-1px}.bdsft-webrtc .videoBar .leftSpacer{width:8px}.bdsft-webrtc .videoBar .cell-hangup{width:42px}.bdsft-webrtc .videoBar .subtitle{display:none}.bdsft-webrtc .videoBar .timerHolder{position:relative;top:0;left:0;width:auto}.bdsft-webrtc .videoBar .rightSpacer{width:8px}.bdsft-webrtc .videoBar._960x720{width:960px}.bdsft-webrtc .videoBar._640x360,.bdsft-webrtc .videoBar._640x480{width:640px}.bdsft-webrtc .videoBar._320x180,.bdsft-webrtc .videoBar._320x240{width:320px}.bdsft-webrtc .videoBar._1280x720,.bdsft-webrtc .videoBar.hd{width:1280px}.bdsft-webrtc .videoBar._1920x1080{width:1920px}.bdsft-webrtc .hangup,.bdsft-webrtc .fullScreen,.bdsft-webrtc .selfView,.bdsft-webrtc .mute,.bdsft-webrtc .dialpadIcon,.bdsft-webrtc .messages{top:0;left:0}.bdsft-webrtc #videoBar #settings{width:auto;background-color:transparent}.bdsft-webrtc .videoBar.audioOnly{display:inline-block;width:auto}.bdsft-webrtc .videoBar.audioOnly .table{table-layout:auto;width:auto}.bdsft-webrtc .videoBar.audioOnly .cell-hangup{width:35px!important}.bdsft-webrtc .videoBar.conference .cell-hangup{width:30px!important;top:2px}.bdsft-webrtc .videoBar.conference .cell .hangup{margin-top:0;width:140px;background-color:#f00;border-radius:5px;margin-left:10px;height:36px;line-height:14px}.bdsft-webrtc .videoBar.conference .hangup .subtitle{display:block!important;font-size:14px;color:#fff}.bdsft-webrtc .videoBar .icon,.bdsft-webrtc .videoBar a{font-size:20px;color:#808080;text-decoration:none}.bdsft-webrtc .videoBar .hold,.bdsft-webrtc .videoBar .resume{margin-top:-1px}.bdsft-webrtc .videoBar .settings{margin-top:12px!important}.bdsft-webrtc .videoBar .settings .icon-settings{margin:0;font-size:18px;color:#fff}.bdsft-webrtc .videoBar.fullscreen-shown{top:auto!important;bottom:0;position:absolute;width:100%}.bdsft-webrtc .videoBar.conference .icon-hangup:before,.bdsft-webrtc .videoBar.conference .icon-hangup:hover:before{color:#fff!important}.bdsft-webrtc .videoBar.conference .selfViewHide,.bdsft-webrtc .videoBar.conference .selfViewShow{text-align:right!important}.bdsft-webrtc .videoBar.conference .fullscreenExpand,.bdsft-webrtc .videoBar.conference .fullscreenContract{text-align:left!important}.bdsft-webrtc .videoBar.audioOnly .fullscreenExpand,.bdsft-webrtc .videoBar.audioOnly .fullscreenContract,.bdsft-webrtc .videoBar.audioOnly .selfViewHide,.bdsft-webrtc .videoBar.audioOnly .selfViewShow,.bdsft-webrtc .videoBar.audioOnly .fullscreenHolder,.bdsft-webrtc .videoBar.audioOnly .cell-selfView{display:none!important}.bdsft-webrtc .videoBar.selfViewShow a,.bdsft-webrtc .videoBar.dialpadHide a,.bdsft-webrtc .videoBar.unmuteAudio a,.bdsft-webrtc .videoBar.fullscreenContract a{color:#04aff0!important}.bdsft-webrtc .videoBar.started .hangup,.bdsft-webrtc .videoBar.calling .hangup,.bdsft-webrtc .videoBar:not(.held).enableHold.started .hold,.bdsft-webrtc .videoBar.enableHold.held .resume,.bdsft-webrtc .videoBar.enableSettings .settings,.bdsft-webrtc .videoBar.enableSelfView:not(.video-hidden) .selfViewHide,.bdsft-webrtc .videoBar.enableSelfView.video-hidden .selfViewShow,.bdsft-webrtc .videoBar.enableTransfer.started .transfer,.bdsft-webrtc .videoBar.enableCallControl.callcontrol-shown .dialpadHide,.bdsft-webrtc .videoBar.enableCallControl:not(.callcontrol-shown) .dialpadShow{transition:all 1s linear;opacity:1;z-index:20}.bdsft-webrtc .videoBar.connected .hangup,.bdsft-webrtc .videoBar.disconnected .hangup,.bdsft-webrtc .videoBar.held .hold,.bdsft-webrtc .videoBar:not(.started) .hold,.bdsft-webrtc .videoBar:not(.started) .resume,.bdsft-webrtc .videoBar:not(.held) .resume,.bdsft-webrtc .videoBar:not(.enableSettings) .settings,.bdsft-webrtc .videoBar.enableSelfView.video-hidden .selfViewHide,.bdsft-webrtc .videoBar.enableSelfView:not(.video-hidden) .selfViewShow,.bdsft-webrtc .videoBar.enableTransfer.connected .transfer,.bdsft-webrtc .videoBar.enableTransfer.disconnected .transfer,.bdsft-webrtc .videoBar.enableCallControl:not(.callcontrol-shown) .dialpadHide,.bdsft-webrtc .videoBar.enableCallControl.callcontrol-shown .dialpadShow{transition:all 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .videoBar:not(.enableTransfer) .cell-transfer,.bdsft-webrtc .videoBar:not(.enableHold) .cell-hold,.bdsft-webrtc .videoBar:not(.enableCallTimer) .cell-timer,.bdsft-webrtc .videoBar:not(.enableSelfView) .cell-selfView,.bdsft-webrtc .videoBar:not(.enableSettings) .cell-settings,.bdsft-webrtc .videoBar:not(.enableCallControl) .cell-dialpad,.bdsft-webrtc .videoBar:not(.enableMute) .muteHolder,.bdsft-webrtc .videoBar:not(.enableCallTimer) .timerHolder,.bdsft-webrtc .videoBar:not(.enableFullscreen) .fullscreenHolder{display:none!important}"}
},{}],818:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // videobar.jade compiled template
    templatizer["videobar"] = function tmpl_videobar() {
        return '<div class="bdsft-webrtc"><div class="videoBar classes"><div class="table fixed collapse"><div class="cell leftSpacer"></div><div class="cell cell-selfView"><div class="selfViewHide icon fadeable"><a href="" title="Disable Self View" class="icon-selfViewHide"></a></div><div class="selfViewShow icon fadeable"><a href="" title="Enable Self View" class="icon-selfViewShow"></a></div></div><div class="cell cell-dialpad"><div class="dialpadShow icon fadeable"><a href="" title="Show Dialpad" class="icon-dialpadShow"></a></div><div class="dialpadHide icon fadeable"><a href="" title="Hide Dialpad" class="icon-dialpadHide"></a></div></div><div class="cell muteHolder"></div><div class="cell cell-hold"><div class="hold icon fadeable"><a href="" title="Hold Call" class="icon-hold"></a></div><div class="resume icon fadeable"><a href="" title="Resume Call" class="icon-resume"></a></div></div><div class="cell cell-hangup"><div class="hangup icon fadeable"><a href="" title="Hangup" class="icon-hangup"></a><div class="subtitle">End Conference</div></div></div><div class="cell cell-transfer"><div class="transfer icon fadeable"><a href="" title="Transfer" class="icon-transfer"></a></div></div><div class="cell timerHolder"></div><div class="cell cell-settings"><div class="settings icon fadeable"><a href="" title="Settings" class="icon-settings"></a></div></div><div class="cell fullscreenHolder"></div><div class="cell rightSpacer"></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],819:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Videobar, {
  config: require('../../js/config.js')
});

var Constants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function Videobar(sipstack, sound, video, callcontrol, fullscreen, transfer, timer, settings, urlconfig, cookieconfig, audio) {
  var self = {};

  self.props = ['classes'];

  self.bindings = {
    classes: {
        audio: 'enableMute',
        videobar: ['enableHold'],
        sipstack: 'callState',
        fullscreen: ['visible', 'enableFullscreen'],
        video: ['visible', 'displayResolution', 'enableSelfView'],
        callcontrol: ['visible', 'enableCallControl'],
        transfer: 'enableTransfer',
        timer: 'enableCallTimer',
        settings: 'enableSettings',
        urlconfig: ['view', 'hd'],
        cookieconfig: 'hd'
    },
    enableHold: {
      urlconfig: 'enableHold'
    }
  };

  return self;
}
},{"../../js/config.js":816,"webrtc-core":824}],820:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(VideobarView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

var Icon = require('webrtc-core').icon;
var Constants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function VideobarView(eventbus, sipstack, sound, timerView, videobar, callcontrol, video, settings, fullscreenView, audioView, transfer) {
  var self = {};

  self.elements = ['transfer', 'settings', 'dialpadShow', 'dialpadHide', 'timerHolder', 'fullscreenHolder', 'muteHolder', 'hangup', 'selfViewShow', 'selfViewHide',
   'hold', 'resume', 'cell'
  ];

  var clickHander = function(callback){
    return function(e) {
      e.preventDefault();
      sound.playClick();
      callback();
    }
  }

  self.insertView = function(view, position) {
    view.view.insertAfter(self.cell[position]);
  };

  self.init = function() {
    fullscreenView.view.appendTo(self.fullscreenHolder);
    audioView.view.appendTo(self.muteHolder);
    timerView.view.appendTo(self.timerHolder);
  };

  self.listeners = function() {
    self.hold = new Icon(self.hold, sound);
    self.resume = new Icon(self.resume, sound);

    eventbus.on(['held', 'resumed'], function(e) {
      self.hold.enable();
      self.resume.enable();
    });
    self.transfer.bind('click', clickHander(function() {
      transfer.toggle();
    }));
    self.settings.bind('click', clickHander(function() {
      settings.toggle();
    }));
    self.dialpadShow.bind('click', clickHander(function() {
      callcontrol.show();
    }));
    self.dialpadHide.bind('click', clickHander(function() {
      callcontrol.hide();
    }));
    self.selfViewHide.bind('click', clickHander(function() {
      video.visible = false;
    }));
    self.selfViewShow.bind('click', clickHander(function() {
      video.visible = true;
    }));
    self.hold.onClick(function(e) {
      self.hold.disable();
      sipstack.hold();
    });
    self.resume.onClick(function(e) {
      self.resume.disable();
      sipstack.unhold();
    });
    self.hangup.bind('click', clickHander(function() {
      eventbus.endCall();
    }));

  };

  return self;
}
},{"../../js/styles":817,"../../js/templates":818,"webrtc-core":824}],821:[function(require,module,exports){
module.exports=require(20)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":20}],822:[function(require,module,exports){
module.exports=require(21)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":21}],823:[function(require,module,exports){
module.exports=require(22)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":22}],824:[function(require,module,exports){
module.exports=require(23)
},{"./adapter":823,"./bdsft":825,"./constants":828,"./cookieconfig":829,"./cookieprop":830,"./dateformat":833,"./debug":834,"./element":835,"./eventbus":836,"./factory":837,"./icon":838,"./loader":839,"./popup":840,"./prop":841,"./urlconfig":843,"./utils":844,"./visibleprop":845,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":23}],825:[function(require,module,exports){
module.exports=require(24)
},{"./app":824,"./binding":826,"./classesbinding":827,"./databinder":832,"./stylesmanager":842,"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":24,"jquery":869}],826:[function(require,module,exports){
module.exports=require(25)
},{"./bdsft":825,"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":25}],827:[function(require,module,exports){
module.exports=require(26)
},{"./binding":826,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":26}],828:[function(require,module,exports){
module.exports=require(27)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":27}],829:[function(require,module,exports){
module.exports=require(28)
},{"./bdsft":825,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":28,"jquery":869,"jquery.cookie":868}],830:[function(require,module,exports){
module.exports=require(29)
},{"./constants":828,"./prop":841,"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":29,"jquery":869,"jquery.cookie":868}],831:[function(require,module,exports){
module.exports=require(30)
},{"./constants":828,"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":30,"ejs":850}],832:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":31,"event-emitter":853}],833:[function(require,module,exports){
module.exports=require(32)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":32}],834:[function(require,module,exports){
module.exports=require(33)
},{"../js/config":821,"./bdsft":825,"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":33,"debug":846,"stacktrace-js":871}],835:[function(require,module,exports){
module.exports=require(34)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":34}],836:[function(require,module,exports){
module.exports=require(35)
},{"./bdsft":825,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":35,"event-emitter":853}],837:[function(require,module,exports){
module.exports=require(36)
},{"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":36,"jquery":869}],838:[function(require,module,exports){
module.exports=require(37)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":37}],839:[function(require,module,exports){
module.exports=require(38)
},{"../":824,"./constants":828,"./factory":837,"./stylesmanager":842,"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":38,"deep-extend":849}],840:[function(require,module,exports){
module.exports=require(39)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":39,"jquery":869}],841:[function(require,module,exports){
module.exports=require(40)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":40,"observe-js":870}],842:[function(require,module,exports){
module.exports=require(41)
},{"../js/styles":822,"./constants":828,"./css":831,"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":41}],843:[function(require,module,exports){
module.exports=require(42)
},{"../js/config":821,"./bdsft":825,"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":42}],844:[function(require,module,exports){
module.exports=require(43)
},{"./adapter":823,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":43,"jquery":869}],845:[function(require,module,exports){
module.exports=require(44)
},{"./constants":828,"./prop":841,"./utils":844,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":44}],846:[function(require,module,exports){
module.exports=require(45)
},{"./debug":847,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":45}],847:[function(require,module,exports){
module.exports=require(46)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":46,"ms":848}],848:[function(require,module,exports){
module.exports=require(47)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":47}],849:[function(require,module,exports){
module.exports=require(48)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":48,"buffer":8}],850:[function(require,module,exports){
module.exports=require(49)
},{"./filters":851,"./utils":852,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":49,"fs":7,"path":12}],851:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":50}],852:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":51}],853:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":52,"d":854,"es5-ext/object/valid-callable":863}],854:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":53,"es5-ext/object/assign":855,"es5-ext/object/is-callable":858,"es5-ext/object/normalize-options":862,"es5-ext/string/#/contains":865}],855:[function(require,module,exports){
module.exports=require(54)
},{"./is-implemented":856,"./shim":857,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":54}],856:[function(require,module,exports){
module.exports=require(55)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":55}],857:[function(require,module,exports){
module.exports=require(56)
},{"../keys":859,"../valid-value":864,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":56}],858:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":57}],859:[function(require,module,exports){
module.exports=require(58)
},{"./is-implemented":860,"./shim":861,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":58}],860:[function(require,module,exports){
module.exports=require(59)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":59}],861:[function(require,module,exports){
module.exports=require(60)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":60}],862:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":61}],863:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":62}],864:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":63}],865:[function(require,module,exports){
module.exports=require(64)
},{"./is-implemented":866,"./shim":867,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":64}],866:[function(require,module,exports){
module.exports=require(65)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":65}],867:[function(require,module,exports){
module.exports=require(66)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":66}],868:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":67,"jquery":869}],869:[function(require,module,exports){
module.exports=require(68)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":68}],870:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":69}],871:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":70}]},{},[1]);
